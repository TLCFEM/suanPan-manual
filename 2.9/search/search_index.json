{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>This repository provides the user manual for suanPan. If you are browsing the GitHub repository, please visit https://tlcfem.github.io/suanPan-manual/latest/ for a better presentation.</p> <p>The manual is also hosted on https://tlcfem.gitbook.io/suanpan-manual/, which always contains the latest version of the manual. This serves as an alternative if the mkdocs theme is not preferred.</p> <p>I'm still working on this site from time to time. Hence, it is unlikely to get a complete reference by solely checking this site. For any potential doubts, please feel free to contact me.</p>"},{"location":"#where-to-start","title":"Where to Start?","text":"<p>It is not easy to pick up a new finite element analysis tool, but it is not impossible. The logic of input files resembles that of ABAQUS. If you have some experience with ABAQUS, it shall be easy to create a simple model by hand.</p> <p>After a simple demo presented in Analyze, you are recommended to check out Syntax and Structure to gain an overall picture of what an input file would look like.</p> <p>The <code>Example</code> section includes a number of examples with various degrees of complexity, check the ones you are familiar with, or simple ones such as Linear Analysis of A Truss Roof and Dynamic Analysis of A Portal Frame, as the starting point.</p> <p>The <code>Collection</code> section includes the top level commands used to develop finite element models.</p> <p>The <code>Library</code> section contains all specific elements, materials, etc., that are available.</p>"},{"location":"#summary","title":"Summary","text":"<p>Here is a complete table of contents. If you are interested in the architecture of the program, you can check the slides I prepared for a talk.</p>"},{"location":"#about","title":"About","text":"<p>Many FEM packages are available out there, so why another package? Commercial packages are great, but may be too expensive for individuals to get access to. The limited extensibility is another pain in the butt. Modern programming paradigms for parallel computing have evolved a lot in recent years. C++ itself has also received a huge number of updates starting from <code>C++11</code>. <code>suanPan</code> is basically a practice of modern parallel computing with brand-new language features. The civil/structural community also needs an update of new tools for efficient numerical analysis. <code>suanPan</code> is designed to offer a concise but highly extensible framework for finite element analysis. With the assist of <code>Armadillo</code>, the syntax of which is expressive, researchers can try out new ideas easily.</p>"},{"location":"#contribution","title":"Contribution","text":"<p>To contribute, please create pull requests. Besides, if you find any typos, please also feel free to create issues.</p> <p>All third party libraries must provide a single markdown file to explain how to use the library and if possible with some theories.</p> <p>It may be convenient to build the manual locally, please check Build for more details.</p>"},{"location":"#citation","title":"Citation","text":"<p>If <code>suanPan</code> has offered some convenience to your research work, please consider visiting 10.5281/zenodo.1285221 and citing any version appropriate.</p>"},{"location":"SUMMARY/","title":"Introduction","text":"<ul> <li>Introduction</li> </ul>"},{"location":"SUMMARY/#basic","title":"Basic","text":"<ul> <li>Obtain Application</li> <li>Configure Application</li> <li>Perform Analysis</li> <li>Model Syntax</li> <li>Model Structure</li> <li>Tweak Performance</li> <li>Compile Application</li> <li>Build Documentation</li> </ul>"},{"location":"SUMMARY/#example","title":"Example","text":"<ul> <li>Developer<ul> <li>element template</li> <li>material template</li> </ul> </li> <li>Solid<ul> <li>wave propagation</li> </ul> </li> <li>Geotechnical<ul> <li>triaxial compression of sand</li> </ul> </li> <li>Structural<ul> <li>Statics<ul> <li>bending of a cantilever beam</li> <li>bifurcation of a cantilever beam</li> <li>double-edge notched specimen</li> <li>lees frame</li> <li>notched beam under cyclic loading</li> <li>rc section analysis</li> <li>truss roof</li> <li>uniform tension of a rubber specimen</li> </ul> </li> <li>Dynamics<ul> <li>bouncing of a ball</li> <li>mass-spring-dashpot system</li> <li>dynamic analysis of a portal frame</li> <li>particle collision</li> <li>response history analysis of an elastic coupled wall</li> <li>multi-support excitation</li> <li>triple pendulum</li> <li>computing response spectrum</li> <li>integrate with python</li> </ul> </li> <li>Hybrid<ul> <li>vibration of a displaced beam</li> </ul> </li> <li>Buckling<ul> <li>buckling analysis of a cantilever beam</li> </ul> </li> <li>Contact<ul> <li>contact between beam and block</li> <li>contact in 3d space</li> </ul> </li> <li>Optimization<ul> <li>evolutionary structural optimization</li> </ul> </li> <li>Isogeometric Analysis<ul> <li>linear analysis of a single element</li> </ul> </li> </ul> </li> <li>Miscellaneous<ul> <li>batch execution for automation</li> </ul> </li> </ul>"},{"location":"SUMMARY/#command-collection","title":"Command Collection","text":"<ul> <li>Define<ul> <li>amplitude</li> <li>bc</li> <li>domain</li> <li>element</li> <li>expression</li> <li>file</li> <li>generate</li> <li>group</li> <li>import</li> <li>initial</li> <li>load</li> <li>material</li> <li>modifier</li> <li>node</li> <li>recorder</li> <li>section</li> </ul> </li> <li>Configure<ul> <li>analyze</li> <li>converger</li> <li>criterion</li> <li>integrator</li> <li>precheck</li> <li>step</li> </ul> </li> <li>Process<ul> <li>benchmark</li> <li>clear</li> <li>command</li> <li>enable</li> <li>exit</li> <li>materialtest</li> <li>materialtestbyload</li> <li>peek</li> <li>plot</li> <li>protect</li> <li>pwd</li> <li>reset</li> <li>save</li> <li>set</li> <li>upsampling</li> <li>sdof_response</li> <li>response_spectrum</li> </ul> </li> </ul>"},{"location":"SUMMARY/#model-library","title":"Model Library","text":""},{"location":"SUMMARY/#amplitude","title":"Amplitude","text":"<ul> <li>Amplitude</li> <li>Special<ul> <li>NZStrongMotion</li> </ul> </li> <li>Universal<ul> <li>Combine</li> <li>Constant</li> <li>Decay</li> <li>Linear</li> <li>Modulated</li> <li>Tabular</li> <li>TabularSpline</li> <li>Trig</li> </ul> </li> </ul>"},{"location":"SUMMARY/#constraint","title":"Constraint","text":"<ul> <li>MPC</li> <li>ParticleCollision</li> <li>RigidWall</li> <li>RestitutionWall</li> <li>FixedLength</li> <li>NodeLine</li> <li>NodeFacet</li> <li>Embed2D</li> <li>Embed3D</li> </ul>"},{"location":"SUMMARY/#converger","title":"Converger","text":"<ul> <li>Converger</li> <li>Absolute<ul> <li>AbsDisp</li> <li>AbsError</li> <li>AbsIncreDisp</li> <li>AbsIncreAcc</li> <li>AbsIncreEnergy</li> <li>AbsResidual</li> </ul> </li> <li>Other<ul> <li>FixedNumber</li> <li>Logic</li> </ul> </li> <li>Relative<ul> <li>RelDisp</li> <li>RelError</li> <li>RelIncreDisp</li> <li>RelIncreAcc</li> <li>RelIncreEnergy</li> <li>RelResidual</li> </ul> </li> </ul>"},{"location":"SUMMARY/#criterion","title":"Criterion","text":"<ul> <li>Criterion</li> <li>MaxDisplacement</li> <li>MaxHistory</li> <li>MaxResistance</li> <li>MinDisplacement</li> <li>MinResistance</li> <li>StrainEnergyEvolution</li> </ul>"},{"location":"SUMMARY/#element","title":"Element","text":"<ul> <li>Beam<ul> <li>B21</li> <li>B21E</li> <li>B21H</li> <li>B31</li> <li>EB21</li> <li>F21</li> <li>F21H</li> <li>F31</li> <li>NMB21</li> <li>NMB21E</li> <li>NMB31</li> <li>MVLEM</li> <li>Orientation</li> </ul> </li> <li>Cube<ul> <li>C3D20</li> <li>C3D4</li> <li>C3D8</li> <li>C3D8I</li> <li>CIN3D8</li> <li>DC3D4</li> <li>DC3D8</li> </ul> </li> <li>Membrane<ul> <li>Couple Stress</li> <li>Phase Field<ul> <li>DCP3</li> <li>DCP4</li> </ul> </li> <li>Axisymmetric<ul> <li>CAX3</li> <li>CAX4</li> <li>CAX8</li> </ul> </li> <li>Plane<ul> <li>CP3</li> <li>CP4</li> <li>CP4I</li> <li>CP5</li> <li>CP6</li> <li>CP7</li> <li>CP8</li> </ul> </li> <li>Mixed<ul> <li>PS</li> <li>QE2</li> </ul> </li> <li>Drilling<ul> <li>Allman</li> <li>GCMQ</li> <li>GQ12</li> </ul> </li> <li>Infinite<ul> <li>CINP4</li> </ul> </li> <li>Geotechnical<ul> <li>PCPE4DC</li> </ul> </li> <li>Membrane</li> </ul> </li> <li>Modifier<ul> <li>Modifier</li> </ul> </li> <li>Patch<ul> <li>Patch</li> <li>PatchCube</li> <li>PatchQuad</li> </ul> </li> <li>Plate<ul> <li>DKT3</li> <li>DKT4</li> <li>Mindlin</li> </ul> </li> <li>Shell<ul> <li>DKTS3</li> <li>DKTS4</li> <li>S4</li> <li>SGCMS</li> <li>ShellBase</li> </ul> </li> <li>Special<ul> <li>Contact2D</li> <li>Contact3D</li> <li>Damper01</li> <li>Damper02</li> <li>Embedded2D</li> <li>Embedded3D</li> <li>Joint</li> <li>Mass</li> <li>SingleSection</li> <li>Spring01</li> <li>Spring02</li> <li>Tie</li> </ul> </li> <li>Truss<ul> <li>T2D2</li> <li>T2D2S</li> <li>T3D2</li> <li>T3D2S</li> </ul> </li> </ul>"},{"location":"SUMMARY/#integrator","title":"Integrator","text":"<ul> <li>Implicit<ul> <li>Linear</li> <li>BatheTwoStep</li> <li>GeneralizedAlpha</li> <li>OALTS</li> <li>GSSSS</li> <li>Newmark<ul> <li>LeeNewmark</li> <li>LeeNewmarkFull</li> <li>Newmark</li> <li>RayleighNewmark</li> <li>WilsonPenzienNewmark</li> </ul> </li> </ul> </li> <li>Explicit<ul> <li>Tchamwa</li> <li>BatheExplicit</li> <li>GeneralizedAlphaExplicit</li> </ul> </li> </ul>"},{"location":"SUMMARY/#material","title":"Material","text":"<ul> <li>Guide<ul> <li>Metal</li> <li>Customisation</li> </ul> </li> <li>Material1D<ul> <li>Concrete<ul> <li>ConcreteCM</li> <li>ConcreteExp</li> <li>ConcreteTsai</li> </ul> </li> <li>Degradation<ul> <li>Degradation</li> </ul> </li> <li>Elastic<ul> <li>BilinearElastic1D</li> <li>Elastic1D</li> <li>MultilinearElastic1D</li> <li>PolyElastic1D</li> <li>NLE1D01</li> <li>Sinh1D</li> <li>Tanh1D</li> <li>CustomElastic1D</li> </ul> </li> <li>Hysteresis<ul> <li>AFC</li> <li>AFCN</li> <li>BilinearOO</li> <li>BilinearPO</li> <li>BoucWen</li> <li>BWBN</li> <li>Flag</li> <li>MPF</li> <li>MultilinearOO</li> <li>MultilinearPO</li> <li>RambergOsgood</li> <li>SimpleHysteresis</li> <li>SlipLock</li> <li>SteelBRB</li> <li>Trivial</li> </ul> </li> <li>Viscosity<ul> <li>Kelvin</li> <li>Maxwell</li> <li>NonlinearViscosity</li> <li>BilinearViscosity</li> <li>CustomViscosity</li> <li>Viscosity01</li> <li>Viscosity02</li> <li>CoulombFriction</li> </ul> </li> <li>vonMises<ul> <li>ArmstrongFrederick1D</li> <li>Bilinear1D</li> <li>BilinearMises1D</li> <li>CustomGurson1D</li> <li>CustomMises1D</li> <li>ExpGurson1D</li> <li>ExpMises1D</li> <li>Mises1D</li> <li>Multilinear1D</li> <li>NonlinearGurson1D</li> <li>VAFCRP1D</li> </ul> </li> </ul> </li> <li>Material2D<ul> <li>AxisymmetricElastic</li> <li>Bilinear2D</li> <li>Concrete21</li> <li>Concrete22</li> <li>Elastic2D</li> <li>Rebar2D</li> </ul> </li> <li>Material3D<ul> <li>CamClay<ul> <li>BilinearCC</li> <li>ExpCC</li> <li>NonlinearCamClay</li> <li>ParabolicCC</li> </ul> </li> <li>Concrete<ul> <li>CDP</li> <li>CDPM2</li> <li>Rebar3D</li> <li>TableCDP</li> <li>CustomCDP</li> </ul> </li> <li>Damage<ul> <li>IsotropicDamage</li> <li>LinearDamage</li> </ul> </li> <li>DruckerPrager<ul> <li>BilinearDP</li> <li>ExpDP</li> <li>CustomDP</li> <li>NonlinearDruckerPrager</li> </ul> </li> <li>Elastic<ul> <li>BlatzKo</li> <li>IsotropicElastic3D</li> <li>IsotropicNonlinearElastic3D</li> <li>MooneyRivlin</li> <li>NLE3D01</li> <li>OrthotropicElastic3D</li> <li>Yeoh</li> </ul> </li> <li>Hoffman<ul> <li>BilinearHoffman</li> <li>ExpHoffman</li> <li>CustomHoffman</li> <li>NonlinearHill</li> <li>NonlinearHoffman</li> </ul> </li> <li>Sand<ul> <li>SimpleSand</li> <li>DafalisaManzari</li> </ul> </li> <li>vonMises<ul> <li>ArmstrongFrederick</li> <li>BilinearJ2</li> <li>BilinearPeric</li> <li>CustomGurson</li> <li>CustomJ2</li> <li>ExpGurson</li> <li>ExpJ2</li> <li>MultilinearJ2</li> <li>NonlinearGurson</li> <li>NonlinearJ2</li> <li>NonlinearPeric</li> <li>PolyJ2</li> <li>VAFCRP</li> </ul> </li> </ul> </li> <li>Wrapper<ul> <li>Axisymmetric</li> <li>Laminated</li> <li>Parallel</li> <li>PlaneStrain</li> <li>PlaneSymmetric</li> <li>PlaneStress</li> <li>Rotation2D</li> <li>Rotation3D</li> <li>Sequential</li> <li>Stacked</li> <li>Uniaxial</li> </ul> </li> </ul>"},{"location":"SUMMARY/#recorder","title":"Recorder","text":"<ul> <li>Recorder</li> <li>OutputType</li> </ul>"},{"location":"SUMMARY/#section","title":"Section","text":"<ul> <li>Code<ul> <li>EU</li> <li>NZ</li> <li>US</li> </ul> </li> <li>Section1D<ul> <li>Circle1D</li> <li>Fibre1D</li> <li>Rectangle1D</li> <li>TrussSection</li> </ul> </li> <li>Section2D<ul> <li>Bar2D</li> <li>Box2D</li> <li>Circle2D</li> <li>CircularHollow2D</li> <li>Fibre2D</li> <li>HSection2D</li> <li>ISection2D</li> <li>Rectangle2D</li> <li>TSection2D</li> </ul> </li> <li>Section3D<ul> <li>Bar3D</li> <li>Box3D</li> <li>Circle3D</li> <li>CircularHollow3D</li> <li>Fibre3D</li> <li>ISection3D</li> <li>Rectangle3D</li> <li>TSection3D</li> </ul> </li> <li>SectionNM<ul> <li>SectionNM</li> <li>NM2D1</li> <li>NM2D2</li> <li>NM3D1</li> <li>NM3D2</li> </ul> </li> </ul>"},{"location":"SUMMARY/#solver","title":"Solver","text":"<ul> <li>BFGS</li> <li>MPDC</li> <li>Newton</li> <li>Ramm</li> </ul>"},{"location":"SUMMARY/#step","title":"Step","text":"<ul> <li>ArcLength</li> <li>Buckle</li> <li>Dynamic</li> <li>Frequency</li> <li>Optimization</li> <li>Static</li> </ul>"},{"location":"SUMMARY/#developer","title":"Developer","text":"<ul> <li>Prerequisites</li> <li>C Style Interface<ul> <li>material</li> </ul> </li> <li>CPP Style Interface<ul> <li>material</li> <li>element</li> <li>constraint</li> </ul> </li> </ul>"},{"location":"Basic/Analyze/","title":"Analyze","text":"<p>This page aims to show an overview of how a model looks like by establishing a simple model, which is a simple elastic cantilever beam subjected to an end load.</p> <p>A native CPP parser is used by <code>suanPan</code>. The default syntax resembles the one of <code>OpenSees</code>. Model files are written in plain text. Although there is no restriction, the suffix <code>.supan</code> is reserved by default.</p> <p>The line starts with the hash symbol (<code>#</code>) or the exclamation symbol (<code>!</code>) is a comment line. To write one command spans a few lines, please use backslash (<code>\\</code>) to concatenate multiple lines. Please refer to Syntax for details.</p> Text Only<pre><code># defines two nodes at (0,0) and (1.34,0)\nnode 1 0 0\nnode 2 1.34 0\n\n# define an elastic material with the elastic modulus of 132\nmaterial Elastic1D 1 132\n\n# define an (E)lastic (B)eam element 1 connecting node 1 and node 2 with A=7.213 and I=6.825 using material 1\nelement EB21 1 1 2 7.213 6.825 1\n\n# fix all DoFs (P) of node 1\nfix 1 P 1\n\n# apply a load of magnitude 23 at DoF 2 of node 2\ncload 1 0 23 2 2\n# apply another load of magnitude 17 at DoF 1 of node 2\ncload 2 0 17 1 2\n\n# create a static step\nstep static 1\n\nanalyze\n\n# print the state of node 2\npeek node 2\n\nexit\n</code></pre> <p>Since each command is commented, there is not much to explain. This model is similar to the one created by the <code>example</code> command, both are simple one element models. The output is directly printed on screen by default. For this model, it is</p> Text Only<pre><code>+--------------------------------------------------+\n|   __        __         suanPan is an open source |\n|  /  \\      |  \\           FEM framework (64-bit) |\n|  \\__       |__/  __   __           Acrux (1.0.0) |\n|     \\ |  | |    |  \\ |  |      maintained by tlc |\n|  \\__/ |__| |    |__X |  |    all rights reserved |\n|                           10.5281/zenodo.1285221 |\n+--------------------------------------------------+\n|  https://github.com/TLCFEM/suanPan               |\n|  https://github.com/TLCFEM/suanPan-manual        |\n+--------------------------------------------------+\n|  https://gitter.im/suanPan-dev/community         |\n+--------------------------------------------------+\n\ncurrent analysis time: 1.00000.\nNode 2:\n   1.3400        0\nDisplacement:\n   0.0239   0.0205   0.0229\nResistance:\n   1.7000E+01   2.3000E+01  -3.0820E-07\n\nFinished in 0.015 seconds.\n</code></pre> <p>The analytical solution of horizontal tip displacement is</p> \\[ u=\\dfrac{PL}{EA}=\\dfrac{17\\times1.34}{132\\times7.213}=0.023926. \\] <p>The analytical solution of vertical tip displacement is</p> \\[ u=\\dfrac{PL^3}{3EI}=\\dfrac{23\\times1.34^3}{3\\times132\\times6.835}=0.020476. \\]"},{"location":"Basic/Build/","title":"Build Manual","text":"<p>This manual can be built locally using <code>mkdocs</code>. To do so, a python environment must be created.</p>"},{"location":"Basic/Build/#tools","title":"Tools","text":"<p><code>git</code> shall be available to clone the repository. Otherwise, you may want to manually download the archive.</p> <p><code>python</code> shall be available to build the documentation.</p> <p>If <code>doxygen</code> generated documentation is required, <code>doxygen</code> shall be available. It also uses <code>graphviz</code> to generate the graph, install it according to the instructions.</p>"},{"location":"Basic/Build/#steps","title":"Steps","text":"<p>Please follow the instructions below to create a local editing environment.</p>"},{"location":"Basic/Build/#clone-the-repository","title":"Clone the Repository","text":"<p>Clone the repository using the following command:</p> Bash<pre><code>git clone https://github.com/TLCFEM/suanPan-manual.git\ncd suanPan-manual\n</code></pre>"},{"location":"Basic/Build/#create-a-python-environment","title":"Create a Python Environment","text":"<p>Within the <code>suanPan-manual</code> directory, create a new virtual environment using whatever tools you have available. Here the plain python virtual environment is used.</p> Bash<pre><code>python3 -m venv venv\nsource venv/bin/activate\n</code></pre>"},{"location":"Basic/Build/#install-requirements","title":"Install Requirements","text":"<p>Now that the virtual environment is created, install the requirements using the following command:</p> Bash<pre><code>python -m pip install -r requirements.txt\n</code></pre> <p>Alternatively, if the <code>doxygen</code> documentation is required, the following command can be used:</p> Bash<pre><code>python -m pip install -e .\n</code></pre> <p>Note <code>doxygen</code> and <code>git</code> are required to be available. This also installs a custom mkdocs plugin to overwrite inline math expressions to properly render them.</p>"},{"location":"Basic/Build/#build-and-run","title":"Build and Run","text":"<p>The following command builds and runs the server on <code>localhost:8000</code>.</p> Bash<pre><code>mkdocs serve\n</code></pre>"},{"location":"Basic/Build/#make-changes","title":"Make Changes","text":"<p>The server monitors changes in real time. Now you can make changes to the manual and check the changes in the browser.</p>"},{"location":"Basic/Compile/","title":"Compile","text":""},{"location":"Basic/Compile/#docker-images","title":"Docker Images","text":"<p>For Linux users, if there is no access to <code>sudo</code> but can build containers with Docker, it is possible to compile the  project with  Docker. Check the provided Dockerfiles for more information.</p> <p>Once the container is built, the <code>.tar.gz</code> will be placed under <code>/</code>. Simply copy them out and install/unpack the  archive. The <code>.deb</code> or <code>.rpm</code> packages are installed in the images, so they can be used directly. </p> <p>The following is a general guide that covers three main operating systems.</p>"},{"location":"Basic/Compile/#prerequisites","title":"Prerequisites","text":"<ol> <li>To configure the source code, CMake shall be available. Please download and install it    before configuring the source code package.</li> <li>The linear algebra driver used is OpenBLAS. You may want to compile it with the    optimal configuration based on the specific machine. Otherwise, precompiled binaries (dynamic platform) are available    in this repository.</li> <li>It is strongly recommended installing Intel MKL for potentially better performance.</li> <li>Please be aware that MKL is throttled on AMD platforms. Performance comparisons can be seen for    example here. If you have AMD CPUs please collect    more knowledge to determine which linear algebra library is more suitable.</li> </ol>"},{"location":"Basic/Compile/#toolsets","title":"Toolsets","text":"<p>A number of new features from new standards are utilized. To compile the binary, a compiler that supports C++20 is required.</p> <p>GCC 11, Clang 13, MSVC 14.3, Intel compilers and later version of those compilers are tested with the source code.</p> <p>On Windows, Visual Studio 2022 with Intel oneAPI toolkit is recommended. Alternatively, WinLibs can be used if GCC compilers are preferred.</p> <p>On other platforms (Linux and macOS), simply use GCC (at least version 10) which comes with a valid Fortran compiler. Clang can also be used for C/CPP code, but since Clang and GCC have different supports for C++20, successful compilation is not guaranteed with Clang.</p>"},{"location":"Basic/Compile/#obtain-source-code","title":"Obtain Source Code","text":"<p>Download the source code archive from GitHub Releases or the latest code.</p>"},{"location":"Basic/Compile/#configure-and-compile","title":"Configure and Compile","text":"<p>The manual compilation is not difficult in general. The CI/CD configuration files can be referred to if you wish. Please check this page. Here some general guidelines are given.</p>"},{"location":"Basic/Compile/#visual-studio","title":"Visual Studio","text":"<p>A solution file is provided under <code>MSVC/suanPan</code> folder. There are two configurations:</p> <ol> <li><code>Debug</code>: Assume no available Fortran compiler, all Fortran related libraries are provided as precompiled DLLs. Use    OpenBLAS for linear algebra. Multithreading disabled. Visualisation disabled. HDF5 support disabled.</li> <li><code>Release</code>: Fortran libraries are configured with Intel compilers. Use MKL for linear algebra. Multithreading enabled.    Visualisation enabled with VTK version 9.2. HDF5 support enabled. CUDA enabled.</li> </ol> <p>This repository contains some precompiled libraries used.</p> <p>If Intel oneAPI Toolkit and CUDA are not installed, only the <code>Debug</code> configuration can be successfully compiled. Simply open the solution and switch to Debug configuration, ignore all potential warnings and build the solution.</p> <p>To compile <code>Release</code> version, please</p> <ol> <li> <p>Make sure oneAPI both base and HPC toolkits, as well as VS integration, are installed. Be aware of this issue     if you are using VS 2022: Microsoft Visual Studio 2022 Version 17.2 and Newer Fails to Integrate with the Intel     Fortran Compiler.    The MKL is enabled via integrated option <code>&lt;UseInteloneMKL&gt;Parallel&lt;/UseInteloneMKL&gt;</code>.</p> </li> <li> <p>Make sure CUDA is installed. The environment variable <code>$(CUDA_PATH)</code> is used to locate headers.</p> </li> <li> <p>Make sure VTK is available. Then define two system environment variables <code>$(VTK_INC)</code> and <code>$(VTK_LIB)</code>, which point    to include and library folders. On my machine, they are</p> </li> </ol> PowerShell<pre><code>VTK_INC=C:\\Program Files\\VTK\\include\\vtk-9.2\nVTK_LIB=C:\\Program Files\\VTK\\lib\n</code></pre> <p>For versions other than 9.2, names of the linked libraries shall be manually changed as they contain version numbers.    Thus, it is not a good idea to switch to a different version. Precompiled VTK library is also available in    this repository</p> <p>Alternatively, <code>CMake</code> can be used to generate solution files if some external packages are not available.</p>"},{"location":"Basic/Compile/#ubuntu","title":"Ubuntu","text":"<p>The following instructions are based on Ubuntu 20.04. CMake is used to manage builds. It is recommended to use CMake GUI if appropriate.</p> <ol> <li>Install necessary tools.</li> </ol> Bash<pre><code>sudo apt-get install gcc-10 g++-10 gfortran-10 git cmake libomp5 -y\n</code></pre> <ol> <li>Clone the project.</li> </ol> Bash<pre><code>git clone -b master https://github.com/TLCFEM/suanPan.git\n</code></pre> <ol> <li>Create build folder and configure via CMake. The default configuration disables parallelism <code>-DBUILD_MULTITHREAD=OFF</code>    and enables HDF5 via bundled library <code>-DUSE_HDF5=ON</code>. Please    check <code>Option.cmake</code> file or use GUI for available    options.</li> </ol> Bash<pre><code>cd suanPan &amp;&amp; mkdir build &amp;&amp; cd build\ncmake ../\n</code></pre> <ol> <li>Invoke <code>make</code>.</li> </ol> Bash<pre><code>make -j4\n</code></pre> <p>Check the following recording.</p> <p></p>"},{"location":"Basic/Compile/#install-vtk","title":"Install VTK","text":"<p>Ubuntu official repository does not (Fedora does!) contain the latest VTK library. It's better to compile it manually.</p> <ol> <li>Install OpenGL first, as well as compilers if necessary.</li> </ol> Bash<pre><code>sudo apt install gcc-10 g++-10 gfortran-10 libglu1-mesa-dev freeglut3-dev mesa-common-dev libglvnd-dev\n</code></pre> <ol> <li>Obtain VTK source code and unpack.</li> </ol> Bash<pre><code>wget https://www.vtk.org/files/release/9.1/VTK-9.1.0.tar.gz\ntar -xf VTK-9.1.0.tar.gz\n</code></pre> <ol> <li>Create folder for building VTK.</li> </ol> Bash<pre><code>mkdir VTK-build &amp;&amp; cd VTK-build\n</code></pre> <ol> <li>Configure and compile VTK library. If necessary, installation destination can be modified. Here static libraries are    built.</li> </ol> Bash<pre><code>cmake -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=OFF -DCMAKE_INSTALL_PREFIX=../VTK-out ../VTK-9.1.0\nmake install -j4\n</code></pre> <ol> <li>Now obtain <code>suanPan</code> source code and unpack it. To configure it with VTK support, users may use the following    flag <code>-DUSE_EXTERNAL_VTK=ON</code>. If <code>FindVTK</code> is presented and <code>VTK</code> is installed to default location, there is no need    to provide the variable <code>VTK_DIR</code>, otherwise point it to the <code>lib/cmake/vtk-9.1</code> folder.</li> </ol>"},{"location":"Basic/Compile/#install-mkl","title":"Install MKL","text":"<p>The provided CMake configuration covers both <code>oneMKL</code> and <code>Intel MKL 2020</code>. Please note MKL is included in oneAPI toolkit starting from 2021, which has a different folder structure compared to Intel Parallel Studio.</p> <p>The following guide is a manual installation is based on Ubuntu terminal using the official repository. See this page for details.</p> <ol> <li>Add repository. To summarise,</li> </ol> Bash<pre><code>wget https://apt.repos.intel.com/intel-gpg-keys/GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB\nsudo apt-key add GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB\necho \"deb https://apt.repos.intel.com/oneapi all main\" | sudo tee /etc/apt/sources.list.d/oneAPI.list </code></pre> <ol> <li>Install the package.</li> </ol> Bash<pre><code>sudo apt update &amp;&amp; sudo apt install intel-oneapi-mkl-devel -y\n</code></pre> <ol> <li>Now compile <code>suanPan</code> by enabling MKL via option <code>-DUSE_MKL=ON</code>. The corresponding <code>MKLROOT</code> shall be assigned, for    example <code>-DMKLROOT=/opt/intel/oneapi/mkl/latest/</code>, depending on the installation location. The configuration used     for snap is the following one.</li> </ol> Bash<pre><code>   -DCMAKE_INSTALL_PREFIX=\n-DCMAKE_BUILD_TYPE=Release\n   -DBUILD_MULTITHREAD=ON\n   -DUSE_HDF5=ON\n   -DUSE_EXTERNAL_VTK=ON\n   -DVTK_DIR=$CRAFT_PART_BUILD/lib/cmake/vtk-9.2/\n   -DUSE_MKL=ON\n   -DMKLROOT=/opt/intel/oneapi/mkl/latest\n   -DUSE_INTEL_OPENMP=OFF\n   -DLINK_DYNAMIC_MKL=OFF\n</code></pre>"},{"location":"Basic/Compile/#fedora","title":"Fedora","text":""},{"location":"Basic/Compile/#vtk","title":"VTK","text":"<p>Fedora offers the latest VTK library, simply install it.</p> Bash<pre><code>sudo dnf install vtk-devel\n</code></pre>"},{"location":"Basic/Compile/#mkl","title":"MKL","text":"<p>Intel also provides a repository to install MKL via <code>dnf</code>. See this page for details.</p> <p>First, create the <code>repo</code> file.</p> Bash<pre><code>tee &gt; /tmp/oneAPI.repo &lt;&lt; EOF\n[oneAPI]\nname=Intel\u00ae oneAPI repository\nbaseurl=https://yum.repos.intel.com/oneapi\nenabled=1\ngpgcheck=1\nrepo_gpgcheck=1\ngpgkey=https://yum.repos.intel.com/intel-gpg-keys/GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB\nEOF\n</code></pre> <p>Move it to the proper location.</p> Bash<pre><code>sudo mv /tmp/oneAPI.repo /etc/yum.repos.d\n</code></pre> <p>Install MKL. You may perform a search <code>sudo dnf search intel-oneapi-mkl-devel</code> to find which package name is available and install the specific version if necessary.</p> Bash<pre><code>sudo dnf install intel-oneapi-mkl-devel\n</code></pre> <p>The source can be compiled with VTK and MKL enabled.</p>"},{"location":"Basic/Compile/#macos","title":"macOS","text":"<p>The following guide is based on macOS Big Sur (11).</p> <p>Install tools. <code>gfortran</code>, <code>llvm</code> and <code>libomp</code> are used for compiling the main program, <code>glfw</code> and <code>glew</code> are required for compiling <code>VTK</code>. <code>VTK</code> does not compile with <code>GCC</code>. Here, we use <code>Clang</code>.</p> Bash<pre><code># install brew if not installed\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n# install necessary packages\nbrew install gcc@10 llvm@13 libomp glfw glew git cmake\n</code></pre> <p>Similar to Ubuntu, compile <code>VTK</code> if wanted.</p> Bash<pre><code>wget https://www.vtk.org/files/release/9.1/VTK-9.1.0.tar.gz\ntar xf VTK-9.1.0.tar.gz &amp;&amp; rm VTK-9.1.0.tar.gz\nmkdir VTK-build &amp;&amp; cd VTK-build\ncmake -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=OFF -DCMAKE_INSTALL_PREFIX=../VTK-out ../VTK-9.1.0\nmake install -j4\n</code></pre> <p><code>MKL</code> can be installed if necessary. See this page .</p> <p>Obtain the source code and configure.</p> Bash<pre><code># clone source code\ngit clone -b master https://github.com/TLCFEM/suanPan.git\n# create build directory\nmkdir suanpan-build &amp;&amp; cd suanpan-build\n# use clang, clang++ and gfortran\nexport CC=/usr/local/opt/llvm/bin/clang &amp;&amp; export CXX=/usr/local/opt/llvm/bin/clang++ &amp;&amp; export FC=gfortran-10\n# configure project\ncmake -DCMAKE_BUILD_TYPE=Release -DBUILD_MULTITHREAD=ON -DUSE_HDF5=ON -DUSE_EXTERNAL_VTK=ON -DVTK_DIR=../VTK-out/lib/cmake/vtk-9.1/ .\n# compile\nmake -j4\n</code></pre>"},{"location":"Basic/Compile/#build-options","title":"Build Options","text":"<p>If CMake GUI is used to configure the project, the following options are available.</p> <ol> <li><code>BUILD_DLL_EXAMPLE</code>: If enabled, example element/material/section implemented as external libraries will be built.</li> <li><code>BUILD_MULTITHREAD</code>: If enabled, <code>TBB</code> will be used for multithreading so that element update, global matrix    assembly, etc., can be parallelized. <code>OpenMP</code> is not controlled by this option given that <code>OpenMP</code> support is    available in major platforms. It will be used for low level parallelization such as linear algebra operations (which    is controlled by <code>Armadillo</code>), matrix solving (which is controlled by various solvers).</li> <li><code>BUILD_SHARED</code>: If enabled, all libraries will be built as shared libraries.</li> <li><code>USE_SUPERLUMT</code>: If enabled, <code>SuperLU-MT</code> will be used, otherwise <code>SuperLU</code> will be used.</li> <li><code>USE_HDF5</code>: If enabled, <code>HDF5</code> will be used to provide support for <code>hdf5recorder</code>.</li> <li><code>USE_EXTERNAL_VTK</code>: If enabled, <code>VTK</code> will be used to provide support for visualization. It will be useful to    generate <code>.vtk</code> files that can be used in <code>Paraview</code> for post-processing. If enabled, <code>VTK_DIR</code> needs to be set to    the path of <code>VTK</code> installation. For example, <code>VTK_DIR=/usr/local/opt/vtk/lib/cmake/vtk-9.1</code>.</li> <li><code>USE_EXTERNAL_CUDA</code>: <code>CUDA</code> needs to be installed manually by the user. If enabled, <code>CUDA</code> based solvers will be    available. However, for dense matrix storage, only full matrix storage scheme is supported by <code>CUDA</code>. Note full    matrix storage scheme is not favorable for FEM. It can, however, be used for sparse matrix solving and mixed    precision solving.</li> <li><code>USE_AVX</code>: If enabled, compiler flags <code>-mavx</code> or <code>/arch:AVX</code> will be used. (~2011)</li> <li><code>USE_AVX2</code>: If enabled, compiler flags <code>-mavx2</code> or <code>/arch:AVX2</code> will be used. (~2013)</li> <li><code>USE_AVX512</code>: If enabled, compiler flags <code>-mavx512f</code> or <code>/arch:AVX512</code> will be used. (~2016)</li> <li><code>USE_MKL</code>: <code>MKL</code> needs to be installed manually by the user. If enabled, the parallel version of <code>MKL</code> will be used     for linear algebra operations. It is possible to manually modify the configuration to use cluster version (MPI).     However, For the moment, the global matrix is still centralized in such a way that element updating will happen on a     single node. The linear algebra operations may be offloaded to other nodes. If <code>USE_MKL</code> is enabled, the following     additional options are available.</li> <li><code>LINK_DYNAMIC_MKL</code>: If enabled, dynamically linked <code>MKL</code> libraries will be used. Otherwise, statically linked <code>MKL</code>     libraries will be used, leading to larger binary size but faster execution and fewer dependencies.</li> <li><code>MKLROOT</code>: Set this path to the root directory of <code>MKL</code> installation. For     example, <code>C:/Program Files (x86)/Intel/oneAPI/mkl/latest</code> or <code>/opt/intel/oneapi/mkl/latest</code>.</li> <li><code>USE_INTEL_OPENMP</code>: If enabled, Intel OpenMP library will be used. Otherwise, Default ones (such as GNU OpenMP     library) will be used.</li> </ol>"},{"location":"Basic/Compile/#example-configuration","title":"Example Configuration","text":"<p>The following command is used to compile the program to be distributed via snap. See this file.</p> Bash<pre><code># assume current folder is suanPan/build\n# the parent folder contains source code\ncmake -DCMAKE_INSTALL_PREFIX= \\\n-DCMAKE_BUILD_TYPE=Release \\\n-DBUILD_MULTITHREAD=ON \\\n-DUSE_HDF5=ON \\\n-DUSE_EXTERNAL_VTK=ON \\\n-DVTK_DIR=$CRAFT_PART_BUILD/lib/cmake/vtk-9.2/ \\\n-DUSE_MKL=ON \\\n-DMKLROOT=/opt/intel/oneapi/mkl/latest \\\n-DUSE_INTEL_OPENMP=OFF \\\n-DLINK_DYNAMIC_MKL=OFF\n</code></pre>"},{"location":"Basic/Config/","title":"Configuration","text":""},{"location":"Basic/Config/#disable-new-version-check","title":"Disable New Version Check","text":"<p>Some distributions are bundled with an updater that checks for new versions of the application on startup and allows you to download new archives if necessary. In some fully automated environments, one can disable the check via the <code>-nu</code> option.</p> Bash<pre><code>suanpan -nu -f &lt;your_input_model.sp&gt;\n</code></pre>"},{"location":"Basic/Config/#disable-color-output","title":"Disable Color Output","text":"<p>By default, the console output is colored to make it more readable. If the console output is redirected to a file, the ANSI color codes will be included in the file. To disable the color output, use the <code>-nc</code> option.</p> Bash<pre><code>suanpan -nc -f &lt;your_input_model.sp&gt;\n</code></pre> <p>The ANSI color codes can be properly rendered using, for example, bat.</p>"},{"location":"Basic/Config/#redirect-console-output","title":"Redirect Console Output","text":"<p>By default, the console output is printed to the standard output. To redirect the output to a file, use the <code>-o</code> option.</p> Bash<pre><code>suanpan -f &lt;your_input_model.sp&gt; -o &lt;your_output_file&gt;\n</code></pre>"},{"location":"Basic/Config/#verbose-output","title":"Verbose Output","text":"<p>With the release build, only info/warning/error/fatal messages will be printed. To print debug messages, use the <code>-vb</code> option.</p> Bash<pre><code>suanpan -vb -f &lt;your_input_model.sp&gt;\n</code></pre>"},{"location":"Basic/Config/#disable-output","title":"Disable Output","text":"<p>If the model has been checked, output can be disabled to speed up the analysis. To disable the output, use the <code>-np</code> option.</p> Bash<pre><code>suanpan -np -f &lt;your_input_model.sp&gt;\n</code></pre>"},{"location":"Basic/Obtain/","title":"Obtain","text":""},{"location":"Basic/Obtain/#docker-image","title":"Docker Image","text":"<p>A docker image is available at Docker Hub. To use it,  docker needs to be installed first. See this page for details.</p> <p>Once docker is installed, it is possible to pull the image via:</p> Bash<pre><code>docker pull tlcfem/suanpan\n</code></pre> <p>Then it is possible to run the container in an interactive manner via:</p> Bash<pre><code>docker run -it --rm tlcfem/suanpan\n</code></pre> <p>Within the container, the <code>suanPan</code> executable is available. To run, type:</p> Bash<pre><code>suanPan\n</code></pre> <p>One can also attach volume to the container to access the files in the host machine. And then run the file inside  the container.</p> Bash<pre><code>docker run -it --rm -v /path/to/host/folder:/path/to/container/folder tlcfem/suanpan\ncd /path/to/container/folder\nsuanPan -f example.model.sp\n</code></pre> <p>Docker image is convenient on machines with older kernels or limited by other factors that does not allow  execution of precompiled binaries.</p>"},{"location":"Basic/Obtain/#precompiled-binaries","title":"Precompiled Binaries","text":"<p>The binaries are published on GitHub. https://github.com/TLCFEM/suanPan/releases</p> <p>Binaries on Windows, Ubuntu and macOS are compiled and deployed automatically on the <code>master</code> branch. The  precompiled binaries are compiled on the following OS versions.</p> Platform Version Windows Windows Server 2022 Ubuntu Ubuntu 22.04 Fedora Fedora 36 macOS Big Sur 11 <p>The <code>.deb</code> and <code>.rpm</code> packages are tested on the same platforms. They do not include <code>updater</code>, which checks for new  versions on startup. For older versions or other flavours of Linux, successful execution is not guaranteed. Please  consider compiling the binaries manually.</p> <p>In order to enable <code>CUDA</code> backed solvers, the program shall be compiled locally with preinstalled external libraries. See this page Compile.</p> <p>Currently, the following package managers can be used to install the program.</p> Platform Package Manager Command Windows Chocolatey <code>choco install suanpan</code> Windows scoop <code>scoop install suanpan</code> Linux snap <code>snap install suanpan</code> Linux flatpak <code>flatpak install flathub io.github.tlcfem.suanPan</code> Ubuntu <code>apt</code> (not available in official repo) <code>sudo apt install ./suanPan-x.x.x-1.x86_64.deb</code> Fedora <code>dnf</code> (not available in official repo) <code>sudo dnf install ./suanPan-x.x.x-1.x86_64.rpm</code> <p>The binaries are tested in standard environments: fresh new Win10/11 images, docker images Ubuntu and Fedora, and macOS GitHub image.</p>"},{"location":"Basic/Obtain/#chocolatey","title":"Chocolatey","text":""},{"location":"Basic/Obtain/#snap","title":"snap","text":""},{"location":"Basic/Obtain/#flatpak","title":"flatpak","text":"<p>To run the application, one shall use the following command in terminal.</p> Bash<pre><code>flatpak run io.github.tlcfem.suanPan\n</code></pre> <p>Since no shim is created, it would be convenient to create alias such that</p> Bash<pre><code>echo \"alias suanpan=\\\"flatpak run io.github.tlcfem.suanPan\\\"\" &gt;&gt; ~/.bashrc\n</code></pre> <p>Then it is possible to use <code>suanpan</code> to invoke the application.</p>"},{"location":"Basic/Obtain/#execute-program","title":"Execute Program","text":"<p>By default, the <code>AVX</code> support is turned on to utilize CPU capability. For CPUs that do not support <code>AVX</code>, the application cannot be successfully executed. Users can either compile the program by themselves or request a specific version by filing an issue. Processors that do not support <code>AVX</code> may be too slow to perform HPC based simulations.</p> <p>The name of the executable is <code>suanPan</code>, however, snap/chocolatey/scoop will create shim executable named as  <code>suanpan</code>. Depending on how the application is installed, one may use <code>suanpan</code> or <code>suanPan</code> to invoke the application.</p> <p>The parallelization is enabled mostly by the <code>TBB</code> library and <code>&lt;execution&gt;</code> header (C++17). If the program is compiled with SUANPAN_MT macro, parallelization is used by default. The OpenMP is enabled in several parts of the program, users can set environment variable OMP_NUM_THREADS to customize some OpenMP based parallelization. To do so, users can, for example, in Windows, use the following command.</p> PowerShell<pre><code>set OMP_NUM_THREADS=6\n</code></pre> <p>On Linux, the dynamic loading path need to be set so that dynamic libraries such as <code>libtbb.so</code> can be successfully found. If the application is installed via snap/apt/dnf, it is automatically done.</p> Bash<pre><code># current path contains suanPan\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$(pwd)/../lib\n./suanPan\n</code></pre> <p>Alternatively, users can execute the program via the provided <code>suanPan.sh</code> script.</p> Bash<pre><code># create links to the executables\n# the script assumes ~/.local/bin is in the path and creates a symbolic link to the executable\n./suanPan.sh --create-link\n# cd to other folders and execute the program\ncd ~\nsuanpan\n</code></pre>"},{"location":"Basic/Obtain/#cli-mode","title":"CLI Mode","text":"<p>By running the program without any parameters, it enters CLI mode by default. Users can create models in an interactive manner.</p> Text Only<pre><code>+--------------------------------------------------+\n|   __        __         suanPan is an open source |\n|  /  \\      |  \\           FEM framework (64-bit) |\n|  \\__       |__/  __   __      Betelgeuse (2.3.0) |\n|     \\ |  | |    |  \\ |  |      maintained by tlc |\n|  \\__/ |__| |    |__X |  |    all rights reserved |\n|                           10.5281/zenodo.1285221 |\n+--------------------------------------------------+\n|  https://github.com/TLCFEM/suanPan               |\n|  https://github.com/TLCFEM/suanPan-manual        |\n+--------------------------------------------------+\n|  https://gitter.im/suanPan-dev/community         |\n+--------------------------------------------------+\n\nsuanPan ~&lt;&gt;\n</code></pre> <p>A command named as <code>example</code> is available to automatically create an example model and perform the analysis.</p> Text Only<pre><code>+--------------------------------------------------+\n|   __        __         suanPan is an open source |\n|  /  \\      |  \\           FEM framework (64-bit) |\n|  \\__       |__/  __   __      Betelgeuse (2.3.0) |\n|     \\ |  | |    |  \\ |  |      maintained by tlc |\n|  \\__/ |__| |    |__X |  |    all rights reserved |\n|                           10.5281/zenodo.1285221 |\n+--------------------------------------------------+\n|  https://github.com/TLCFEM/suanPan               |\n|  https://github.com/TLCFEM/suanPan-manual        |\n+--------------------------------------------------+\n|  https://gitter.im/suanPan-dev/community         |\n+--------------------------------------------------+\n\nsuanPan ~&lt;&gt; example\n====================================================\n-&gt; A Minimum Example: Elastic Truss Under Tension &lt;-\n====================================================\n--&gt; create two nodes at (0,0) and (2,0):\n        node 1 0 0\n        node 2 2 0\n--&gt; create material model (elastic modulus 52):\n        material Elastic1D 1 52\n--&gt; create a truss element connecting nodes 1 and 2:\n        element T2D2 1 1 2 1 93\n--&gt; define boundary condition and load:\n        fix 1 1 1\n        fix 2 2 1 2\n        displacement 1 0 1.4 1 2\n--&gt; define a static step:\n        step static 1\n--&gt; perform the analysis:\n        analyze\ncurrent analysis time: 1.00000.\n--&gt; check nodal force (P=UEA/L=1.4*52*93/2=3385.2):\n        peek node 2\nNode 2:\n   2.0000        0\nDisplacement:\n   1.4000        0\nResistance:\n   3.3852e+03            0\n\n--&gt; clean up and it's your turn!\n====================================================\nsuanPan ~&lt;&gt;\n</code></pre>"},{"location":"Basic/Obtain/#batch-mode","title":"Batch Mode","text":"<p>To analyze the model written in a model file named as for example <code>example.supan</code>, the <code>-f</code> or <code>--file</code> parameter can be used. First we create the file <code>example.supan</code> with <code>exit</code> command.</p> Bash<pre><code>echo exit &gt; example.supan\n</code></pre> <p>Then we can run it by the following command.</p> Bash<pre><code>suanpan -f ./example.supan\n</code></pre> <p>Or on Windows,</p> PowerShell<pre><code>./suanPan.exe -f example.supan\n</code></pre> <p>If the model has been prechecked, it is possible to run the analysis without output. It is known that printing strings to terminals slows down the analysis. Users can use the <code>-np</code> or <code>--noprint</code> option to suppress output.</p> PowerShell<pre><code>./suanPan.exe -np -f example.supan\n</code></pre> <p>In the CLI mode, it is possible to use <code>file</code> command to load the file.</p> Text Only<pre><code>+--------------------------------------------------+\n|   __        __         suanPan is an open source |\n|  /  \\      |  \\           FEM framework (64-bit) |\n|  \\__       |__/  __   __      Betelgeuse (2.3.0) |\n|     \\ |  | |    |  \\ |  |      maintained by tlc |\n|  \\__/ |__| |    |__X |  |    all rights reserved |\n|                           10.5281/zenodo.1285221 |\n+--------------------------------------------------+\n|  https://github.com/TLCFEM/suanPan               |\n|  https://github.com/TLCFEM/suanPan-manual        |\n+--------------------------------------------------+\n|  https://gitter.im/suanPan-dev/community         |\n+--------------------------------------------------+\n\nsuanPan ~&lt;&gt; file example.supan\n</code></pre>"},{"location":"Basic/Obtain/#sublime-text-workspace","title":"Sublime Text Workspace","text":"<p>I personally use Sublime Text as my model editor. Other tools like Atom and VS Code can also be used.</p>"},{"location":"Basic/Obtain/#syntax-highlighting","title":"Syntax Highlighting","text":"<p>Create a new syntax file via <code>Tools -&gt; Developer -&gt; New Syntax...</code>, copy and paste the following sample content into the new file and save as <code>suanPan.sublime-syntax</code> under the default path. It provides syntax highlighting for comments only. Other components can be added accordingly.</p> YAML<pre><code>%YAML 1.2\n---\nfile_extensions:\n- supan\n- sp\nscope: source.supan\ncontexts:\nmain:\n- match: '^[#!].*'\nscope: comment.line\n- match: '!.*'\nscope: comment.line\n</code></pre> <p>A syntax file with (almost) all commands is provided as <code>suanPan.sublime-syntax</code> in the archive. Please feel free to use/modify it. It may be necessary to manually search for the file if the application is installed via some package manager.</p>"},{"location":"Basic/Obtain/#autocomplete","title":"Autocomplete","text":"<p>All keywords used are stored in the JSON file <code>suanPan.sublime-completions</code>. Place the file in folder <code>~/.config/sublime-text-3/Packages/User/</code> (Linux) or <code>%appdata%\\Sublime Text 3\\Packages\\User</code> (Windows) and you are good to go with the previous syntax file. The new path has been changed to <code>~/.config/sublime-text/Packages/User/</code> ( Linux) and <code>%appdata%\\Sublime Text\\Packages\\User</code> (Windows) in <code>Sublime Text 4</code>.</p>"},{"location":"Basic/Obtain/#build-system","title":"Build System","text":"<p>In order to render ANSI color codes correctly in Linux like systems, you may wish to install ANSIescape package. Now define a new build system via <code>Tools -&gt; Build System -&gt; New Build System...</code>, copy and paste the following contents in the file and save it as <code>suanPan.sublime-build</code>. You may need to replace command <code>suanpan</code> with the full path of the executable.</p> JSON<pre><code>{\n\"cmd\": [\n\"suanpan\",\n\"-f\",\n\"$file\"\n],\n\"selector\": \"source.supan\",\n\"file_patterns\": [\n\"*.supan\",\n\"*.sp\"\n],\n\"target\": \"ansi_color_build\",\n\"syntax\": \"Packages/ANSIescape/ANSI.sublime-syntax\"\n}\n</code></pre> <p>Now models can be run in Sublime Text via the shortcut <code>Ctrl+B</code>.</p> <p>To disable colored output, use <code>-nc</code> option such as</p> Bash<pre><code>suanpan -nc -f model_file.supan\n</code></pre>"},{"location":"Basic/Obtain/#automation","title":"Automation","text":""},{"location":"Basic/Obtain/#windows","title":"Windows","text":"<p>A batch file named as <code>AddAssociation.bat</code> is provided in the archive. It associates <code>*.sp</code> and <code>*.supan</code> files with the program and copies configuration files to default folder if Sublime Text is installed. If the package is installed via package managers, pleas manually search for and execute this file.</p> <p>Admin privilege is required.</p>"},{"location":"Basic/Obtain/#linux","title":"Linux","text":"<p>A bash script named as <code>suanPan.sh</code> is provided in the archive to set up the above configurations automatically. The script can be used to both execute the program and create symbolic links.</p> <p>For the first time use, the following commands create a soft link under <code>$HOME/.local/bin</code> so that users can execute the program anywhere by invoking command <code>suanpan</code> in any folder. The Sublime Text configuration files are copied to the default folder if Sublime Text is installed.</p> Bash<pre><code># current path contains suanPan\nchmod +x suanPan.sh\n./suanPan.sh --create-link\n# cd to other places such as folders that contain models\n# now invoke the program\nsuanpan\n</code></pre> <p>Check the following recording.</p> <p></p>"},{"location":"Basic/Performance/","title":"Performance Considerations","text":"<p><code>suanPan</code> prioritizes performance and designs the analysis logic in a parallel context.</p> <p>Although the majority of the common analysis types can be parallelized, there are still some certain parts that have  strong data dependencies that cannot be parallelized. According to Amdahl's law, there would be an upper bound of the  theoretical speedup.</p> <p>For example, for a static analysis of a simple model with a sufficiently large number of elements, there is no local  iteration required to update element status, the major tasks are to assemble global stiffness matrix and solve it.  In such a case, the performance is likely governed by the CPU capacity and often a large value of GFLOPS can be  achieved (close to practical limit).</p> <p>However, if one choose to perform a dynamic analysis of the same model with a fairly sophisticated time integration  algorithm, such as GSSSS, as the effective stiffness would be the summation of  the scaled versions of several global matrices, the analysis may be blocked by memory operations, which eventually  leads to a lower value of GFLOPS.</p> <p>In the nonlinear context, it is even more complicated. Several additional factors, such as the complexity of the  material models used, the use of constraints, the element type, can all affect the performance.</p> <p>Nevertheless, experience has shown that the performance is generally good enough and for most cases. Users are  encouraged to <code>perf</code> the performance of various analysis types.</p>"},{"location":"Basic/Performance/#tweaks","title":"Tweaks","text":"<p>It is possible to tweak the performance in the following ways, which may or may not improve the performance.</p>"},{"location":"Basic/Performance/#openmp-threads","title":"OpenMP Threads","text":"<p>OpenMP is used by MKL and OpenBLAS to parallelize the matrix operations, alongside with SIMD instructions. It is  possible to manually set OMP_NUM_THREADS to control the number of  threads used. Pay attention to over-subscription.</p> <p>OMP_DYNAMIC may affect cache locality and thus the performance. For  computation intensive tasks, it is recommended to set it to false.</p>"},{"location":"Basic/Performance/#affinity","title":"Affinity","text":"<p>CPU affinity can also affect the performance. Tweaking affinity, for example, with KMP_AFFINITY, can improve  performance.</p>"},{"location":"Basic/Performance/#memory-allocation","title":"Memory Allocation","text":"<p>Memory fragmentation may downgrade analysis performance, especially for finite element analysis, in which there are  a large number of small matrices and vectors. It is recommended to use a performant memory allocator, for example, a  general purpose allocator like mimalloc.</p> <p>On Linux, it is fairly easy to replace the default memory allocator. For example,</p> Bash<pre><code>LD_PRELOAD=/path/to/libmimalloc.so  suanpan -f input.sp\n</code></pre>"},{"location":"Basic/Structure/","title":"Structure","text":"<p>The default parser accepts a three-part structure. They are:</p> <ol> <li>Model Properties Setup</li> <li>Analysis Properties Setup</li> <li>Post-processing</li> </ol> <p>The previous cantilever beam example is used here to explain the structure. The model is shown as follows.</p> Text Only<pre><code>node 1 0 0\nnode 2 1.34 0\nmaterial Elastic1D 1 132\nelement EB21 1 1 2 7.213 6.825 1\nstep static 1\nfix 1 P 1\ncload 1 0 23 2 2\ncload 2 0 17 1 2\nanalyze\npeek node 2\nexit\n</code></pre>"},{"location":"Basic/Structure/#model-properties-setup","title":"Model Properties Setup","text":"<p>Anything before the first <code>step</code> command is treated as the setup of model properties. This part may include the definitions of nodes, elements, material models, loads, recorders, boundary conditions, etc. In this part, the order of commands does not affect the establishment of the model. So that the following reshuffled command flow creates the same model as the original one does, although, the <code>EB21</code> element is created before the creation of its connected nodes.</p> Text Only<pre><code>element EB21 1 1 2 7.213 6.825 1\nnode 2 1.34 0\nmaterial Elastic1D 1 132\nnode 1 0 0\n</code></pre> <p>When the program parses those commands, the corresponding objects are only created and stored, but not initialized ( viz., no other information is required during the creation of a particular object). So the order does not affect anything in this part.</p>"},{"location":"Basic/Structure/#analysis-properties-setup","title":"Analysis Properties Setup","text":"<p>The command block between the first <code>step</code> command the <code>analyze</code> command (or the <code>precheck</code> command) is the setup of analysis properties. A similar analysis flow which resembles the one of ABAQUS is used, that is, multiple steps can be defined in sequence in this part.</p> <p>In this example, within step 1, a fixed boundary condition is applied to node 1, two concentrated loads are applied to node 2 along two directions. For the purpose of illustration, those two loads can be defined in two different steps as follows.</p> Text Only<pre><code>fix 1 P 1\nstep static 1\ncload 1 0 23 2 2\nstep static 2\ncload 2 0 17 1 2\nanalyze\n</code></pre> <p>Now the horizontal load is created in step 2 that follows step 1. It shall be noted the BC is created before the first step. By default, there is a step 0 with no step time, so the BC can be defined in either step 0 or step 1. Similar to ABAQUS, the sequence of multiple steps will affect analysis results.</p>"},{"location":"Basic/Structure/#post-processing","title":"Post-processing","text":"<p>The code block between the <code>analyze</code> command and the <code>exit</code> command belongs to post-processing. This part is less concerning and most commands have instant response.</p>"},{"location":"Basic/Syntax/","title":"Syntax","text":""},{"location":"Basic/Syntax/#command","title":"Command","text":"<p>All commands are case insensitive. Each command by default shall be written in one line.</p> <p>It is not allowed to write two commands in one line.</p> <p>To split one command into several lines, use the backslash (<code>\\</code>) to concatenate. Only one backslash can serve as concatenation symbol in one line. Other backslashes (if any) will be kept and combined with other lines and may lead to wrongly interpreted command.</p> <p>The leading and trailing whitespaces would be omitted by default.</p>"},{"location":"Basic/Syntax/#separatordelimiter","title":"Separator/Delimiter","text":"<p>Either whitespace (<code>_</code>), including tab (<code>\\t</code>), or comma (<code>,</code>) can be used as separator/delimiter.</p>"},{"location":"Basic/Syntax/#comment","title":"Comment","text":"<p>Comment lines start with the hash symbol (<code>#</code>) or the exclamation symbol (<code>!</code>).</p> <p>Inline comments shall be denoted with the exclamation symbol (<code>!</code>) only. All contents after the first <code>!</code> will be treated as comments.</p> <p>Comments can be mixed with concatenation. There can only be white spaces between <code>\\</code> and <code>!</code>.</p> Text Only<pre><code># this is a comment\n! this is another comment\nnode 1 2 3 4 5 6 ! this is an inline comment\n# split one command into multiple lines\nnode 2 9 7 5 1 3 \\\n3 4 5 \\ ! comments can be put after backslash \\\n9 8 2\n</code></pre>"},{"location":"Basic/Syntax/#input","title":"Input","text":"<p>Inputs are mostly integers, doubles and strings. The model input file is a plain text file, scripting of any sorts is not supported. Math expressions are not available.</p> <p>When the required input argument is an integer, it is not allowed to have a double in place. The decimal point cannot be read by the integer parser so may cause failure of command parsing.</p> <p>However, a double input can be replaced by an integer (if desired value matches), type conversion is automatically done.</p> <p>Some commands take Boolean values in form of string. For <code>true</code> value, following inputs are equivalent: <code>true</code>, <code>yes</code> , <code>1</code>, <code>on</code>, <code>t</code>, <code>y</code>. For <code>false</code> value, following inputs are equivalent: <code>false</code>, <code>no</code>, <code>0</code>, <code>off</code>, <code>f</code>, <code>n</code>. Again, commands, including inputs, are case-insensitive.</p> <p>For all commands, compulsory arguments are denoted by rounded brackets <code>(n)</code>, optional arguments are denoted by square brackets <code>[n]</code>. Input arguments shall be defined in sequence. To change the default value of any optional arguments, all leading optional arguments (if any) shall be explicitly defined. For group arguments, <code>(n n+1...)</code> means arguments <code>n</code> and <code>n+1</code> appear as a group and must be defined due to rounded brackets, while <code>( ...)</code> means this group can be repeated to define a set of arguments. For square case, <code>[ ...]</code> means this group is optional.</p>"},{"location":"Collection/Configure/analyze/","title":"analyze","text":"<p>The <code>analyze</code> or <code>analyse</code> command will trigger the analysis. The model will be initialized by initializing for example elements and global storage of matrices.</p> <p>All steps will be analysed. It is possible to define subsequent steps after performing the analysis.</p>"},{"location":"Collection/Configure/analyze/#syntax","title":"Syntax","text":"Text Only<pre><code>analyze\nanalyse\n</code></pre>"},{"location":"Collection/Configure/converger/","title":"converger","text":"<p>Converger is not a proper English word. It is used to check if the system converges according to a given specific rule. Please refer to the specific type of convergers for syntax and details.</p>"},{"location":"Collection/Configure/criterion/","title":"criterion","text":"<p>The <code>criterion</code> command is used to construct criteria that may be used to modify the model according to specific rules. Please refer to the specific type of criteria for syntax and details.</p>"},{"location":"Collection/Configure/integrator/","title":"integrator","text":"<p>The <code>integrator</code> command is used to construct time integration algorithms. Please refer to the specific type of integrators for syntax and details.</p>"},{"location":"Collection/Configure/precheck/","title":"precheck","text":"<p>The <code>precheck</code> command initialize all the models created to check potential errors. However, this command will not run analysis. To perform the analysis, please use the <code>analyze</code> command.</p>"},{"location":"Collection/Configure/precheck/#syntax","title":"Syntax","text":"Text Only<pre><code>precheck\n</code></pre>"},{"location":"Collection/Configure/step/","title":"step","text":"<p>Please refer to the specific type of steps for details.</p> <p>For any steps available, a default asymmetric banded dense storage is used. This storage scheme fits most problems. The LAPACK driver used is <code>_gbsv()</code>. The main reason behind such a choice stems from two aspects.</p> <ol> <li>For 2D and 3D problems, most material models have asymmetric stiffness moduli. The global stiffness matrix is then    asymmetric.</li> <li>If the problem shows softening behaviour, the stiffness matrix is not always positive definite, the symmetric solver    fails to solve such a matrix.</li> </ol>"},{"location":"Collection/Define/amplitude/","title":"amplitude","text":"<p>Please refer to specific types for details.</p>"},{"location":"Collection/Define/bc/","title":"bc","text":"<p>Although called boundary condition, here we only deal with trivial Dirichlet boundary condition.</p>"},{"location":"Collection/Define/bc/#syntax","title":"Syntax","text":"<p>There are currently several commands to define boundary conditions.</p> Text Only<pre><code>fix (1) (2) (3...)\nfix2 (1) (2) (3...)\nmultiplierbc (1) (2) (3...)\npenaltybc (1) (2) (3...)\n# (1) int, unique tag\n# (2) string, dof identifier\n# (3...) int, tags of nodes that shall be constrained\n</code></pre> <p>To apply BCs to node groups, it is possible to use the following commands.</p> Text Only<pre><code>groupmultiplierbc (1) (2) (3...)\ngrouppenaltybc (1) (2) (3...)\n# (1) int, unique tag\n# (2) string, dof identifier\n# (3...) int, tags of groups that shall be constrained\n</code></pre>"},{"location":"Collection/Define/bc/#remark","title":"Remark","text":"<ol> <li>Both <code>fix</code> and <code>fix2</code> serve the same purpose but with different approaches. The <code>fix</code> command modifies the    corresponding main diagonal term by multiplying a large number, for example \\(\\(10^8\\)\\). The <code>fix2</code> command erase the    column and row of target DoF and set the main diagonal to unity. In both case, the corresponding right hand side    entry is erased.</li> <li>The <code>fix</code> and <code>penaltybc</code> commands is computationally efficient but leads to an ill-conditioned matrix. This may not    be a problem for direct solvers but will greatly affect the performance of iterative solvers. The penalty number can    be controlled by <code>set</code> command via <code>constraint_multiplier</code> option.</li> <li>The <code>fix2</code> and <code>multiplierbc</code> commands requires more operations but the final matrix is well conditioned.</li> <li>The performance difference is almost negligible. Either one can be used with direct solvers. The error won't    accumulate as there is a special mechanism to prevent it.</li> <li>The DoF identifier <code>(2)</code> takes the following string input: <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>pinned</code>, <code>encastre</code>    , <code>xsymm</code>, <code>ysymm</code>, <code>zsymm</code> and the corresponding initials <code>p</code>, <code>e</code>, <code>x</code>, <code>y</code>, <code>z</code>. The names do not actually reflect    their meaning, instead, following DoFs would be restrained when string input is given.</li> <li><code>pinned</code>: 1 2 3</li> <li><code>encastre</code>: 1 2 3 4 5 6</li> <li><code>xsymm</code>: 1 5 6</li> <li><code>ysymm</code>: 2 4 6</li> <li><code>zsymm</code>: 3 4 5</li> <li>The nontrivial Dirichlet boundary condition is treated as displacement load.</li> </ol>"},{"location":"Collection/Define/constraint/","title":"constraint","text":"<p>Please refer to specific constraint types provided for details.</p> <p>All constraints are processed in parallel.</p> <p>Most constraints are implemented in both the penalty function and Lagrange multiplier methods. A brief discussion on  the difference can be found in the Constraint page.</p>"},{"location":"Collection/Define/domain/","title":"domain","text":"<p>The <code>domain</code> command can be used to create new problem domains or switch from one to another.</p>"},{"location":"Collection/Define/domain/#syntax","title":"Syntax","text":"Text Only<pre><code>domain (1)\n# (1) int, domain tag\n</code></pre>"},{"location":"Collection/Define/domain/#example","title":"Example","text":"<p>The program adopts a domain concept so that it could hold multiple domains (problems) at the same time. The program starts with a default domain labelled with tag 1. Following output can be seen if a debug version is executed. Irrelevant information has been removed for simplicity.</p> Text Only<pre><code>+--------------------------------------------------+\n|   __        __        suanPan is an open source  |\n|  /  \\      |  \\          FEM framework (64-bit)  |\n|  \\__       |__/  __   __          Acrux (0.1.0)  |\n|     \\ |  | |    /  | |  |                        |\n|  \\__/ |__| |    |__X |  |     maintained by tlc  |\n|                             all rights reserved  |\n+--------------------------------------------------+\n\ndebug: Storage of Domain ctor() called.\ndebug: Domain 1 ctor() called.\nsuanPan ~&lt;&gt;\n</code></pre> <p>By using the <code>domain</code> command, readers can create/switch to other domains, if necessary.</p> Text Only<pre><code>suanPan ~&lt;&gt; domain 2\ndebug: Domain 2 ctor() called.\ncreate_new_domain() successfully creates Domain 2.\nsuanPan ~&lt;&gt;\n</code></pre> <p>Of course, domains can be deleted by using <code>erase</code>, <code>remove</code> or <code>delete</code>.</p> Text Only<pre><code>suanPan ~&lt;&gt; domain 2\ndebug: Domain 2 ctor() called.\ncreate_new_domain() successfully creates Domain 2.\nsuanPan ~&lt;&gt; domain 3\ndebug: Domain 3 ctor() called.\ncreate_new_domain() successfully creates Domain 3.\nsuanPan ~&lt;&gt; domain 4\ndebug: Domain 4 ctor() called.\ncreate_new_domain() successfully creates Domain 4.\nsuanPan ~&lt;&gt; domain 5\ndebug: Domain 5 ctor() called.\ncreate_new_domain() successfully creates Domain 5.\nsuanPan ~&lt;&gt; remove domain 2\ndebug: Domain 2 dtor() called.\nsuanPan ~&lt;&gt; erase domain 5\ndebug: Domain 5 dtor() called.\nerase_domain() switches to Domain 1.\nsuanPan ~&lt;&gt; domain 4\ncreate_new_domain() switches to Domain 4.\nsuanPan ~&lt;&gt; delete domain 3\ndebug: Domain 3 dtor() called.\nsuanPan ~&lt;&gt; remove domain 4\nerase_domain() switches to Domain 1.\nsuanPan ~&lt;&gt;\n</code></pre> <p>Five domains are created. When <code>remove domain 2</code> is invoked, the current domain is <code>5</code>, so <code>2</code> is safely removed. When <code>erase domain 5</code> is invoked, the current domain 5 is then deleted, by default, the program switches to the first domain in the storage, it could be other domains, not necessary <code>1</code>. When <code>domain 4</code> is invoked, <code>4</code> already exists in the storage so instead of creating a new one, the program switch to the existing one.</p> <p>Within each domain, independent model can be defined, when <code>analyze</code> command is called, all domains will be analyzed.</p>"},{"location":"Collection/Define/element/","title":"element","text":"<p>The <code>element</code> command is used to construct finite elements. Please refer to the specific type of elements for syntax and details.</p>"},{"location":"Collection/Define/element/#general-syntax","title":"General Syntax","text":"<p>In general, the syntax uses the following pattern:</p> Text Only<pre><code>element &lt;name&gt; &lt;tag&gt; &lt;connected_nodes&gt; &lt;associated_material&gt; &lt;other_specific_parameters&gt;\n</code></pre>"},{"location":"Collection/Define/element/#output-types","title":"Output Types","text":"<p>All elements support record elemental stiffness and mass by tokens <code>K</code> and <code>M</code>. One can use the following to record  them. The detailed syntax can be seen in Record page.</p> Text Only<pre><code>hdf5recorder (1) Element K (2...)\nhdf5recorder (1) Element M (2...)\n# (1) int, unique recorder tag\n# (2...) int, element tags that K or M needs to be recorded\n</code></pre> <p>The matrices are vectorised.</p> <p>Most elements do not support additional quantities to be recorded. There are some exceptions, however. The additional ones will be documented in the specific element documentation.</p> <p>The recording command will be directly forwarded to the attached material models. Take the <code>CP4</code> element for instance, it uses a second order Gaussian quadrature, that is four integration points per element, each one is assigned with a copy of material model. If one records the stress using a command similar to <code>plainrecorder 1 Element S 1</code>, the request will be forwarded to the material models of all four integration points. Each point returns a vector of size 3, \\(\\(\\begin{bmatrix}\\sigma_{11}&amp;\\sigma_{22}&amp;\\sigma_{12}\\end{bmatrix}\\)\\), four of those vectors will be concatenated so  that the final record in the file will be a row of size 12.</p> time IP1 IP1 IP1 IP2 IP2 IP2 IP3 IP3 IP3 IP4 IP4 IP4 time \\(\\(\\sigma_{11}\\)\\) \\(\\(\\sigma_{22}\\)\\) \\(\\(\\sigma_{12}\\)\\) \\(\\(\\sigma_{11}\\)\\) \\(\\(\\sigma_{22}\\)\\) \\(\\(\\sigma_{12}\\)\\) \\(\\(\\sigma_{11}\\)\\) \\(\\(\\sigma_{22}\\)\\) \\(\\(\\sigma_{12}\\)\\) \\(\\(\\sigma_{11}\\)\\) \\(\\(\\sigma_{22}\\)\\) \\(\\(\\sigma_{12}\\)\\) <p>The detailed quadrature schemes for elements are not well documented for the moment. The most used ones are Gauss  and Lobatto with various orders.</p>"},{"location":"Collection/Define/element/#implementation-details","title":"Implementation Details","text":""},{"location":"Collection/Define/element/#creation","title":"Creation","text":"<p>The creation of any elements does not validate anything beyond the scope of the element. For example, if the correct syntax appears to be the following.</p> Text Only<pre><code>element MyEle (1) (2) (3) (4)\n# (1) int, unique tag\n# (2) int, tag of the first node\n# (3) int, tag of the second node\n# (4) int, tag of the material\n</code></pre> <p>Then <code>element MyEle 7 8 9 10</code> will create an element with tag 7, nodes 8, 9 and material 10, while <code>element MyEle 7 8 9</code> or <code>element MyEle 7 8 9 unexpected_str</code> will fail the creation. Whether nodes 8, 9 and material 10 exist or not is not validated. Instead, these type of validations are performed during the initialisation stage, before the analysis stage. This means, the order of defining basic components is not important. It is valid to define an element before defining its connected nodes.</p>"},{"location":"Collection/Define/element/#initialisation","title":"Initialisation","text":"<p>Before performing the analysis, all defined elements will be initialised. During this stage, each element will check the connected nodes and make sure they are active, and are able to accommodate the DoFs needed by the element. Local copies of the attached material models will be retrieved from the global storage. If any mismatch is found, for example, a uniaxial material model is assigned to a 3D element, the element will be disabled.</p>"},{"location":"Collection/Define/element/#analysis","title":"Analysis","text":"<p>During the analysis stage, the global solving algorithm solves the global system and updates nodal displacement accordingly. The new nodal displacement will be dispatched to all active elements for further analysis.</p> <p>From the element's perspective, it is in charge of returning elemental nodal force vector based on given nodal displacement vector.</p>"},{"location":"Collection/Define/element/#interaction","title":"Interaction","text":"<p>The problem domain holds all necessary information for elements to update themselves. Elements do not directly  interacts with global data storage. Rather, them only communicates with the associated nodes and sections/materials.</p> <p>A complete interaction graph can be seen as follows. For elements themselves, apart from the connected nodes, they  do not share information with any other objects by any means. Some elements may do not even need sections and/or  materials.</p> <pre><code>graph LR\n  A[Domain] --&gt;|update_trial_status| B[Element];\n  A --&gt;|updaye_trial_status| J[Node];\n  J --&gt;|get_trial_displacement| B;\n  B --&gt;|update_trial_status| D[Section];\n  D --&gt;|update_trial_status| F[Material];\n  F --&gt;|get_trial_stress| D;\n  F --&gt;|get_trial_stiffness| D;\n  D --&gt;|get_trial_resistance| B;\n  D --&gt;|get_trial_stiffness| B;\n  B --&gt;|get_trial_resistance| A;\n  B --&gt;|get_trial_stiffness| A;</code></pre>"},{"location":"Collection/Define/expression/","title":"expression","text":"<p>The <code>expression</code> command can be used to define mathematical expressions that can be later used to customise relevant material models.</p> <p>The <code>expression</code> command essentially parses a block of plain text into mathematical expressions. The parsing and evaluation functionalities are powered by <code>exprtk</code>.</p> <p>The <code>exprtk</code> generates an AST from the input text. The evaluation of the expression has an on par performance with the native C++ code.</p> <p>But a customisable expression allows for more flexibility and it is easier to experiment different functions.</p>"},{"location":"Collection/Define/expression/#syntax","title":"Syntax","text":""},{"location":"Collection/Define/expression/#simple-scalar-valued-expression","title":"Simple Scalar-valued Expression","text":"Text Only<pre><code>expression SimpleScalar (1) (2) (3)\n# (1) int, unique expression tag\n# (2) string, input variable list\n# (3) string, expression string or name of file containing expression\n</code></pre> <p>This evaluates a scalar-valued function \\(\\(f(x_1,x_2,\\cdots,x_n)\\)\\). The input arguments can be either scalars or vectors. For example, <code>\"x_1|2|x_2\"</code> represents two variables: 1) \\(\\(x_1\\)\\) is a vector of size 2 and 2) \\(\\(x_2\\)\\) is a scalar. The function value is returned as a result. The expression should be in the form of, for example, \\(\\(x_1^2+x_2^2\\)\\).</p> <p>This form supports automatic computation of derivatives. Thus, it can be used in models that require automatic computation of derivatives.</p>"},{"location":"Collection/Define/expression/#simple-vector-valued-expression","title":"Simple Vector-valued Expression","text":"Text Only<pre><code>expression SimpleVector (1) (2) (3) (4)\n# (1) int, unique expression tag\n# (2) string, input variable list\n# (3) string, output variable list\n# (4) string, expression string or name of file containing expression\n</code></pre> <p>This evaluates a vector-valued function \\(\\(y:=f(x_1,x_2,\\cdots,x_n)\\)\\). An assignment must be used to explicitly assign values to the output variables. The input arguments can be either scalars or vectors. The output argument should be a vector, the size shall be given such that \\(\\(y|3\\)\\) represents a vector of size 3.</p> <p>This form does support automatic computation of derivatives. Thus, it cannot be used in models that require automatic computation of derivatives.</p>"},{"location":"Collection/Define/expression/#remarks","title":"Remarks","text":"<ol> <li>The variables in the expression need to be explicitly given as the arguments.    It can be either unquoted or quoted by <code>\"</code>.</li> <li>Multiple variables must be separated by vertical bar <code>|</code>.</li> <li>The expression can be given as a string or as a file name. The program tries to load the file first. If the file    does not exist, the program tries to parse the string as an expression.</li> <li>No whitespace (',', ' ', etc.) is allowed in any arguments.</li> </ol> <p><code>exprtk</code> provides very powerful functionalities. It is possible to apply logics and control flows in the expression.</p>"},{"location":"Collection/Define/expression/#example","title":"Example","text":"<p>Say, for example, one is going to define a uniaxial nonlinear elastic model that uses the following stress-strain relationship:</p> \\[ \\sigma=\\varepsilon^3+\\varepsilon \\] <p>Then the expression can be defined as</p> Text Only<pre><code>expression SimpleScalar 1 x x^3+x\n</code></pre> <p>Here, we use <code>x</code> as the free variable and the corresponding expression is <code>x^3+x</code>.</p> <p>For the unixial nonlienar elastic model, the input is strain, which maps to <code>x</code>, the output maps to stress.</p> <p>Alternatively, the expression can be stored in a file and loaded by the program.</p> Text Only<pre><code># file cubic.txt\nx^3+x\n</code></pre> <p>Then the expression can be defined as</p> Text Only<pre><code>expression SimpleScalar 1 x cubic.txt\n</code></pre> <p>For complex expressions, it is convenient to use the file format.</p> <p>To use the expression, here, <code>CustomElastic1D</code> is used.</p> Text Only<pre><code># using expression 1\nmaterial CustomElastic1D 1 1\n\nmaterialTest1D 1 1E-2 200\n\nexit\n</code></pre> <p>The response can be tested by material tester.</p>"},{"location":"Collection/Define/expression/#result","title":"Result","text":""},{"location":"Collection/Define/file/","title":"file","text":"<p>The <code>file</code> command is used to load external <code>suanPan</code> model files with or without extension <code>.supan</code> under the current working path.</p>"},{"location":"Collection/Define/file/#syntax","title":"Syntax","text":"Text Only<pre><code>file (1)\n# (1) string, external file name\n</code></pre> <p>Please note users can use <code>pwd</code> to change current working path.</p>"},{"location":"Collection/Define/file/#usage","title":"Usage","text":"<p>The main file:</p> Text Only<pre><code># main file calling external file\nfile pre\nstep static 1\ncload 1 0 23 2 2 ! this is an example\nstep static 2\ncload 2 0 17 1 2\nanalyze\npeek node 2\nexit\n</code></pre> <p>The <code>pre.supan</code> file:</p> Text Only<pre><code># pre.supan\nnode 1 0 0\nnode 2 1.34 0\nmaterial Elastic1D 1 132\nelement EB21 1 1 2 7.213 6.825 1\nfix 1 P 1\n</code></pre>"},{"location":"Collection/Define/generate/","title":"generate","text":"<p>The <code>generate</code> command is used to generate node/element groups according to predefined rules.</p>"},{"location":"Collection/Define/generate/#form-one-generate-based-on-fixed-interval","title":"form one: generate based on fixed interval","text":"Text Only<pre><code># to hold one node/element only\ngenerate nodegroup (1) (2)\ngenerate elementgroup (1) (2)\n# (1) int, unique group tag\n# (2) int, object tag\n\n# generate from tag (2) to tag (3) with unit increment\ngenerate nodegroup (1) (2) (3)\ngenerate elementgroup (1) (2) (3)\n# (1) int, unique group tag\n# (2) int, starting object tag\n# (3) int, ending object tag\n\n# generate according to given increment\ngenerate nodegroup (1) (2) (3) (4)\ngenerate elementgroup (1) (2) (3) (4)\n# (1) int, unique group tag\n# (2) int, starting object tag\n# (3) int, interval\n# (4) int, ending object tag\n</code></pre> <p>It shall be noted that the starting tag does not have to be smaller than the ending tag.</p>"},{"location":"Collection/Define/generate/#form-two-generate-node-group-based-on-polynomial","title":"form two: generate node group based on polynomial","text":"Text Only<pre><code>generatebyrule nodegroup (1) (2) [(3)...]\n# (1) int, unique group tag\n# (2) int, DoF tag that polynomial shall be applied on\n# [(3)...] double, parameters a_n, a_{n-1}, a_{n-2},..., a_0\n</code></pre> <p>The polynomial constraint is defined to be</p> \\[ \\sum{}a_nx^n=0, \\] <p>where \\(\\(x\\)\\) is the coordinate of the target DoF of the target node.</p> <p>For example, if one wants to select all nodes on the line \\(\\(y=200\\)\\), then the following command can be defined.</p> Text Only<pre><code>generatebyrule nodegroup 1 2 1. -200.\n</code></pre>"},{"location":"Collection/Define/generate/#form-three-generate-node-group-based-on-the-line-segment","title":"form three: generate node group based on the line segment","text":"<p>It is sometimes useful to select all nodes lie in a straight line segment. The following command can be used.</p> Text Only<pre><code>generatebypoint nodegroup (1) [(2)...]\n# (1) int, unique group tag\n# [(2)...] double, coordinates of two end points\n</code></pre> <p>There is no restriction on the size of each point defined, but the sizes of two points must match. If one wants to select all points lie on the line segment between points \\(\\((3,~4)\\)\\) and \\(\\((8,~7)\\)\\), then</p> Text Only<pre><code>generatebypoint nodegroup 1 3. 4. 8. 7.\n</code></pre>"},{"location":"Collection/Define/generate/#form-four-generate-node-group-based-on-plane","title":"form four: generate node group based on plane","text":"Text Only<pre><code>generatebyplane nodegroup (1) [(2)...]\n# (1) int, unique group tag\n# [(2)...] double, parameters that define a plane\n</code></pre> <p>A plane is defined by</p> \\[ \\sum{}a_ix_i+b=0, \\] <p>where \\(\\(x_i\\)\\) are coordinates and \\(\\(a_i\\)\\) are the corresponding constants, \\(\\(b\\)\\) is constant.</p> <p>For example, a plane can be defined as</p> \\[ 3x+2y-z+7=0. \\] <p>Then</p> Text Only<pre><code>generatebyplane nodegroup 1 3. 2. -1. 7.\n</code></pre> <p>finds all nodes that fall in this plane and groups them.</p> <p>There is no restriction on the number of coordinates used. So it is possible to define a hyper-plane, or a line. However, the last parameter will always be the constant. For example, the following command defines the line \\(\\(x+2y-3=0\\)\\) in the 2D plane.</p> Text Only<pre><code>generatebyplane nodegroup 1 1. 2. -3.\n</code></pre> <p>If this is used to find nodes to define a group in a 3D problem, then the \\(\\(z\\)\\) coordinates of all nodes will be automatically skipped so that nodes such as \\(\\((2,1,0)\\)\\) and \\(\\((2,1,10)\\)\\) will be added to the group.</p>"},{"location":"Collection/Define/group/","title":"group","text":"<p>The <code>group</code> command is used to construct a set of nodes so that the corresponding constraints and loads can be applied onto. It is similar to the concept of \"set\" in ABAQUS.</p> <p>Please refer to <code>generate</code> for available commands.</p>"},{"location":"Collection/Define/import/","title":"import","text":"<p>The <code>import</code> command is used to load external libraries. Drop the library file <code>.dll</code> (or <code>.so</code> or <code>.dylib</code>) to the same folder contains the executable, one can use following command to import it.</p> Text Only<pre><code>import (1)\n# (1) string, external library name\n</code></pre> <p>There is no need to include file extension.</p> <p>If the external library has only one function exported and the name of which coincides with the external library name, there is no need to explicitly import the library. It will be done automatically.</p> <p>Say for example, the external library <code>ElementExample.dll</code> contains the corresponding function to create an external <code>ElementExample</code> object. According to the default naming convention, the function will be named as <code>void new_elementexample()</code>. To define a <code>ElementExample</code> element, one can simply use</p> Text Only<pre><code>element ElementExample !... element definition goes here\n</code></pre> <p>The program will look up build-in element library to see if <code>ElementExample</code> exists. If not, it tries to find a function with signature <code>void new_elementexample()</code> in the currently loaded external libraries. If still not found, the program tries to load <code>ElementExample.dll</code>.</p> <p>If the external library contains more than one function, to use other functions, users need to explicitly import the library.</p> <p>For CPP implementation, a smart pointer, for example <code>unique_ptr&lt;Element&gt;</code>, is passed from DLL to main executable. It is crucial to ensure both <code>.dll</code> and <code>.exe</code> are compiled with the same configuration. Otherwise, unexpected errors may occur. If possible, always try a C type interface implementation.</p>"},{"location":"Collection/Define/initial/","title":"initial","text":"<p>The <code>initial</code> command can be used to define initial conditions for nodes, material models, etc.</p>"},{"location":"Collection/Define/initial/#syntax","title":"Syntax","text":"<p>For nodal properties:</p> Text Only<pre><code>initial displacement (1) (2) [3...]\ninitial velocity (1) (2) [3...]\ninitial acceleration (1) (2) [3...]\n# (1) double, magnitude\n# (2) int, dof\n# [3...] int, node tags\n</code></pre> <p>For material properties:</p> Text Only<pre><code>initial history (1) [2...]\n# (1) int, material model tag\n# [2...] double, initial history vector\n</code></pre>"},{"location":"Collection/Define/initial/#remarks","title":"Remarks","text":"<p>Proper initial nodal conditions are important for dynamic analysis. Some time integration algorithms are sensitive to initial conditions. For example, if a standard sinusoidal wave is used as excitation, its initial displacement and acceleration are zeros so nothing needs to be changed. However, its initial velocity shall be unity, if it is not set to unity, the results may oscillate.</p> <p>Some material models supports user-defined initial history variables. It could be useful when it comes to model for example rolled/annealed metal. Different material models may have different layout of storage of history variables. Please refer to the specific model for details.</p>"},{"location":"Collection/Define/load/","title":"load","text":"<p>The <code>load</code> command is used to create loads applied on nodes.</p> <p>Currently, concentrated node based loads can be applied in terms of force, displacement and acceleration. Given that  all external forces are eventually converted to concentrated nodal forces, commands for distributed load patterns  may not be available in the foreseeable future.</p> <p>All loads are initialised and processed in parallel via global mutexes.</p>"},{"location":"Collection/Define/load/#syntax","title":"Syntax","text":"<p>All loads share a similar syntax:</p> Text Only<pre><code>load &lt;load_type&gt; &lt;unique_tag&gt; &lt;arguments that define the specific load...&gt;\n</code></pre>"},{"location":"Collection/Define/load/#nodal-load","title":"Nodal Load","text":"<p>To apply loads on nodes,</p> Text Only<pre><code># to apply nodal concentrated force\ncload (1) (2) (3) (4) (5...)\nload cload (1) (2) (3) (4) (5...)\n# to apply nodal displacement\ndisplacement (1) (2) (3) (4) (5...)\nload displacement (1) (2) (3) (4) (5...)\n# (1) int, unique tag\n# (2) int, amplitude tag, 0 to use a default `Ramp` amplitude\n# (3) double, nominal magnitude\n# (4) int, dof tag\n# (5...) int, node tags\n\n# to apply nodal acceleration\nacceleration (1) (2) (3) (4) [5...]\nload acceleration (1) (2) (3) (4) [5...]\n# (1) int, unique tag\n# (2) int, amplitude tag, 0 to use a default `Ramp` amplitude\n# (3) double, nominal magnitude\n# (4) int, dof tag\n# [5...] int, node tags\n</code></pre> <p>The keyword <code>cload</code> is the abbreviation for concentrated load.</p>"},{"location":"Collection/Define/load/#body-force","title":"Body Force","text":"<p>Some elements support body force. Indications are given for elements that support body force in the corresponding pages.</p> Text Only<pre><code>bodyforce (1) (2) (3) (4) (5...)\nload bodyforce (1) (2) (3) (4) (5...)\n# (1) int, unique tag\n# (2) int, amplitude tag, 0 to use a default `Ramp` amplitude\n# (3) double, nominal magnitude\n# (4) int, dof tag\n# (5...) int, element tags\n</code></pre>"},{"location":"Collection/Define/load/#load-applied-to-nodeelement-groups","title":"Load Applied To Node/Element Groups","text":"<p>To apply loads on groups,</p> Text Only<pre><code># on node groups\ngroupcload (1) (2) (3) (4) (5...)\ngroupdisplacement (1) (2) (3) (4) (5...)\nload groupcload (1) (2) (3) (4) (5...)\nload groupdisplacement (1) (2) (3) (4) (5...)\n\n# on element groups\ngroupbodyforce (1) (2) (3) (4) (5...)\nload groupbodyforce (1) (2) (3) (4) (5...)\n\n# (1) int, unique tag\n# (2) int, amplitude tag, 0 to use a default `Ramp` amplitude\n# (3) double, nominal magnitude\n# (4) int, dof tag\n# (5...) int, group tags\n</code></pre>"},{"location":"Collection/Define/load/#support-excitation","title":"Support Excitation","text":"<p>For response history analysis, sometimes it is necessary to apply excitations on supports. The multi-support excitation is automatically supported if analysts assign different excitations to different supports.</p> Text Only<pre><code>supportdisplacement (1) (2) (3) (4) (5...)\nsupportvelocity (1) (2) (3) (4) (5...)\nsupportacceleration (1) (2) (3) (4) (5...)\nload supportdisplacement (1) (2) (3) (4) (5...)\nload supportvelocity (1) (2) (3) (4) (5...)\nload supportacceleration (1) (2) (3) (4) (5...)\n# (1) int, unique tag\n# (2) int, amplitude tag, 0 to use a default `Ramp` amplitude\n# (3) double, nominal magnitude\n# (4) int, dof tag\n# (5...) int, node tags\n</code></pre> <p>Essentially, <code>supportdisplacement</code>, <code>supportvelocity</code> and <code>supportacceleration</code> are all implemented as displacement loads, thus displacement controlled scheme is automatically enabled.</p> <p>Although it is designed to be used in response history analysis, it can also be used to apply acceleration/velocity on any nodes (not only supports).</p>"},{"location":"Collection/Define/load/#uniformly-distributed-load-udl","title":"Uniformly Distributed Load (UDL)","text":"Text Only<pre><code>lineudl2d (1) (2) (3) (4) (5...)\nlineudl3d (1) (2) (3) (4) (5...)\nload lineudl2d (1) (2) (3) (4) (5...)\nload lineudl3d (1) (2) (3) (4) (5...)\n# (1) int, unique tag\n# (2) int, amplitude tag, 0 to use a default `Ramp` amplitude\n# (3) double, nominal magnitude\n# (4) int, dof tag\n# (5...) int, node tags\n</code></pre>"},{"location":"Collection/Define/load/#remarks","title":"Remarks","text":"<ol> <li>The leading <code>load</code> keyword can often be omitted for simplicity.</li> <li>The <code>acceleration</code> is by default applied to all active nodes in the model if <code>[5...]</code> is not assigned.</li> <li>The true load magnitude is the product of nominal magnitude and amplitude. This is similar to ABAQUS.</li> <li>The multipoint displacement control algorithm <code>MPDC</code> is automatically enabled if    a <code>displacement</code> or <code>groupdisplacement</code> is used.</li> <li>Optionally, the displacement can be applied by using <code>MPC</code> constraint.</li> <li>The multipoint displacement control algorithm <code>MPDC</code> is automatically enabled if    a <code>supportdisplacement</code>, <code>supportvelocity</code> and/or <code>supportacceleration</code> are used.</li> </ol> <p>It must be noted that nodal displacement loads are only valid for one single step. This means, if a displacement  load is defined within a step, it will be activated for that step only.</p> <p>All other load types will stay active once they are activated.</p>"},{"location":"Collection/Define/material/","title":"material","text":"<p>The <code>material</code> command is used to construct a material prototype. Each prototype needs a unique tag. During the initialization procedure, all valid elements will request a copy of associated material prototype for local use via the problem domain.</p> <p>Density is treated as a material property so in order to define consistent mass, often a proper density shall be assigned in the definition of the material prototypes. Most material models has density as the final optional input argument.</p> <p>Please refer to the specific type of materials for details.</p> <p>It shall be noted that some material models support initial conditions. In order to define initial conditions for the specific material model, please use the <code>initial</code> command. Please note the initial conditions are defined in the material prototype, so it is necessary to define several material models if different initial conditions are required.</p>"},{"location":"Collection/Define/modifier/","title":"modifier","text":"<p>The <code>modifier</code> objects are used to modify element response that does not considered in element itself. Typical examples include element damping matrix, lumped mass matrix, etc.</p> <p>It shall be noted that if several modifiers are defined, they are applied on the system in a sequential manner based on their tags. No parallel execution can be implemented as different orders may lead to different results.</p> <p>Users shall pay extra attention to the order of definition of modifiers.</p> <p>Please refer to <code>Modifier</code> for available modifiers.</p>"},{"location":"Collection/Define/node/","title":"node","text":"<p>Nodes are basic components in FE models. The <code>node</code> command is used to construct nodes.</p>"},{"location":"Collection/Define/node/#syntax","title":"Syntax","text":"Text Only<pre><code>node (1) [2...]\n# (1) int, unique tag\n# [2...] double, coordinates\n</code></pre>"},{"location":"Collection/Define/node/#usage","title":"Usage","text":"<p>A unique tag is required to identify different nodes. The tag shall be an unsigned integer, negative values are not allowed. Although zero is a valid tag, it is suggested to label nodes starting with one. It is not recommended to use arbitrarily large tag for any nodes, although the maximum tag is about four billion (<code>unsigned int</code>). Any unnecessarily large node tag may lead to memory leakage as some functions create matrix depending on the largest node tag to ensure all nodes could be stored.</p> <p>There is no limitation on the dimension of the node defined. A dummy node (without location) can be defined as follows. Such a node will not be used to define elements in general cases.</p> Text Only<pre><code>node 1\n</code></pre> <p>Nodes with different dimensions can coexist.</p> Text Only<pre><code>node 1\nnode 2 2. 0.\nnode 3 0.\nnode 4 9. 8. 7. 1.\n</code></pre> <p>In fact, during initialisation, the dimension of each node will be double-checked to ensure the connected elements could work properly. Meanwhile, excessive dimensions would be ignored (but not discarded) during analysis. If for example one is performing a 2D analysis and the model contains the following snippet.</p> Text Only<pre><code>node 1 3.\nnode 2 2. 1.\n# later define a 2D element connecting node 1 and node 2\n</code></pre> <p>The dimension of node 1 will be automatically expanded to 2 with zero filling so node 1 represents node \\(\\((3.0,0.0)\\)\\) in the 2D space. If, on the other hand, an 1D analysis is performed, then the second coordinate will be ignored.</p> <p>It is still recommended defining nodes with proper coordinates. Generating a node list from ABAQUS input file is an easy task.</p>"},{"location":"Collection/Define/node/#output-types","title":"Output Types","text":"<p>The following quantities can be recorded using the commands similar to <code>plainrecorder 1 Node (output_type) (nodes...)</code>.</p> variable label physical meaning U all displacement components U1, U2, U3, UR1, UR2, UR3 displacement along each DoF V all velocity components V1, V2, V3, VR1, VR2, VR3 velocity along each DoF A all acceleration components A1, A2, A3, AR1, AR2, AR3 acceleration along each DoF RF all resistance components RF1, RF2, RF3, RM1, RM2, RM3 resistance along each DoF DF all damping force components DF1, DF2, DF3, DM1, DM2, DM3 damping force along each DoF IF all inertial force components IF1, IF2, IF3, IM1, IM2, IM3 inertial force along each DoF"},{"location":"Collection/Define/node/#remarks","title":"Remarks","text":"<ol> <li>For static analysis, normally only displacement <code>U</code> and resistance <code>RF</code> are activated. Thus recording other     quantities return trivial results.</li> <li>If the required quantity is not active, the output will be empty.</li> <li>The damping and inertial forces are collected from all the elements in the model. It must be noted that the     recorded values do not include any contributions that do not stem from elements. For example, the damping     force given by global damping models cannot be split to individual elements, thus it is not reflected in the     nodal damping force. This design is necessary as one may wish to separate contributions from various sources apart.</li> <li>To record global damping and inertial forces that account for the total force, use <code>GDF</code>, <code>GDF1</code>, <code>GDF2</code>,     <code>GDF3</code>, <code>GDF4</code>, <code>GDF5</code>, <code>GDF6</code>, <code>GIF</code>, <code>GIF1</code>, <code>GIF2</code>, <code>GIF3</code>, <code>GIF4</code>, <code>GIF5</code>, <code>GIF6</code>, which stand for global     damping force and global inertial force.</li> </ol>"},{"location":"Collection/Define/recorder/","title":"recorder","text":"<p>Model response can be recorded and output in a tabular fashion.</p> <p>Currently, there are two main file formats supported:</p> <ol> <li>plain text,</li> <li>hdf5 file.</li> </ol> <p>Please check Recorder.md for details.</p>"},{"location":"Collection/Define/section/","title":"section","text":"<p>Please refer to the specific type of sections for details.</p>"},{"location":"Collection/Process/benchmark/","title":"benchmark","text":"<p>The <code>benchmark</code> command can be used to benchmark the platform to provide a performance baseline.</p> <p>The routine preallocates a square matrix of size 5120 and repeatedly solves it for 50 times. Unlike other approaches that normally rely on <code>dgemm</code> subroutine, here <code>dgesv</code> subroutine is used as for FEM, the main operations are solving  matrices rather than multiplying matrices.</p>"},{"location":"Collection/Process/benchmark/#syntax","title":"Syntax","text":"Text Only<pre><code>benchmark\n</code></pre>"},{"location":"Collection/Process/benchmark/#notes","title":"Notes","text":"<p>The basic idea of the benchmark resembles that of linpack, but it is not intended to be as versatile as linpack. Thus, it does not provide any configurable options.</p> <p>The theoretical maximum GFLOPS is not often achievable in practical applications. Modern hardware is often bounded  by other factors such as memory bandwidth.</p> <p>One can <code>perf</code> this benchmark to reveal the GFLOPS, for example,</p> Bash<pre><code>echo \"benchmark\" &gt;&gt;b\necho \"exit\" &gt;&gt;b\nperf stat -e fp_arith_inst_retired.128b_packed_double,fp_arith_inst_retired.256b_packed_double,fp_arith_inst_retired.512b_packed_double,fp_arith_inst_retired.scalar_double suanpan -f b\n</code></pre> <p>The corresponding result is</p> Text Only<pre><code>+--------------------------------------------------+\n|   __        __         suanPan is an open source |\n|  /  \\      |  \\           FEM framework (64-bit) |\n|  \\__       |__/  __   __      Betelgeuse (2.4.0) |\n|     \\ |  | |    |  \\ |  |      by tlc @ b3918adf |\n|  \\__/ |__| |    |__X |  |    all rights reserved |\n|                           10.5281/zenodo.1285221 |\n+--------------------------------------------------+\n|  \ud83e\uddee https://github.com/TLCFEM/suanPan            |\n|  \ud83d\udcda https://github.com/TLCFEM/suanPan-manual     |\n+--------------------------------------------------+\n|  \ud83d\udd0b https://gitter.im/suanPan-dev/community      |\n+--------------------------------------------------+\n\n[==================================================]\nCurrent platform rates (higher is better): 25.58.\n\nTime Wasted: 39.3980 Seconds.\n\n Performance counter stats for 'suanpan -f b':\n\n        17,075,053      fp_arith_inst_retired.128b_packed_double                                   \n         3,849,289      fp_arith_inst_retired.256b_packed_double                                   \n   563,539,901,688      fp_arith_inst_retired.512b_packed_double                                   \n       122,202,329      fp_arith_inst_retired.scalar_double                                   \n\n      39.428329959 seconds time elapsed\n\n     130.321384000 seconds user\n       3.369368000 seconds sys\n</code></pre> <p>This roughly gives 114 GFLOPS, which is around \\(\\(60\\%\\)\\) of the theoretical maximum GFLOPS of a <code>i7-1185G7</code> processor. Of course, the actual performance depends on many other factors. Here the  numbers are indicative. A rate of \\(\\(2n\\)\\) means the platform is two times faster than a rate of \\(\\(n\\)\\).</p> <p>The practical FEM involves other processes such as updating elemental stiffness (small matrix manipulations) and  assembling global stiffness (random memory accesses). As the result, the performance of analysis would further be a  fraction of GFLOPS of this benchmark test.</p>"},{"location":"Collection/Process/clear/","title":"clear","text":"<p>The <code>clear</code> command clears all information of the current domain.</p>"},{"location":"Collection/Process/clear/#syntax","title":"Syntax","text":"Text Only<pre><code>clear\n</code></pre>"},{"location":"Collection/Process/command/","title":"command","text":"<p>The <code>command</code> can be used to list all available commands.</p>"},{"location":"Collection/Process/command/#syntax","title":"Syntax","text":"Text Only<pre><code>command\n</code></pre>"},{"location":"Collection/Process/enable/","title":"enable/disable/remove","text":""},{"location":"Collection/Process/enable/#enabledisableremove-objects","title":"Enable/Disable/Remove Objects","text":"<p>In <code>suanPan</code>, defining some objects does not necessarily mean those will be considered in analysis. Instead, each object has an 'active' flag, only active objects will be considered. Thus, it is possible to define a set of candidate objects (for example, a number of loads), and test different cases with different objects.</p> <p>Furthermore, it is possible to remove some wrongly defined objects before performing the analysis.</p> Text Only<pre><code>enable (1) [2...]\ndisable (1) [2...]\nremove (1) [2...]\n# (1) string, object type\n# [2...] int, tags\n</code></pre> <p>For object types, possible values are: <code>domain</code>, <code>step</code>, <code>converger</code>, <code>constraint</code>, <code>load</code>, <code>element</code>, <code>node</code> , <code>recorder</code>, <code>modifier</code>, <code>expression</code>.</p>"},{"location":"Collection/Process/enable/#enabledisable-print-output","title":"Enable/Disable Print Output","text":"<p>Additionally, it is possible to enable or disable output. Printing to screen buffer takes time. Once the model is confirmed to be correctly established, users can disable print to improve speed. Third-party libraries are not controlled by this command thus may print.</p> Text Only<pre><code>enable print\ndisable print\n</code></pre>"},{"location":"Collection/Process/exit/","title":"exit","text":"<p>The <code>exit</code> command exits.</p>"},{"location":"Collection/Process/exit/#syntax","title":"Syntax","text":"Text Only<pre><code>exit\n</code></pre>"},{"location":"Collection/Process/materialtest/","title":"materialtest","text":"<p>This command category can be used to test most material models depend on strain input only without establishing a FE model. Some wrappers and material models that rely on other material models cannot be tested in this way.</p>"},{"location":"Collection/Process/materialtest/#syntax","title":"Syntax","text":"Text Only<pre><code>materialTest1D (1) (2) (3) [4...]\n# (1) int, unique tag of the material model to use\n# (2) double, size of per strain increment\n# (3) int, number of steps along increment direction\n# [4...] int, optional numbers of steps for strain history\n\nmaterialTest2D (1) (2...4) (5) [6...]\n# (1) int, unique tag of the material model to use\n# (2...4) double, size of per strain increment\n# (5) int, number of steps along increment direction\n# [6...] int, optional numbers of steps for strain history\n\nmaterialTest3D (1) (2...7) (8) [9...]\n# (1) int, unique tag of the material model to use\n# (2...7) double, size of per strain increment\n# (8) int, number of steps along increment direction\n# [9...] int, optional numbers of steps for strain history\n</code></pre>"},{"location":"Collection/Process/materialtest/#remarks","title":"Remarks","text":"<ol> <li>The increment size could be either positive or negative.</li> <li>The loading direction reverses after given numbers of steps.</li> <li>The strain-stress history would be saved to <code>RESULT.txt</code>. If <code>HDF5</code> is used, the result would be additionally saved    to <code>RESULT.h5</code>. Besides, a <code>gnuplot</code> file named <code>RESULT.plt</code> will be generated.</li> </ol>"},{"location":"Collection/Process/materialtest/#usage","title":"Usage","text":"<p>To use the tester, it is necessary to define a material beforehand. Here a <code>Bilinear1D</code> model is defined with elastic modulus \\(\\(E=1000.0\\)\\), yield stress \\(\\(\\sigma_y=10.0\\)\\) and a negative hardening ratio \\(\\(h=-0.2\\)\\).</p> Text Only<pre><code>material Bilinear1D 1 1000.0 10.0 -0.2\n</code></pre> <p>The following command loads towards positive strain direction for 300 increments with increment size of \\(\\(0.0001\\)\\) then negative direction for another 300 increments and eventually 200 increments towards positive direction. The ending strain would be \\(\\(\\varepsilon=0.02\\)\\).</p> Text Only<pre><code>materialTest1D 1 0.0001 300 300 200\n</code></pre> <p>The output is shown as follows.</p> <p></p>"},{"location":"Collection/Process/materialtestbyload/","title":"materialtestbyload","text":"<p>This command category can be used to test most material models depend on load/stress input only without establishing a FE model. Some wrappers and material models that rely on other material models cannot be tested in this way.</p>"},{"location":"Collection/Process/materialtestbyload/#syntax","title":"Syntax","text":"Text Only<pre><code>materialTestByLoad1D (1) (2) (3) [4...]\n# (1) int, unique tag of the material model to use\n# (2) double, size of per stress increment\n# (3) int, number of steps along increment direction\n# [4...] int, optional numbers of steps for stress history\n\nmaterialTestByLoad2D (1) (2...4) (5) [6...]\n# (1) int, unique tag of the material model to use\n# (2...4) double, size of per stress increment\n# (5) int, number of steps along increment direction\n# [6...] int, optional numbers of steps for stress history\n\nmaterialTestByLoad3D (1) (2...7) (8) [9...]\n# (1) int, unique tag of the material model to use\n# (2...7) double, size of per stress increment\n# (8) int, number of steps along increment direction\n# [9...] int, optional numbers of steps for stress history\n</code></pre>"},{"location":"Collection/Process/materialtestbyload/#remarks","title":"Remarks","text":"<ol> <li>The Newton-Raphson method is implemented to solve the corresponding strain increments. Thus softening models should    not be tested in this way.</li> </ol>"},{"location":"Collection/Process/peek/","title":"peek","text":"<p>The <code>peek</code> command can be used to print out predefined information. This command has no effect if global screen print is switched off.</p>"},{"location":"Collection/Process/peek/#syntax","title":"Syntax","text":"Text Only<pre><code>peek node (1)\npeek element (1)\npeek material (1)\npeek constraint (1)\npeek recorder (1)\npeek solver (1)\npeek integrator (1)\npeek group (1)\npeek amplitude (1)\n# (1) int, object tag\n\npeek eigenvalue\n</code></pre>"},{"location":"Collection/Process/plot/","title":"plot","text":"<p>The <code>plot</code> command can be used to plot and save visualization as <code>.vtk</code> file.</p> <p>Only binaries compiled with VTK libraries can use this command. Otherwise, it does nothing.</p> <p>Since <code>Paraview</code> can be used to perform all kinds of post-processing, the objective is not to implement a full-featured visualisation support.</p>"},{"location":"Collection/Process/plot/#syntax","title":"Syntax","text":"<p>The <code>plot</code> command uses a different parsing mechanism.</p> Text Only<pre><code>plot [-keyword [-parameters]...]\n</code></pre> <p>Available keywords and corresponding parameters are listed as follows.</p> <ol> <li><code>scale</code> controls the scale of deformed configuration. A single double value is required as parameter. If <code>undeformed</code>    is used, then <code>scale</code> will be set to zero. Example: <code>scale 2</code></li> <li><code>deformed</code> sets deformed plot.</li> <li><code>undeformed</code> sets undeformed plot.</li> <li><code>type</code> controls which quantity shall be extracted and plotted. A single string is required as parameter. Available    values can be seen in output types. Example: <code>type U1</code></li> <li><code>fontsize</code> controls the font size of legend, title, etc. This has no effect if the plot is saved.    Example: <code>fontsize 14</code></li> <li><code>nobar</code> disables legend in plot window.</li> <li><code>material</code> filters the elements plotted based on material tag. A single unsigned integer is required as parameter.    Example: <code>material 1</code></li> <li><code>size</code> controls the size of plot window. Two double values are required. Examples: <code>size 300 400</code></li> <li><code>save</code> indicates the file name. A string value with suffix of <code>.vtk</code> is required. Example: <code>save S11.vtk</code></li> </ol>"},{"location":"Collection/Process/plot/#remarks","title":"Remarks","text":"<p>Invoking this command with proper parameters spawn an interactive rendering window using VTK. It offers a quick view of the model. The spawned window can be closed by pressing <code>q</code> key. The spawned window does not block the application so it is possible to plot multiple quantities at the same time. However, new analysis won't be performed until all the windows are closed.</p>"},{"location":"Collection/Process/plot/#example","title":"Example","text":""},{"location":"Collection/Process/protect/","title":"protect","text":"<p>In for example structural optimization, elements will be disabled when necessary. For some analysis, some elements shall never be disabled. To this end, users can use <code>protect</code> to protect those elements from being modified.</p>"},{"location":"Collection/Process/protect/#syntax","title":"Syntax","text":"Text Only<pre><code>protect node (1...)\nprotect element (1...)\n# (1...) int, node/element tags\n</code></pre>"},{"location":"Collection/Process/pwd/","title":"pwd","text":"<p>The <code>pwd</code> command resembles the same command in Unix-like systems, which can be used to print/set current working path.</p> <p>To load files from another path while to save the keystrokes at the same time, users can set current working path to the folder contains the desired modal script first.</p>"},{"location":"Collection/Process/pwd/#syntax","title":"Syntax","text":"<p>To check the current working path, please use</p> Text Only<pre><code>pwd\n</code></pre> <p>To change the current working path, please use</p> Text Only<pre><code>pwd (1)\n# (1) string, new absolute working path\n</code></pre> <p>Please note in Windows, <code>\\</code> needs to be changed to <code>\\\\</code> or <code>/</code>. Note relative paths are not supported.</p>"},{"location":"Collection/Process/reset/","title":"reset","text":"<p>Reset Model</p>"},{"location":"Collection/Process/reset/#syntax","title":"Syntax","text":"<p>The <code>reset</code> command resets the trial state to the latest converged state.</p> Text Only<pre><code>reset\n</code></pre>"},{"location":"Collection/Process/response_spectrum/","title":"response_spectrum","text":"<p>Compute Response Spectrum of a Given Accelerogram</p> <p>Minimum version: v2.6</p> <p>Reference:</p> <ol> <li>https://doi.org/10.1016/S0267-7261(05)80015-6</li> </ol> <p>Please note the following.</p> <ol> <li>Only applies to elastic system.</li> <li>Only trivial initial conditions are accounted for.</li> </ol>"},{"location":"Collection/Process/response_spectrum/#syntax","title":"Syntax","text":""},{"location":"Collection/Process/response_spectrum/#form-a","title":"Form A","text":"<p>For accelerogram record stored in single column plain text file. The following syntax can be used.</p> Text Only<pre><code>response_spectrum (1) (2) (3) (4)\n# (1) string, file path of the accelerogram file\n# (2) string, file path of the period file\n# (3) double, sampling interval\n# (4) double, damping ratio\n</code></pre> <p>The accelerogram stores discrete acceleration amplitudes in the first column of the file.</p> <p>The desired period points where the response spectrum is computed are stored in the first column of the period file. The period file itself can have multiple columns, but only the first column is used.</p> <p>As the accelerogram only provides the amplitudes, the sampling interval must be provided as the <code>(3)</code> argument.</p>"},{"location":"Collection/Process/response_spectrum/#form-b","title":"Form B","text":"<p>For accelerogram record stored in double column plain text file. The following syntax can be used.</p> Text Only<pre><code>response_spectrum (1) (2) (3)\n# (1) string, file path of the accelerogram file\n# (2) string, file path of the period file\n# (3) double, damping ratio\n</code></pre> <p>The accelerogram stores the time and acceleration amplitudes in the first and second columns of the file.</p> <p>The time series must be equally spaced.</p> <p>The desired period points where the response spectrum is computed are stored in the first column of the period file. The period file itself can have multiple columns, but only the first column is used.</p>"},{"location":"Collection/Process/response_spectrum/#remarks","title":"Remarks","text":"<p>The sampling interval is provided as the <code>(3)</code> argument in Form A, and is computed from the time series in Form B.</p> <p>The same sampling interval is used in Lee's algorithm to compute the response histories. If the provided interval is  large, the response spectra may be inaccurate. One can use the <code>upsampling</code> command to process the  accelerogram before using the <code>response_spectrum</code> command.</p>"},{"location":"Collection/Process/response_spectrum/#example","title":"Example","text":"<p>See this example.</p>"},{"location":"Collection/Process/save/","title":"save","text":"<p>The <code>save</code> command can be used to save data to disk.</p>"},{"location":"Collection/Process/save/#syntax","title":"Syntax","text":"Text Only<pre><code>save recorder (1)\n# (1) int, recorder tag\n</code></pre>"},{"location":"Collection/Process/sdof_response/","title":"sdof_response","text":"<p>Compute Response of a Single Degree of Freedom Oscillator to a Given Acceleration Record</p> <p>Minimum version: v2.6</p> <p>Reference:</p> <ol> <li>https://doi.org/10.1016/S0267-7261(05)80015-6</li> </ol> <p>Please note the following.</p> <ol> <li>Only applies to elastic system.</li> <li>Only trivial initial conditions are accounted for.</li> </ol>"},{"location":"Collection/Process/sdof_response/#syntax","title":"Syntax","text":"<p>The frequency of the oscillator is used. Its unit is Hertz (Hz).</p> <p>Please note the natural frequency shall not be passed to the command. The natural frequency has a unit of radian per second (rad/s).</p>"},{"location":"Collection/Process/sdof_response/#form-a","title":"Form A","text":"<p>For accelerogram record stored in single column plain text file. The following syntax can be used.</p> Text Only<pre><code>sdof_response (1) (2) (3) (4)\n# (1) string, file path of the accelerogram file\n# (2) double, sampling interval\n# (3) double, frequency of the system\n# (4) double, damping ratio\n</code></pre> <p>The accelerogram stores discrete acceleration amplitudes in the first column of the file.</p> <p>As the accelerogram only provides the amplitudes, the sampling interval must be provided as the <code>(2)</code> argument.</p>"},{"location":"Collection/Process/sdof_response/#form-b","title":"Form B","text":"<p>For accelerogram record stored in double column plain text file. The following syntax can be used.</p> Text Only<pre><code>response_spectrum (1) (2) (3)\n# (1) string, file path of the accelerogram file\n# (2) double, frequency of the system\n# (3) double, damping ratio\n</code></pre> <p>The accelerogram stores the time and acceleration amplitudes in the first and second columns of the file.</p> <p>The time series must be equally spaced.</p>"},{"location":"Collection/Process/sdof_response/#example","title":"Example","text":"<p>See this example.</p>"},{"location":"Collection/Process/set/","title":"set","text":"<p>The <code>set</code> command is used to set some properties of the analysis.</p>"},{"location":"Collection/Process/set/#linear-elastic-simplification","title":"Linear Elastic Simplification","text":"<p>In a general non-linear context, each substep requires at least two system solving, one for initial guess, one for convergence test. There is no general way to detect linear system automatically, with which we know the initial guess leads to convergence so that the further system solving is not necessary. To speed up simulation, one can use the following command to indicate the system is linear.</p> Text Only<pre><code>set linear_system true\n</code></pre> <p>With this enabled, only one system solving will be performed in each substep.</p>"},{"location":"Collection/Process/set/#substepping-control","title":"Substepping Control","text":"<p>To use a fixed substep size, users can define</p> Text Only<pre><code>set fixed_step_size true\n</code></pre> <p>Otherwise, the algorithm will automatically substep the current step if convergence is not met. The time step control strategy cannot be customized.</p> <p>To define the initial step size, users can use</p> Text Only<pre><code>set ini_step_size (1)\n# (1) double, substep size\n</code></pre> <p>To define the maximum/minimum step size, users can use</p> Text Only<pre><code>set max_step_size (1)\nset min_step_size (1)\n# (1) double, target time step size\n</code></pre>"},{"location":"Collection/Process/set/#solving-related-settings","title":"Solving Related Settings","text":""},{"location":"Collection/Process/set/#matrix-storage-scheme","title":"Matrix Storage Scheme","text":""},{"location":"Collection/Process/set/#asymmetric-banded","title":"Asymmetric Banded","text":"<p>By default, an asymmetric banded matrix storage scheme is used. For 1D analysis, the global stiffness matrix is always symmetric. However, when it comes to 2D and 3D analyses, the global stiffness may be structurally symmetric in terms of its layout, but there may not have the same value on the symmetric entries. In maths language, if \\(\\(K(i,j) \\neq0\\)\\) then \\(\\(K(j,i)\\neq0\\)\\), but \\(\\(K(i,j)\\neq{}K(j,i)\\)\\). Hence, an asymmetric banded storage is the safest. The <code>_gbsv()</code> LAPACK subroutine is used for matrix solving.</p>"},{"location":"Collection/Process/set/#symmetric-banded","title":"Symmetric Banded","text":"<p>It shall be noted that the symmetric scheme can save almost \\(\\(50\\%\\)\\) of the memory used in the asymmetric scheme. The <code>_pbsv()</code> LAPACK subroutine is used. This subroutine can only deal with symmetric positive definite band matrix. For some problems, in which the matrix is not necessarily positive definite, for example the buckling problems, this subroutine fails. Before enabling the symmetric banded storage, the analyst must check if the matrix is SPD.</p>"},{"location":"Collection/Process/set/#full-storage","title":"Full Storage","text":"<p>If the problem scale is small, it does not hurt if a full storage scheme is used. For some particular issues such as particle collision issues, the full storage scheme is the only option.</p>"},{"location":"Collection/Process/set/#full-packed-storage","title":"Full Packed Storage","text":"<p>If the matrix is symmetric, a so-called pack format can be used to store the matrix. Essentially, only the upper or the lower triangle of the matrix is stored. The spatial cost is half of that of the full storage, but the solving speed is no better. The <code>_spsv()</code> subroutine is used for matrix solving. It is not recommended using this packed scheme.</p>"},{"location":"Collection/Process/set/#sparse-storage","title":"Sparse Storage","text":"<p>The sparse matrix is also supported. Several sparse solvers are implemented.</p>"},{"location":"Collection/Process/set/#direct-system-solver","title":"Direct System Solver","text":"<p>Different solvers are implemented for different storage schemes. It is possible to switch from one to another by using the following command. Details are covered in the summary table.</p> Text Only<pre><code>set system_solver (1)\n# (1) string, system solver name\n</code></pre>"},{"location":"Collection/Process/set/#mixed-precision-algorithm","title":"Mixed Precision Algorithm","text":"<p>The following command can be used to control if to use mixed precision refinement. This command has no effect if the target matrix storage scheme has no mixed precision implementation.</p> Text Only<pre><code>set precision (1)\n# (1) string, \"single\" (\"mixed\") or \"double\" (\"full\")\n</code></pre>"},{"location":"Collection/Process/set/#iterative-refinement","title":"Iterative Refinement","text":"<p>The maximum number of refinements can be bounded by</p> Text Only<pre><code>set iterative_refinement (1)\n# (1) integer, maximum number of refinements\n</code></pre>"},{"location":"Collection/Process/set/#iterative-refinement-tolerance","title":"Iterative Refinement Tolerance","text":"<p>If the mixed precision algorithm is used, it is possible to use the following command to control the tolerance.</p> Text Only<pre><code>set tolerance (1)\n# (1) double, tolerance of the iterative solver\n</code></pre> <p>Typically, each refinement reduces the error by a factor of \\(\\(10^{-7}\\)\\). Thus two or three refinements should be  sufficient to achieve the working precision.</p> <p>Thus, the following command set makes sense.</p> Text Only<pre><code>set precision mixed\nset iterative_refinement 3\nset tolerance 1e-15\n</code></pre>"},{"location":"Collection/Process/set/#summary","title":"Summary","text":"<p>All available settings are summarised in the following table.</p> storage configuration configuration system solver mixed precision subroutine in external library full <code>set symm_mat false</code> <code>set band_mat false</code> <code>LAPACK</code> yes <code>d(s)gesv</code> <code>CUDA</code> yes <code>cusolverDnD(S)gesv</code> symm. banded <code>set symm_mat true</code> <code>set band_mat true</code> <code>LAPACK</code> yes <code>d(s)pbsv</code> <code>SPIKE</code> yes <code>d(s)spike_gbsv</code> asymm. banded <code>set symm_mat false</code> <code>set band_mat true</code> <code>LAPACK</code> yes <code>d(s)gbsv</code> <code>SPIKE</code> yes <code>d(s)spike_gbsv</code> symm. packed <code>set symm_mat true</code> <code>set band_mat false</code> <code>LAPACK</code> yes <code>d(s)ppsv</code> sparse <code>set sparse_mat true</code> <code>SuperLU</code> yes <code>d(s)gssv</code> <code>CUDA</code> yes <code>cusolverSpD(S)csrlsvqr</code> <code>MUMPS</code> no <code>dmumps_c</code> <code>PARDISO</code> no <code>pardiso</code> <code>FGMRES</code> no <code>dfgmres</code> <p>Some empirical guidance can be concluded as follows.</p> <ol> <li>For most cases, the asymmetric banded storage with full precision solver is the most general option.</li> <li>The best performance is obtained by using symmetric banded storage, if the (effective) stiffness matrix is guaranteed    to be positive definite, users shall use it as a priority.</li> <li>The mixed precision algorithm often gives the most significant performance boost for full storage with <code>CUDA</code> solver.    It outperforms the full precision algorithm when the size of system exceeds several thousands.</li> <li>The <code>SPIKE</code> solver is slightly slower than the conventional <code>LAPACK</code> implementations.</li> <li>The <code>SuperLU</code> solver is slower than the <code>MUMPS</code> solver. The multithreaded <code>SuperLU</code> performs LU factorization in    parallel but forward/back substitution in sequence.</li> <li>The <code>PARDISO</code> direct solver and <code>FGMRES</code> iterative solver are provided by <code>MKL</code>.</li> <li>The <code>MUMPS</code> solver supports both symmetric and asymmetric algorithms. One can use <code>set symm_mat true</code>    or <code>set symm_mat false</code>.</li> </ol>"},{"location":"Collection/Process/set/#iterative-system-solver","title":"Iterative System Solver","text":"<p>[available from v2.5]</p> <p>It is possible to use iterative solvers to solve the linear system of equations. Currently, two solvers are available  by using the following command.</p> Text Only<pre><code>set system_solver BiCGSTAB\nset system_solver GMRES\n</code></pre> <p>As the iterative solvers are relatively independent of the matrix storage scheme, thus, all different storage  schemes can be used along with different iterative solvers. One should beware that different storage schemes may  affect the performance of iterative solvers as they largely depend on matrix--vector multiplication.</p> <p>Mixed precision solving is not supported by the iterative solvers.</p>"},{"location":"Collection/Process/set/#preconditioner","title":"Preconditioner","text":"<p>Three preconditioners are available for the iterative solvers.</p> Text Only<pre><code>set preconditioner None\nset preconditioner Jacobi\nset preconditioner ILU\n</code></pre> <p>The <code>None</code> preconditioner uses identify matrix as the preconditioner.</p> <p>The <code>Jacobi</code> preconditioner uses the diagonal of the matrix as the preconditioner. This is the default one but may  not perform well for certain problems.</p> <p>The <code>ILU</code> preconditioner uses the incomplete LU factorization of the matrix as the preconditioner. This <code>ILU</code> preconditioner is provided by the <code>SuperLU</code> library.</p> <p>If the iterative solver is used, then it is possible to set the tolerance of the iterative solver. In this case,  tolerance assigned will not be used by mixed precision algorithm as it is not activated due to an iterative solver  is defined.</p> Text Only<pre><code>set tolerance (1)\n# (1) double, tolerance of the iterative solver\n</code></pre>"},{"location":"Collection/Process/set/#parallel-matrix-assembling","title":"Parallel Matrix Assembling","text":"<p>For dense matrix storage schemes, the global matrix is stored in a consecutive chunk of memory. Assembling global matrix needs to fill in the corresponding memory location with potentially several values contributed by different elements. Often in-place atomic summation is involved. To assign each memory location a mutex lock is not cost-efficient. Instead, a \\(\\(k\\)\\)-coloring concept can be adopted to divide the whole model into several groups. Each group contains elements that do not share common nodes with others in the same group. By such, no atomic operations are required. Elements in the same group can be updated simultaneously so the matrix assembling is lock free.</p> <p>By default, the coloring algorithm is enabled. To disable it, users can use the following command.</p> Text Only<pre><code>set color_model false\nset color_model none\n</code></pre> <p>As a NP hard problem, there is no optimal algorithm to find the minimum chromatic number. The Welsh-Powell algorithm is implemented in <code>suanPan</code>. The maximum independent set algorithm is also available, it may outperform the  Welsh-Powell algorithm on large models. To switch, users can use the following command.</p> Text Only<pre><code># default to WP algorithm\nset color_model WP\n# switch to MIS algorithm\nset color_model MIS\n</code></pre> <p>Also, depending on the problem setup, such a coloring may or may not help to improve the performance. If there are not a large number of matrix assembling, the time saved may not be significant. Thus, for problems of small sizes, users may consider disabling coloring.</p> <p>This option has no effect if a sparse storage is used.</p>"},{"location":"Collection/Process/set/#penalty-number","title":"Penalty Number","text":"<p>For some constraints and loads that are implemented by using the penalty method, the default penalty number can be overridden.</p> Text Only<pre><code>set constraint_multiplier (1)\nset load_multiplier (1)\n# (1) double, new penalty number\n</code></pre> <p>This command does not overwrite user defined penalty number if the specific constraint or load takes the penalty number than input arguments.</p>"},{"location":"Collection/Process/set/#fgmres-iterative-tolerance","title":"FGMRES Iterative Tolerance","text":"<p>For <code>FGMRES</code> iterative solver, one can use the following dedicated command to control the tolerance of the algorithm.</p> Text Only<pre><code>set fgmres_tolerance (1)\n# (1) double, tolerance\n</code></pre> <p>If the boundary condition is applied via the penalty method, say for example one previously uses <code>set constraint_multiplier 1E8</code>, then there is no need to set a tolerance smaller than <code>1E-8</code>. A slightly larger value is sufficient for an iterative algorithm, one can then set</p> Text Only<pre><code>set fgmres_tolerance 1E-6\n</code></pre>"},{"location":"Collection/Process/terminal/","title":"terminal","text":"<p>The <code>terminal</code> command can be used to execute external commands.</p> Text Only<pre><code>terminal (1)\n# (1) string, external command to be executed\n</code></pre> <p>The <code>terminal</code> command can only be used to external non-interactive commands. It invokes <code>std::system</code> function to execute commands in the host environment's command processor.</p> <p>Commands such as <code>chdir</code> will not work as the spawned process will quit when the command is executed.</p>"},{"location":"Collection/Process/upsampling/","title":"upsampling","text":"<p>Upsample a Given Seismogram</p> <p>Minimum version: v2.6</p>"},{"location":"Collection/Process/upsampling/#syntax","title":"Syntax","text":"Text Only<pre><code>upsampling (1) (2) [3]\n# (1) string, file path of the seismogram file\n# (2) integer, upsampling rate\n# [3] string, window type, default: 'Hamming'\n</code></pre>"},{"location":"Collection/Process/upsampling/#remarks","title":"Remarks","text":"<p>The seismogram must be stored in double column plain text file. The first column stores the time series, and the second column stores the acceleration amplitudes.</p> <p>The time series must be equally spaced.</p> <p>The window type can be one of the following:</p> <ul> <li>Hamming</li> <li>Hann</li> <li>Blackman</li> <li>BlackmanNuttall</li> <li>BlackmanHarris</li> <li>FlatTop</li> </ul> <p>If the upsampling rate is denoted as \\(\\(L\\)\\), the window length is \\(\\(8L+1\\)\\).</p>"},{"location":"Developer/Prerequisites/","title":"Prerequisites","text":"<p>The linear algebra module is implemented by Armadillo. It is necessary to learn some basic syntaxes in order to work with vector and matrix objects provided. Armadillo provides a complete support to linear algebra computation and has a syntax similar to Matlab, users who are familiar with Matlab can easily get started with Armadillo.</p> <p>New standards (C++11, C++14 and C++17) are utilised to simplify development. cppreference provides a complete reference to C++.</p>"},{"location":"Developer/C/material/","title":"material","text":"<p>Passing CPP objects to/from libraries may have stability issues. The strong coupling between main executable and library results in users have to make sure both executable and library are compiled with the same compiler of the same version. This does not sound nice.</p> <p>A C type interface is more stable. The C interface of material models is implemented via a common function with a trailing <code>_handler</code>. The function takes a pointer to <code>ExternalMaterialData</code> structure with plain PODs as input argument and operates on that based on the operation indicated by a pointer to an integer. If the material model has a name of <code>samplemat</code>, then the signature will be</p> C++<pre><code>SUANPAN_EXPORT void samplemat_handler(ExternalMaterialData* data, int* info);\n</code></pre>"},{"location":"Developer/C/material/#communication-convention","title":"Communication Convention","text":"<p>On entry, based on different values of <code>*info</code>, a set of different operations need to be done and the corresponding results need to be stored in <code>*data</code>. The structure of <code>*data</code> would be explained later, we focus on <code>*info</code> in this section.</p> <p>In general, two states should be managed in the material model. The current state stores converged variables from the last converged time step. The trial state stores updated variables based on trial strain, trial strain rate, etc. This state may or may not be the converged state, thus may or may not be kept in an incremental setup.</p> value operation 0 allocate memory, initialise variables based on parameters defined by users 1 deallocate memory that is previously allocated in operation <code>*info=0</code> 2 update material state based on new trial strain only 3 update material state based on new trial strain and new trial strain rate 4 commit trial state to current state 5 reset trial state to current state 6 clear both current and trial state to zero 7 validate if the model parameters are legal <p>Some remarks to explain those operations.</p> <ol> <li>In operation <code>*info=0</code>, memory shall be allocated to store two states and other relevant variables. Since it is not    known to the main executable how large the memory is required, this has to be done by the library using whatever    methods to allocate.</li> <li>In operation <code>*info=2</code>, trial state is updated based on trial strain and current state (as an incremental form is    implemented). This operation will be called in a static analysis, or by elements that only computes strains. Before    calling this operation, the trial strain will be written to the corresponding location of allocated memory some place    defined in <code>*data</code>.</li> <li>In operation <code>*info=3</code>, trial state is updated based on trial strain, trial strain rate and current state (as an    incremental form is implemented). This operation will be called by elements that computes both strains and strain    rates and pass them to material models. Often, the resulting stiffness and damping matrices shall be computed. Before    calling this operation, the trial strain and the trial strain rate will be written to the corresponding location of    allocated memory some place defined in <code>*data</code>.</li> <li>In operation <code>*info=4</code>, we simply overwrite current state with trial state as the trial state now converges after    several iterations.</li> <li>In operation <code>*info=5</code>, when this operation is called, convergence is not met, so we overwrite trial state with    current state and update the system with a smaller increment of (pseudo) time.</li> <li>In operation <code>*info=6</code>, all state variables and history variables shall be reverted to initial (potential zero)    state.</li> <li>In operation <code>*info=7</code>, all model parameters shall be checked to see if a proper material model can be defined. This    cannot be done in the main executable although the command is processed in the main executable, in which all    parameters will be read as double inputs and stored in a raw double array in <code>*data</code>.</li> </ol> <p>In a typical analysis flow, <code>*info=0</code> will be called first to initialise memory, then <code>*info=7</code> will be called to valid parameters. If it fails, <code>*info=1</code> will be called. Otherwise, either <code>*info=2</code> or <code>*info=3</code> will be called to update states, followed by appropriate remaining operations.</p> <p>For any material models, developers must provide implementations of the above eight operations. Whether those implementations are combined with the exported handler or wrapped in separate functions is left to developers to decide.</p> <p>On exit, <code>*info=0</code> indicates the operation succeeds and no error has been reported, it can be set to other values to terminate analysis.</p>"},{"location":"Developer/C/material/#data-layout","title":"Data Layout","text":"<p>The <code>ExternalMaterialData</code> structure has the following definition.</p> C++<pre><code>struct ExternalMaterialData {\nunsigned size = 0;          // indicate the dimension of material\nunsigned constant_size = 0; // indicate the number of constants\nint c_strain = -1;      // current status\nint c_strain_rate = -1; // current status\nint c_stress = -1;      // current status\nint t_strain = -1;      // trial status\nint t_strain_rate = -1; // trial status\nint t_stress = -1;      // trial status\nint c_history = -1;   // current status\nint c_stiffness = -1; // stiffness matrix\nint c_damping = -1;   // damping matrix\nint t_history = -1;   // trial status\nint t_stiffness = -1; // stiffness matrix\nint t_damping = -1;   // damping matrix\nint i_history = -1;   // initial status\nint i_stiffness = -1; // stiffness matrix\nint i_damping = -1;   // damping matrix\ndouble density = 0.;\ndouble* pool = nullptr;     // stores states, should be allocated by dll\ndouble* constant = nullptr; // stores model constants, should be allocated by main exe\n};\n</code></pre> <p>The unsigned integers are used to indicate the sizes. For 1D, 2D and 3D problems, <code>size</code> should be <code>1</code>, <code>3</code> and <code>6</code>. The <code>constant</code> pointer points to the head of model parameters.</p> <p>The integers are indices used to indicate the location of the first element of the corresponding variable in <code>pool</code>. A negative value <code>-1</code> means the corresponding variable is not used by the model. For a 3D trial strain, it will be stored in the continuous memory from <code>pool[t_strain]</code> to <code>pool[t_strain+6]</code>.</p> <p>During initialisation (<code>*info=0</code>), some positive values shall be assigned if the target variable will be used in the model, otherwise, leave it as <code>-1</code>. The <code>pool</code> shall be allocated with whatever size required. <code>*pool</code> stores not only mandatory state variables, it can further store additional history variables manages by the model itself.</p>"},{"location":"Developer/C/material/#example","title":"Example","text":"<p>Here we present a simple uniaxial elastic material example. For the full code, please check the file <code>Developer/Material/ElasticExternal.cpp</code>.</p>"},{"location":"Developer/C/material/#the-handler","title":"The Handler","text":"<p>Although it is a C style interface, CPP syntax can be used. Each operation is wrapped in separate functions.</p> C++<pre><code>SUANPAN_EXPORT void elasticexternal_handler(ExternalMaterialData* data, int* info) {\nif(0 == *info) allocate_material(data, info);\nelse if(1 == *info) deallocate_material(data, info);\nelse if(2 == *info) static_update(data, info);\nelse if(3 == *info) dynamic_update(data, info);\nelse if(4 == *info) commit(data, info);\nelse if(5 == *info) reset(data, info);\nelse if(6 == *info) clear(data, info);\nelse if(7 == *info) validate(data, info);\nelse {\nsuanpan_error(\"unknown flag received.\\n\");\n*info = -1;\n}\n}\n</code></pre>"},{"location":"Developer/C/material/#allocation","title":"Allocation","text":"<p>Since it is a uni-axial elastic material, <code>size</code> should be one. Strain, stress and stiffness related variables are used, the rest can remain unused. We arrange the data in the following layout.</p> index value <code>pool[0]</code> current strain <code>pool[1]</code> trial strain <code>pool[2]</code> current stress <code>pool[3]</code> trial stress <code>pool[4]</code> initial stiffness <code>pool[5]</code> current stiffness <code>pool[6]</code> trial stiffness <p>No history variables are involved in this elastic material model. The <code>pool</code> can be allocated by <code>new double[7]</code> and filled with zeros. Then elastic modulus, which is assumed to be the first model parameter (<code>constant[0]</code>), is copied to stiffness.</p> <p>The density shall be handled as well. If there are more than one model parameter, the second is assumed to be density.</p> C++<pre><code>void allocate_material(ExternalMaterialData* data, int* info) {\ndata-&gt;size = 1;\ndata-&gt;c_strain = 0;\ndata-&gt;t_strain = 1;\ndata-&gt;c_stress = 2;\ndata-&gt;t_stress = 3;\ndata-&gt;i_stiffness = 4;\ndata-&gt;c_stiffness = 5;\ndata-&gt;t_stiffness = 6;\ndata-&gt;pool = new double[7];\nif(nullptr == data-&gt;pool) *info = -1;\nfor(auto I = 0; I &lt; 7; ++I) data-&gt;pool[I] = 0.;\ndata-&gt;pool[data-&gt;c_stiffness] = data-&gt;pool[data-&gt;t_stiffness] = data-&gt;pool[data-&gt;i_stiffness] = data-&gt;constant[0];\nif(data-&gt;constant_size &gt; 1) data-&gt;density = data-&gt;constant[1];\n}\n</code></pre> <p>With such a definition, the command used to define such a model is</p> Text Only<pre><code>material ElasticExternal (1) (2) [3]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# [3] double, density, default: 0.0\n</code></pre>"},{"location":"Developer/C/material/#deallocation","title":"Deallocation","text":"<p>The <code>pool</code> needs to be deallocated.</p> C++<pre><code>void deallocate_material(ExternalMaterialData* data, int* info) {\ndelete[] data-&gt;pool;\n*info = 0;\n}\n</code></pre>"},{"location":"Developer/C/material/#update-based-on-strain","title":"Update Based On Strain","text":"<p>No local iteration is required to update state, thus stress can always be computed by multiply strain with elastic modulus, which is</p> \\[ \\sigma^{n}=E~\\varepsilon^{n} \\] <p>For complex models, alias can be used to simplify code.</p> C++<pre><code>void static_update(ExternalMaterialData* data, int* info) {\ndata-&gt;pool[data-&gt;t_stress] = data-&gt;pool[data-&gt;t_stiffness] * data-&gt;pool[data-&gt;t_strain];\n*info = 0;\n}\n</code></pre>"},{"location":"Developer/C/material/#state-manipulation","title":"State Manipulation","text":"<p>It is straightforward.</p> C++<pre><code>void commit(ExternalMaterialData* data, int* info) {\ndata-&gt;pool[data-&gt;c_strain] = data-&gt;pool[data-&gt;t_strain];\ndata-&gt;pool[data-&gt;c_stress] = data-&gt;pool[data-&gt;t_stress];\n*info = 0;\n}\nvoid reset(ExternalMaterialData* data, int* info) {\ndata-&gt;pool[data-&gt;t_strain] = data-&gt;pool[data-&gt;c_strain];\ndata-&gt;pool[data-&gt;t_stress] = data-&gt;pool[data-&gt;c_stress];\n*info = 0;\n}\nvoid clear(ExternalMaterialData* data, int* info) {\ndata-&gt;pool[data-&gt;c_strain] = data-&gt;pool[data-&gt;t_strain] = 0.;\ndata-&gt;pool[data-&gt;c_stress] = data-&gt;pool[data-&gt;t_stress] = 0.;\n*info = 0;\n}\n</code></pre>"},{"location":"Developer/C/material/#validation","title":"Validation","text":"<p>For this model, there should be at least one model parameter.</p> C++<pre><code>void validate(ExternalMaterialData* data, int* info) {\n*info = 0 == data-&gt;constant_size ? -1 : 0;\n}\n</code></pre>"},{"location":"Developer/CPP/constraint/","title":"Constraint","text":"<p>In this article, the formulation and implementation of constraints, both single-point and multipoint types, are briefly discussed.</p>"},{"location":"Developer/CPP/constraint/#penalty-method","title":"Penalty Method","text":""},{"location":"Developer/CPP/constraint/#theory","title":"Theory","text":""},{"location":"Developer/CPP/constraint/#implementation","title":"Implementation","text":"<p>The easiest approach to implement the constraint with penalty method is to treat the constraint as a special element.</p>"},{"location":"Developer/CPP/constraint/#lagrange-multiplier-method","title":"Lagrange Multiplier Method","text":""},{"location":"Developer/CPP/constraint/#theory_1","title":"Theory","text":"<p>In the most general form, a minimisation problem of function \\(\\(f(x)\\)\\) subjected to equality constraint \\(\\(g(x)\\)\\) can be expressed as</p> \\[ \\text{minimise}~f(x)~\\text{subjected to}~g(x)=0. \\] <p>It can be converted to the Lagrangian function so that the target is to find the stationary points of</p> \\[ L(x,\\lambda)=f(x)+\\lambda^\\mathrm{T}g(x). \\] <p>Either linear or nonlinear constraints can be applied.</p> <p>For finite element analysis, \\(\\(f(x)\\)\\) is normally the strain energy \\(\\(W(u)\\)\\) so that</p> \\[ \\dfrac{\\partial{}W(u)}{\\partial{}u}=R(u), \\] <p>which would be resistance.</p> <p>Thus, the stationary condition leads to the following nonlinear system.</p> \\[ R(u)+\\lambda^\\mathrm{T}\\dfrac{\\mathrm{d}g}{\\mathrm{d}u}=0,\\qquad g=0. \\] <p>Linearisation gives the Jacobian to be</p> \\[ J=\\begin{bmatrix} K&amp;\\dfrac{\\mathrm{d}g}{\\mathrm{d}u}^\\mathrm{T}\\\\ \\dfrac{\\mathrm{d}g}{\\mathrm{d}u}&amp;0 \\end{bmatrix}+ \\begin{bmatrix} \\displaystyle\\sum_{i=1}^{n}\\lambda_i\\dfrac{\\mathrm{d}^2g_i}{\\mathrm{d}u^2}&amp;0\\\\0&amp;0 \\end{bmatrix}, \\] <p>where \\(\\(K\\)\\) is the tangent stiffness of the unconstrained system.</p>"},{"location":"Developer/CPP/constraint/#implementation_1","title":"Implementation","text":"<p>From the formulation, it is clear that the general implementation of Lagrange multiplier method requires two main parts, namely the Hessian matrix and the gradient of constraints \\(\\(g_i\\)\\).</p> <p>For the Hessian matrix, it can be treated as the corresponding stiffness matrix of the element that connects the nodes on which the constraint is applied. It can be computed locally and assembled into global stiffness matrix with other conventional elements.</p> <p>For the gradient, it is normally stored separately in the so-called border matrix. In a system with multiple constraints defined, the number of active constraints may differ from step to step, especially with the presence of inequality constraints. Thus, the border matrix, and the corresponding constraint residual (for nonlinear constraints), shall be stored locally and later be used to formulate the corresponding global variables in each iteration.</p> <p>To consider linear constraints only, the implementation can be greatly simplified. But its applicability would be confined.</p>"},{"location":"Developer/CPP/element/","title":"Element","text":""},{"location":"Developer/CPP/element/#abstraction","title":"Abstraction","text":"<p>The abstraction of the <code>Element</code> class is defined in <code>ElementBase</code> class. Readers can check that header to get an overall picture of all methods implemented.</p>"},{"location":"Developer/CPP/element/#variables-and-methods","title":"Variables and Methods","text":"<p>The <code>Element</code> class manages two states by default: current converged state and trial state. Accordingly, several build-in variables are defined, they are grouped in a struct. Some frequently used variables are listed as follows. A complete list can be found in the header of <code>Element</code> class.</p> C++<pre><code>struct ElementData {\nconst uvec node_encoding; // node encoding\nconst uvec material_tag;  // material tags\nconst uvec section_tag;   // section tags\nconst bool nlgeom = false; // nonlinear geometry switch\nbool update_mass = true;      // flag to indicate if update matrix\nbool update_damping = true;   // flag to indicate if update matrix\nbool update_stiffness = true; // flag to indicate if update matrix\nbool update_geometry = true;  // flag to indicate if update matrix\nuvec dof_encoding; // DoF encoding vector\nmat initial_mass;      // mass matrix\nmat initial_damping;   // damping matrix\nmat initial_stiffness; // stiffness matrix\nmat initial_geometry;  // geometry matrix\nmat trial_mass;      // mass matrix\nmat trial_damping;   // damping matrix\nmat trial_stiffness; // stiffness matrix\nmat trial_geometry;  // geometry matrix\nmat current_mass;      // mass matrix\nmat current_damping;   // damping matrix\nmat current_stiffness; // stiffness matrix\nmat current_geometry;  // geometry matrix\nvec trial_resistance;       // resistance vector\nvec current_resistance;     // resistance vector\nvec trial_damping_force;    // damping force\nvec current_damping_force;  // damping force\nvec trial_inertial_force;   // inertial force\nvec current_inertial_force; // inertial force\nvec trial_body_force;\nvec current_body_force;\nvec trial_traction;\nvec current_traction;\nmat body_force;\nmat traction;\n};\n</code></pre> <p>There are some build-in methods to get nodal information. The purposes are indicated by method names. These methods are implemented through the stored node pointers. The same functionalities can be reimplemented manually otherwise those predefined methods are sufficient in most cases.</p> C++<pre><code>mat get_coordinate(unsigned) const;\nvec get_incre_displacement() const;\nvec get_incre_velocity() const;\nvec get_incre_acceleration() const;\nvec get_trial_displacement() const;\nvec get_trial_velocity() const;\nvec get_trial_acceleration() const;\nvec get_current_displacement() const;\nvec get_current_velocity() const;\nvec get_current_acceleration() const;\nvec get_node_incre_resistance() const;\nvec get_node_trial_resistance() const;\nvec get_node_current_resistance() const;\nvector&lt;shared_ptr&lt;Material&gt;&gt; get_material(const shared_ptr&lt;DomainBase&gt;&amp;) const;\nvector&lt;shared_ptr&lt;Section&gt;&gt; get_section(const shared_ptr&lt;DomainBase&gt;&amp;) const;\n</code></pre>"},{"location":"Developer/CPP/element/#constructor","title":"Constructor","text":"<p>The most common constructor looks like this.</p> C++<pre><code> Element(unsigned,    // tag\nunsigned,    // number of nodes\nunsigned,    // number of dofs\nuvec&amp;&amp;,      // node encoding\nuvec&amp;&amp;,      // material tags\nbool,        // nonlinear geometry switch\nMaterialType // material type for internal check\n);\n</code></pre> <p>Some elements are based on sections while some elements are based on integration points that are directly tied to material models. The above is the constructor used for material based elements. The number of nodes and the number of DoFs per node shall be passed to <code>Element</code> class so that the connected nodes can be correctly initialized, as well as all related matrices. Either material tags or section tags shall be passed to define the element. During initialization, if no proper material/section tag is provided, the target element will be disabled. Also, the associated material/section model will be checked if the dimension matches. The nonlinear geometry switch allows the nonlinear version to be implemented in the same class.</p> <p>There are some other constructors. The following one can be used to define elements that depend on node groups (a number of nodes organized in groups).</p> C++<pre><code> Element(unsigned, // tag\nunsigned, // number of dofs\nuvec&amp;&amp;    // group encoding\n);\n</code></pre> <p>And the following one defines elements that require information of other elements.</p> C++<pre><code> Element(unsigned, // tag\nunsigned, // number of dofs\nunsigned, // other element tag\nunsigned  // node tag\n);\n</code></pre> <p>The initialization is able to handle these different types of elements.</p>"},{"location":"Developer/CPP/element/#initialization","title":"Initialization","text":"<p>Any derived element class shall implement the initializer.</p> C++<pre><code>virtual void initialize(const shared_ptr&lt;DomainBase&gt;&amp;) = 0;\n</code></pre> <p>This method takes a <code>DomainBase</code> pointer that allows the target element to acquire material/section objects and/or other necessary information to initialize the element. A better illustration can be seen in an example element implementation. For the moment, we only need to know this must be overridden.</p> <p>The <code>Element</code> class itself provides an initializer to initialise common variables.</p> C++<pre><code>void initialize_base(const shared_ptr&lt;DomainBase&gt;&amp;) override final;\n</code></pre> <p>A number of tasks are performed in the default initialization.</p> <ol> <li>Check if all involved nodes are active, if not, the element will be disabled.</li> <li>Check the current number of DoFs of each involved node, if it is smaller than that required by the current element,    then reset it.</li> <li>Check if there is a valid and active material/section model based on the corresponding tag provided in the    constructor, if not, the element will be disabled.</li> <li>On the second run, check again if all nodes are active, if not, the element will be disabled.</li> </ol>"},{"location":"Developer/CPP/element/#general-procedure","title":"General Procedure","text":"<p>The main task of an element is to provide force response based on the trial nodal displacements. In the meantime, the corresponding matrices such as tangent stiffness, or tangent modulus in 1D case, shall be provided.</p> <p>The only entrance to update an element is the method <code>update_status()</code>. All trial state associated variables shall be updated in this method. Then several getters are available to return the corresponding variables. This is the default strategy adopted by all existing elements. However, there are other options. For some solvers, the number of calls to get, for example, trial resistance would be multiples of that to get tangent stiffness. For some algorithms, tangent stiffness matrix will only be assembled in the first iteration of each sub-step. In this case, it would be unnecessary to update trial stiffness in each call of <code>update_status()</code>, rather, it can be implemented in the getter <code>get_trial_stiffness()</code> to minimize the computational cost. This is not chosen by default to simplify the development. Please check the following section for details.</p>"},{"location":"Developer/CPP/element/#two-paths","title":"Two Paths","text":""},{"location":"Developer/CPP/element/#if-you-decide-to-use-predefined-variables","title":"If You Decide To Use Predefined Variables","text":"<p>The predefined variables are sufficient to manage element state in most cases. If so, only four methods shall be implemented.</p> C++<pre><code>virtual int update_status() = 0; // update trial\nvirtual int clear_status() = 0;  // clear both trial and current\nvirtual int commit_status() = 0; // commit trial to current\nvirtual int reset_status() = 0;  // reset trial to current\n</code></pre> <p>The latter three manage states. Normally it is necessary to call the corresponding methods in all related material/section models if the implemented element itself does not store history variables. As the name suggests, we need to update the trial state in the first method. A general procedure would be:</p> <ol> <li>obtain nodal displacement/velocity vector by calling for example <code>get_trial_displacement()</code>,</li> <li>compute strain at each integration point,</li> <li>update material models using new trial strains,</li> <li>get material response and form element resistance and stiffness matrix. If necessary, mass/damping matrix shall be    updated according to the new trial state.</li> </ol>"},{"location":"Developer/CPP/element/#if-you-decide-to-manage-states-in-your-way","title":"If You Decide To Manage States In Your Way","text":"<p>In this case, probably all build-in variables won't be used. To manage states, following additional methods shall be overridden.</p> C++<pre><code>virtual const vec&amp; get_trial_resistance() const;\nvirtual const vec&amp; get_current_resistance() const;\nvirtual const mat&amp; get_trial_mass() const;\nvirtual const mat&amp; get_trial_damping() const;\nvirtual const mat&amp; get_trial_stiffness() const;\nvirtual const mat&amp; get_trial_geometry() const;\nvirtual const mat&amp; get_trial_secant() const;\nvirtual const mat&amp; get_current_mass() const;\nvirtual const mat&amp; get_current_damping() const;\nvirtual const mat&amp; get_current_stiffness() const;\nvirtual const mat&amp; get_current_geometry() const;\nvirtual const mat&amp; get_current_secant() const;\nvirtual const mat&amp; get_initial_mass() const;\nvirtual const mat&amp; get_initial_damping() const;\nvirtual const mat&amp; get_initial_stiffness() const;\nvirtual const mat&amp; get_initial_geometry() const;\nvirtual const mat&amp; get_initial_secant() const;\n</code></pre> <p>As a general guideline, here are some conventions to follow:</p> <ol> <li>It is not recommended using the second approach, that is, managing internal variables at derived class level, unless    all methods are carefully implemented.</li> <li>All state updates, including all history variables, shall only happen in the <code>update_status()</code> method, as all get    methods are declared as <code>const</code>.</li> <li>It is sometimes useful to update trial strain related variables only in <code>update_status()</code> and compute responses in    the corresponding getters. In that case, a <code>const_cast</code> is required. By doing so, developers must clearly know what    the operation means. A typical example would be, for example, the modified Newton algorithm or    the <code>BFGS</code> method, in which <code>update_status()</code> will only be called once and getters of    resistances and matrices would be called several times for each iteration in each sub-step. Splitting updater and    getters apart will for sure save some computation efforts but is also error-prone.</li> <li>Normally the damping matrix and the mass matrix shall only be defined as functions of current state at most --- if    they are not constants. Essentially, they cannot be functions of trial strain/displacement if a quadratic convergence    rate shall be preserved.</li> <li>If the stiffness matrix is constant throughout the analysis, it is recommended to use    function <code>ConstantStiffness(ElementData*)</code> to declare such a feature in order to save some memory.</li> <li>If the damping matrix is constant throughout the analysis, it is recommended to use    function <code>ConstantDamping(ElementData*)</code> to declare such a feature in order to save some memory.</li> <li>If the mass matrix is constant throughout the analysis, it is recommended to use    function <code>ConstantMass(ElementData*)</code> to declare such a feature in order to save some memory.</li> </ol>"},{"location":"Developer/CPP/element/#record-response","title":"Record Response","text":"<p>To record response, simply override</p> C++<pre><code>virtual vector&lt;vec&gt; record(OutputType);\n</code></pre> <p>A number of physical variables can be identified and output accordingly in this method. Except for some special elements that stores element-wise variables, most elements would directly forward call <code>record(OutputType)</code> in the associated material objects following the order of integration points and generate and return a <code>vector&lt;vec&gt;</code>.</p>"},{"location":"Developer/CPP/element/#remarks","title":"Remarks","text":"<p>In general, implementing a new element class is not a difficult task. Basically, there are two things to do: 1) initialize the element correctly and 2) update element status using nodal information in a correct, iterative way. The remaining is automatically handled by the base class.</p> <p>For different dimensions, here are some very simple elements implemented for reference.</p> <ol> <li>1D --- <code>Spring01</code> a spring element based on infinitesimal displacement.</li> <li>2D --- <code>ElementExample</code> a three-node triangle plain membrane element.</li> <li>3D --- <code>C3D4</code> a four-node tetragon using one-node integration.</li> </ol>"},{"location":"Developer/CPP/material/","title":"Material","text":""},{"location":"Developer/CPP/material/#things-to-know","title":"Things to Know","text":"<ol> <li>There is no need to write wrappers. Various wrappers are available to wrap 3D material models for 1D and 2D    applications.</li> <li>Unless the 2D material model is formulated directly in the 2D space, for example the plane stress space (such as the    Barlat-Lian model), developers are not encouraged to write any 2D versions of 3D models.</li> </ol>"},{"location":"Developer/CPP/material/#main-tasks-of-a-material-model","title":"Main Tasks of a Material Model","text":"<p>The material model is often associated with the integration point to compute the material response. As a general purposed computation framework, in general, most material models are not tied to any specific element types.</p> <p>The main task of a material model is to compute the response based on the input(s). The input may be displacement, strain, velocity, strain rate, etc. The corresponding response could be force, stress and stiffness.</p> <p>Hence, the associated element would call the material model to pass, for example, the trial strain to update the trial state. The material model shall compute the response of the trial state based on current state and stored history variables.</p>"},{"location":"Developer/CPP/material/#abstraction","title":"Abstraction","text":"<p>The abstraction of the <code>Material</code>class is given in the <code>MaterialBase</code> class.</p>"},{"location":"Developer/CPP/material/#data-storage","title":"Data Storage","text":"<p>All data is stored in a <code>struct</code> named as <code>MaterialData</code>.</p> C++<pre><code>struct MaterialData {\nconst double tolerance = 1E-14;\nconst double density = 0.; // density\nconst MaterialType material_type = MaterialType::D0;\nvec current_strain;      // current status\nvec current_strain_rate; // current status\nvec current_stress;      // current status\nvec current_stress_rate; // current status\nvec trial_strain;      // trial status\nvec trial_strain_rate; // trial status\nvec trial_stress;      // trial status\nvec trial_stress_rate; // trial status\nvec incre_strain;      // incremental status\nvec incre_strain_rate; // incremental status\nvec incre_stress;      // incremental status\nvec incre_stress_rate; // incremental status\nvec initial_history; // initial status\nvec current_history; // current status\nvec trial_history;   // trial status\nmat initial_stiffness; // stiffness matrix\nmat current_stiffness; // stiffness matrix\nmat trial_stiffness;   // stiffness matrix\nmat initial_damping; // damping matrix\nmat current_damping; // damping matrix\nmat trial_damping;   // damping matrix\n};\n</code></pre> <p>Two states are stored. The current state is the converged state while the trial state should be updated for each iteration. The difference between two states is also stored, given that some material models is formulated based on an incremental form.</p> <p>The variable <code>initial_history</code> can be used to assign initial conditions. A detailed layout shall be provided in the corresponding manual page.</p> <p>It is not compulsory to use pre-defined variables. It is possible to use user-defined variables to manage states. However, several methods shall be overridden, which makes codes longer.</p> <p>To save memory, it is recommended to reset pre-defined variables during the initialization if user-defined variables are used. Details will be covered in the discussion of the corresponding methods.</p>"},{"location":"Developer/CPP/material/#pure-virtual-methods","title":"Pure Virtual Methods","text":"<p>Some methods are labelled as pure virtual methods, meaning that they need to be overridden in the derived classes.</p> C++<pre><code> virtual void initialize(const shared_ptr&lt;DomainBase&gt;&amp; = nullptr) = 0; // for initialization of the model\nvirtual unique_ptr&lt;Material&gt; get_copy() = 0; // to get a deep copy for local usage\nvirtual int clear_status() = 0; // state control\nvirtual int commit_status() = 0; // state control\nvirtual int reset_status() = 0; // state control\n</code></pre> <p>Apart from those five methods, the updater shall be overridden as well. Two methods are defined. The first one accepts trial strain as input. This method has no default behaviour, so it needs to be implemented in all derived classes otherwise it throws an exception.</p> C++<pre><code> virtual int update_trial_status(const vec&amp;);\n</code></pre> <p>The second one accepts trial strain and trial strain rate as inputs. By default, this method calls the above method with trial strain. If the material model is rate independent, this method can be left unchanged.</p> C++<pre><code> virtual int update_trial_status(const vec&amp;, const vec&amp;);\n</code></pre> <p>Some element models may call the material model with increments. The according methods are defined as well.</p> C++<pre><code> virtual int update_incre_status(const vec&amp;);\nvirtual int update_incre_status(const vec&amp;, const vec&amp;);\n</code></pre> <p>By default, these two methods compute the trial state by adding increments to the current state and call the corresponding <code>update_trial_status()</code> method.</p> <p>For 1D material models, often the trial strain (rate) is directly stored in a scalar. So the scalar versions of the above four methods are defined.</p> C++<pre><code> int update_incre_status(double);\nint update_incre_status(double, double);\nint update_trial_status(double);\nint update_trial_status(double, double);\n</code></pre> <p>By default, these methods wrap the input scalars into <code>vec</code> variables and call the corresponding vector versions of these methods. If there is no special considerations, these four methods do not need to be overridden.</p>"},{"location":"Developer/CPP/material/#material-in-details","title":"Material In Details","text":""},{"location":"Developer/CPP/material/#initialization","title":"Initialization","text":"<p>The initialization procedure is performed before the analysis. The main task is to formulate for example the initial stiffness, initialize the corresponding history variables (if any), etc. The pointer of the domain that the current material model is defined in is sent to the initialization method in case of any other resources are required by the current material model.</p> <p>As the material model is the bottom layer of FEA, most models are independent of other components of the problem domain.</p> <p>The following is an example from the <code>NonlinearJ2</code> class.</p> C++<pre><code>void NonlinearJ2::initialize(const shared_ptr&lt;DomainBase&gt;&amp;) {\ntrial_stiffness = current_stiffness = initial_stiffness = tensor::isotropic_stiffness(elastic_modulus, poissons_ratio);\ninitialize_history(7);\n}\n</code></pre> <p>In this method, the initial/current/trial stiffness matrix is set to the isotropic elastic matrix by calling the function <code>tensor::isotropic_stiffness</code> with elastic modulus and Poisson's ratio.</p> <p>Then the history variables are initialized. A scalar (accumulated plastic strain) and a six-component vector (back stress) are required so the total size of history variables is 7.</p> <p>It shall be noted that, if the model is designed to support nonzero initial history, viz., initial conditions, history variables cannot be initialized by directly call the <code>zeros()</code> method. The method <code>initialize_history()</code> shall be called instead. This method checks if the initial history is set. If yes, the initial condition will be retained.</p> <p>By default, strain, stress and stiffness will be initialized in the base class implementation of <code>initialize()</code>. If any of those variables are not used, it is possible to reset them to save memory in the derived implementation of <code>initialize()</code>.</p>"},{"location":"Developer/CPP/material/#copier","title":"Copier","text":"<p>By implementing the copy constructor (if necessary), the copier can be written in one line. Each integration point needs a material object for local use.</p> C++<pre><code>unique_ptr&lt;Material&gt; DerivedClassName::get_copy() { return make_unique&lt;DerivedClassName&gt;(*this); }\n</code></pre>"},{"location":"Developer/CPP/material/#state-control","title":"State Control","text":"<p>Although when the built-in variables are used, the state control methods can be implemented in a universal approach. For example,</p> C++<pre><code>int Material::clear_status() {\nif(!current_strain.is_empty()) current_strain.zeros();\nif(!current_strain_rate.is_empty()) current_strain_rate.zeros();\nif(!current_stress.is_empty()) current_stress.zeros();\nif(!trial_strain.is_empty()) trial_strain.zeros();\nif(!trial_strain_rate.is_empty()) trial_strain_rate.zeros();\nif(!trial_stress.is_empty()) trial_stress.zeros();\nif(initial_history.is_empty()) {\nif(!current_history.is_empty()) current_history.zeros();\nif(!trial_history.is_empty()) trial_history.zeros();\n} else trial_history = current_history = initial_history;\nif(!initial_stiffness.is_empty()) trial_stiffness = current_stiffness = initial_stiffness;\nreturn SUANPAN_SUCCESS;\n}\nint Material::commit_status() {\nif(!trial_strain.is_empty()) current_strain = trial_strain;\nif(!trial_strain_rate.is_empty()) current_strain_rate = trial_strain_rate;\nif(!trial_stress.is_empty()) current_stress = trial_stress;\nif(!trial_history.is_empty()) current_history = trial_history;\nif(!trial_stiffness.is_empty()) current_stiffness = trial_stiffness;\nreturn SUANPAN_SUCCESS;\n}\nint Material::reset_status() {\nif(!trial_strain.is_empty()) trial_strain = current_strain;\nif(!trial_strain_rate.is_empty()) trial_strain_rate = current_strain_rate;\nif(!trial_stress.is_empty()) trial_stress = current_stress;\nif(!trial_history.is_empty()) trial_history = current_history;\nif(!trial_stiffness.is_empty()) trial_stiffness = current_stiffness;\nreturn SUANPAN_SUCCESS;\n}\n</code></pre> <p>Developers can still choose to manage state variables by them own. Similar to elements, all state updates, including all history variables, shall only happen in the <code>update_trial_status()</code> method to keep a simple and clean structure.</p>"},{"location":"Example/Developer/element-template/","title":"Element Template","text":"<p>Here we show the build-in element template. Comments explain the template a bit. A detailed guideline could be seen elsewhere.</p> C++<pre><code>/**\n * @class ElementTemplate\n * @brief The ElementTemplate class illustrates the basic formulation a typical\n * Element class used in FEM analysis.\n *\n * @author tlc\n * @date 05/01/2020\n * @version 0.1.3\n * @file ElementTemplate.h\n * @addtogroup Element\n * @{\n */\n#ifndef ELEMENTTEMPLATE_H\n#define ELEMENTTEMPLATE_H\n#include \"MaterialElement.h\"\nclass ElementTemplate final : public MaterialElement2D {\n// As a universal practice, we define two static constants to\n// represent the number of nodes and the number of DoFs.\n// This is not necessary but only for clearness.\nstatic constexpr unsigned m_node = 3, m_dof = 2;\ndouble thickness = 0.; /**&lt; thickness */\ndouble area = 0.;      /**&lt; area */\nmat strain_mat;\nunique_ptr&lt;Material&gt; m_material; /**&lt; store material model */\npublic:\nElementTemplate(unsigned, uvec&amp;&amp;, unsigned, double = 1.);\nvoid initialize(const shared_ptr&lt;DomainBase&gt;&amp;) override;\nint update_status() override;\nint commit_status() override;\nint clear_status() override;\nint reset_status() override;\n};\n#endif\n</code></pre> C++<pre><code>#include \"ElementTemplate.h\"\n#include &lt;Domain/DomainBase.h&gt;\n#include &lt;Domain/Node.h&gt;\n#include &lt;Material/Material2D/Material2D.h&gt;\n/**\n * @brief\n * Here we target our ElementTemplate class to fulfil the functionality of a\n * constant stress triangular element, viz., CPS3, in ABAQUS notation.\n *\n * The example element is derived from the `MaterialElement2D` class, hence it\n * is a 2D element using material models (instead of sections).\n *\n * The constructor of `MaterialElement2D` class asks for six parameters:\n * - Unique Element Object Tag (T)\n * - Number of Nodes (NN)\n * - Number of DoFs (ND)\n * - Node Encoding Tags (NT)\n * - Material Tag (MT)\n * - Nonlinear Switch (F)\n *\n * In our example, CT and F will be constants, NN is 3 and ND is 2. So we have\n * three parameters plus thickness for our derived element. Except for\n * initializing private member variables, we do not have to do anything. All\n * other initializations will be handled by the Element and Domain class. As\n * simple as this.\n */\nElementTemplate::ElementTemplate(const unsigned T, uvec&amp;&amp; NT, const unsigned MT, const double TH)\n: MaterialElement2D(T, m_node, m_dof, std::forward&lt;uvec&gt;(NT), uvec{MT}, false)\n, thickness(TH) {}\n/**\n * @brief\n * As explained before, this method get all necessary information, which\n * includes getting copies of Material objects and other operations, from the\n * Domain object.\n *\n * Please note that **we do not have to check the existence of any objects**\n * which are used in the element. The validity of the connected node objects and\n * the material models is checked in the base initialisation before calling\n * this method. The execution of this `initialize()` method automatically\n * implies that this is a valid Element object with valid material model.\n *\n * The displacement mode is\n * \\f{gather}{\\phi=\\begin{bmatrix}1&amp;x&amp;y\\end{bmatrix}.\\f}\n *\n * The strain matrix is calculated as\n * \\f{gather}{B=\\partial{}N=\\partial{}\\left(\\phi{}C^{-1}\\right),\\f}\n * where\n * \\f{gather}{C=\\begin{bmatrix}1&amp;x_i&amp;y_i\\\\1&amp;x_j&amp;y_j\\\\1&amp;x_k&amp;y_k\\end{bmatrix}.\\f}\n *\n * One can also initialize stiffness matrix and/or other build-in matrices from\n * Element class (check the definition for details) in the `initialize()` method.\n * However, this it not necessary, as the Solver will always call\n * update_status() method with a zero trial displacement to update current\n * stiffness and resistance before running iterations.\n */\nvoid ElementTemplate::initialize(const shared_ptr&lt;DomainBase&gt;&amp; D) {\n//! As CPS3 is a constant stress/strain element, one integration point at the\n//! center of the element is enough. Hence we only have one material model\n//! defined. First we get a reference of the Material object from the Domain\n//! and then call the `get_copy()` method to get a local copy. Direct\n//! assignment is allowed, the move semantics will automatically be invoked.\n//! There is no need to check if the material model is a 2D one. The validation\n//! is done in base Element class initialisation.\nm_material = D-&gt;get&lt;Material&gt;(material_tag(0))-&gt;get_copy();\n//! The node pointers are handled in the base Element class, we do not have to\n//! set it manually. Now we could fill in the `ele_coor` matrix. The\n//! area/natural coordinate is another version of implementation. Please refer\n//! to FEM textbooks for theories. This will be used for the computation of\n//! the shape function.\nmat ele_coor(m_node, m_node, fill::ones);\nfor(unsigned i = 0; i &lt; m_node; ++i) {\nauto&amp; tmp_coor = node_ptr[i].lock()-&gt;get_coordinate();\nfor(unsigned j = 0; j &lt; m_dof; ++j) ele_coor(i, j + 1llu) = tmp_coor(j);\n}\n//! The area is half of the determinant of the above matrix.\n//! The area of 2D polygons can also be computed by the `shoelace` function.\narea = .5 * det(ele_coor);\nconst mat inv_coor = inv(ele_coor);\n//! A standard way to construct the strain mat is to derive from the partial\n//! derivative of the shape function N. For CP3, as it is a constant\n//! stress/strain element, the derivatives are constants which can be directly\n//! obtained from above matrix.\nstrain_mat.zeros(3, m_node * m_dof);\nfor(unsigned i = 0, j = 0, k = 1; i &lt; 3; ++i, j += m_dof, k += m_dof) {\nstrain_mat(2, k) = strain_mat(0, j) = inv_coor(1, i);\nstrain_mat(2, j) = strain_mat(1, k) = inv_coor(2, i);\n}\ntrial_stiffness = current_stiffness = initial_stiffness = strain_mat.t() * m_material-&gt;get_initial_stiffness() * strain_mat * area * thickness;\nif(const auto t_density = area * thickness * m_material-&gt;get_parameter(); t_density &gt; 0.) {\ninitial_mass.zeros(m_size, m_size);\nconst rowvec n = mean(ele_coor) * inv_coor;\nconst mat t_mass = n.t() * n * t_density * area * thickness;\ninitial_mass(uvec{1, 3, 5}, uvec{1, 3, 5}) = t_mass;\ninitial_mass(uvec{0, 2, 4}, uvec{0, 2, 4}) = t_mass;\n}\n//! We use function `ConstantMass()` to indicate the mass matrix will not change\n//! so that `trial_mass`, `current_mass` and `initial_mass` matrices can point to\n//! the same memory location. This avoids unnecessary allocation of memory.\n//! It is not compulsory to call `ConstantMass()`, `ConstantStiffness()` and\n//! `ConstantDamping()` but highly recommended to do so when one or some matrices\n//! indeed remain unchanged for the whole analysis.\nConstantMass(this);\n}\n/**\n * @brief Now we handle the status update method. We get trial displacement via\n * build-in method and pass trial strain to the material model. Then get updated\n * stiffness and stress back to form element stiffness and resistance.\n *\n * For a static analysis, **stiffness** and **resistance** have to be\n * formulated. Apart from this, there is nothing you have to do. They will be\n * send to global assembler by methods in base Element class, which can also be\n * overridden to be customized.\n */\nint ElementTemplate::update_status() {\nm_material-&gt;update_trial_status(strain_mat * get_trial_displacement());\ntrial_stiffness = area * thickness * strain_mat.t() * m_material-&gt;get_trial_stiffness() * strain_mat;\ntrial_resistance = area * thickness * strain_mat.t() * m_material-&gt;get_trial_stress();\nreturn 0;\n}\n/**\n * \\brief Simply call corresponding methods in material objects. If the element\n * itself has history variables, they should also be updated/modified in\n * following methods.\n */\nint ElementTemplate::commit_status() { return m_material-&gt;commit_status(); }\nint ElementTemplate::clear_status() { return m_material-&gt;clear_status(); }\nint ElementTemplate::reset_status() { return m_material-&gt;reset_status(); }\n</code></pre>"},{"location":"Example/Developer/material-template/","title":"Material Template","text":"<p>Here we show the build-in material template.</p> C++<pre><code>/**\n * @class MaterialExample\n * @brief A MaterialExample material class.\n * @author tlc\n * @date 06/07/2018\n * @version 0.2.0\n * @file MaterialExample.h\n * @addtogroup Material-1D\n * @ingroup Material\n * @{\n */\n#ifndef MATERIALEXAMPLE_H\n#define MATERIALEXAMPLE_H\n#include &lt;Material/Material.h&gt;\n/**\n * \\brief It is recommended to store data, especially constant data, in a simple\n * structure. The motivation is to obtain a clear interface so that store and recover\n * of objects will be easier.\n */\nstruct MaterialExampleData {\nconst double elastic_modulus; // elastic modulus\nconst double yield_stress;    // initial yield stress\nconst double hardening_ratio; // hardening ratio\nconst double beta;            // isotropic/kinematic hardening factor\nconst double plastic_modulus; // plastic modulus\n};\nclass MaterialExample final : MaterialExampleData, public Material {\ndouble current_back_stress = 0.;\ndouble current_plastic_strain = 0.;\ndouble trial_back_stress = 0.;\ndouble trial_plastic_strain = 0.;\npublic:\nexplicit MaterialExample(unsigned = 0,  // tag\ndouble = 2E5,  // elastic modulus\ndouble = 400., // initial yield stress\ndouble = .05,  // hardening ratio\ndouble = 0.,   // isotropic/kinematic hardening factor\ndouble = 0.    // density\n);\nvoid initialize(const shared_ptr&lt;DomainBase&gt;&amp;) override;\nunique_ptr&lt;Material&gt; get_copy() override;\nint update_trial_status(const vec&amp;) override;\nint clear_status() override;\nint commit_status() override;\nint reset_status() override;\nvoid print() override;\n};\n#endif\n</code></pre> C++<pre><code>#include \"MaterialExample.h\"\n/**\n * \\brief The constructor of material model depends on the specific model to be\n * implemented. But for the base `Material` class, it takes only three input arguments:\n *\n * - Unique Material Tag\n * - Material Type\n * - Density\n *\n * Here we are implementing a uniaxial bilinear hardening model, hence `MaterialType::D1`\n * is passed to the base. The material type will be used to validate with associated\n * elements/sections to ensure the consistency of the sizes of data passed between objects.\n * \n * \\param T Unique Material Tag\n * \\param E Elastic Modulus\n * \\param Y Yield Stress\n * \\param H Hardening Ratio\n * \\param B Beta\n * \\param R Density\n */\nMaterialExample::MaterialExample(const unsigned T, const double E, const double Y, const double H, const double B, const double R)\n: MaterialExampleData{E, Y, H, B, E * H / (1. - H)}\n, Material(T, MaterialType::D1, R) {}\n/**\n * \\brief Unless the target material model involves other material models to compute\n * responses, in general, it is not necessary to get additional information from\n * other parts of the model.\n *\n * In general cases, history variables shall be initialised and initial stiffness\n * (and initial damping if appropriate) shall be set to proper value.\n *\n * To enable initial values for history variables, build-in `trial_history` and\n * `current_history` shall be used, developers can initialise them via method\n * `initialise_history()` so that initial values set by `initial` command will not be\n * overwritten.\n *\n * In this example, instead of using build-in history variables, we manage history\n * variables, namely back stress and plastic strain, by ourselves.\n * \n */\nvoid MaterialExample::initialize(const shared_ptr&lt;DomainBase&gt;&amp;) {\ncurrent_back_stress = trial_back_stress = 0.;\ncurrent_plastic_strain = trial_plastic_strain = 0.;\ntrial_stiffness = current_stiffness = initial_stiffness = elastic_modulus;\n}\n/**\n * \\brief The `get_copy()` method should always be implemented with `make_unique`.\n * In case the model defines other memory management, developers may need to further\n * provide a copy ctor to make `make_unique` work.\n * \n * **!!!NEVER DO A MANUAL COPY OF DATA IN THIS METHOD!!!**\n * \n * \\return a copy of material model\n */\nunique_ptr&lt;Material&gt; MaterialExample::get_copy() { return make_unique&lt;MaterialExample&gt;(*this); }\n/**\n * \\brief There are two states we are managing at any time point.\n * The current state is the converged state from the last time substep. Since it is\n * converged, all data shall be valid and accurate.\n * The trial state stores the response computed based on converged state and new trial\n * strain. It may be discarded, committed or overwritten with new trial values.\n *\n * **WE ALWAYS COMPUTE TRIAL STATE BASED ON CURRENT STATE AND NEW TRIAL STRAIN**\n * **NEVER COMPUTE RESPONSE BASED ON ANY INFORMATION FROM UNCONVERGED STATE**\n *\n * Developers who are not familiar with classic plasticity theory may consult textbooks\n * for details.\n * \n * \\param t_strain trial strain\n * \\return error flag\n */\nint MaterialExample::update_trial_status(const vec&amp; t_strain) {\ntrial_strain = t_strain;\nincre_strain = trial_strain - current_strain;\nif(fabs(incre_strain(0)) &lt;= tolerance) return 0;\ntrial_back_stress = current_back_stress;\ntrial_plastic_strain = current_plastic_strain;\ntrial_stiffness = initial_stiffness;\ntrial_stress = current_stress + elastic_modulus * incre_strain;\nconst auto shifted_stress = trial_stress(0) - current_back_stress;\nconst auto yield_func = fabs(shifted_stress) - yield_stress - (1. - beta) * plastic_modulus * current_plastic_strain;\nif(yield_func &gt; 0.) {\nconst auto incre_plastic_strain = yield_func / (elastic_modulus + plastic_modulus);\ntrial_stress -= suanpan::sign(shifted_stress) * elastic_modulus * incre_plastic_strain;\ntrial_stiffness *= hardening_ratio;\ntrial_back_stress += suanpan::sign(shifted_stress) * beta * plastic_modulus * incre_plastic_strain;\ntrial_plastic_strain += incre_plastic_strain;\n}\nreturn 0;\n}\n/**\n * \\brief Operations are required to achieve the following objective.\n *\n * current state -&gt; 0\n * trial state -&gt; 0\n * \n * \\return error flag\n */\nint MaterialExample::clear_status() {\ncurrent_strain.zeros();\ncurrent_stress.zeros();\ncurrent_stiffness = initial_stiffness;\ncurrent_back_stress = 0.;\ncurrent_plastic_strain = 0.;\nreturn reset_status();\n}\n/**\n * \\brief Operations are required to achieve the following objective.\n *\n * current state &lt;- trial state\n * \n * \\return error flag\n */\nint MaterialExample::commit_status() {\ncurrent_strain = trial_strain;\ncurrent_stress = trial_stress;\ncurrent_stiffness = trial_stiffness;\ncurrent_back_stress = trial_back_stress;\ncurrent_plastic_strain = trial_plastic_strain;\nreturn 0;\n}\n/**\n * \\brief Operations are required to achieve the following objective.\n *\n * current state -&gt; trial state\n * \n * \\return error flag\n */\nint MaterialExample::reset_status() {\ntrial_strain = current_strain;\ntrial_stress = current_stress;\ntrial_stiffness = current_stiffness;\ntrial_back_stress = current_back_stress;\ntrial_plastic_strain = current_plastic_strain;\nreturn 0;\n}\nvoid MaterialExample::print() {\nsuanpan_info(\"A material example based on uniaxial J2 bilinear mixed hardening model.\\n\");\nsuanpan_info(\"current strain: %.5E\\tcurrent stress: %.5E.\\n\", current_strain.at(0), current_stress.at(0));\n}\n</code></pre>"},{"location":"Example/Geotechnical/triaxial-compression-of-sand/","title":"Triaxial Compression of Sand Using SimpleSand","text":"<p>In this example, we demonstrate the usage of <code>SimpleSand</code> model by conducting a triaxial compression simulation.</p> <p>The model scripts can be downloaded.</p>"},{"location":"Example/Geotechnical/triaxial-compression-of-sand/#the-model","title":"The Model","text":"<p>A unit cube defined with <code>C3D8</code> element is used to represent the specimen.</p> Text Only<pre><code>node 1 .5 -.5 0\nnode 2 .5 .5 0\nnode 3 -.5 .5 0\nnode 4 -.5 -.5 0\nnode 5 .5 -.5 1\nnode 6 .5 .5 1\nnode 7 -.5 .5 1\nnode 8 -.5 -.5 1\n\nelement C3D8 1 1 2 3 4 5 6 7 8 1 G\n</code></pre> <p>For the material properties, the following values are used.</p> Text Only<pre><code>material SimpleSand 1 9E4 .2 .01 -.7 5. 1.25 1.1 3.5 1.6 -130. .02 2.\n</code></pre> <p>Please refer to the corresponding page for explanations.</p>"},{"location":"Example/Geotechnical/triaxial-compression-of-sand/#loading","title":"Loading","text":"<p>The confinement is applied to achieve a confinement stress of \\(\\(\\sigma=3000~\\mathrm{kPa}\\)\\).</p> <p>In this case, a displacement of \\(\\(-0.01\\)\\) would do the job.</p> Text Only<pre><code>displacement 1 0 -0.02 1 1 2 5 6\ndisplacement 2 0 -0.02 2 2 3 6 7\n</code></pre> <p>The vertical displacement is applied in the same way.</p>"},{"location":"Example/Geotechnical/triaxial-compression-of-sand/#monotonic","title":"Monotonic","text":"Text Only<pre><code>amplitude Tabular 1 monotonic\n\ndisplacement 3 1 -0.02 3 5 6 7 8\n</code></pre>"},{"location":"Example/Geotechnical/triaxial-compression-of-sand/#cyclic","title":"Cyclic","text":"<p>Cyclic displacement load can be applied. It varies cyclicly after the target confinement is achieved.</p> Text Only<pre><code>amplitude Tabular 1 cyclic\n\ndisplacement 3 1 -0.02 3 5 6 7 8\n</code></pre> <p>The load level can be plotted as follows.</p> <p></p>"},{"location":"Example/Geotechnical/triaxial-compression-of-sand/#result","title":"Result","text":"<p>The \\(\\(p\\)\\)-\\(\\(q\\)\\) response is shown as follows. As a linear relationship is assumed for elastic part, linear line segments are expected within the yield surface.</p> <p>The <code>SimpleSand</code> model is a very simple model for sand to showcase the concept of bounding surface.</p> <p></p> <p></p> <p>For more advanced response, other models shall be used.</p>"},{"location":"Example/Miscellaneous/batch-execution/","title":"Batch Execution for Automation","text":"<p>In some use cases, it may be convenient to run parametric analysis of some numerical model with different parameters. A batch execution procedure may be required to automate the process. In this example, we show how to perform similar tasks. The model can be downloaded.</p> <p>It must be noted that by default, all output files generated by recorders are saved under the current working folder. Only the Visualization recorder supports customized output folder name, which is again defined relative to current working folder.</p> <p>Possible useful commands include: <code>pwd</code> , <code>terminal</code>. Depending on the different platform, it is always possible to use PowerShell, bash or other shells to perform automation tasks. Here, we show a Python example.</p>"},{"location":"Example/Miscellaneous/batch-execution/#batched-time-history-analysis","title":"Batched Time History Analysis","text":"<p>Suppose we, as structural engineers, are asked to perform a series of time history analyses to find the maximum displacement of some structure under a number of different ground motions.</p> <p>For simplicity, let the structure be a SDOF mass--spring system, and we want to apply all the records in the NZ Strong Motion database. Please note the provided archive only contains a few records. Please visit the corresponding page for the full database (with 700+ records).</p>"},{"location":"Example/Miscellaneous/batch-execution/#the-model","title":"The Model","text":"<p>We define a template of the model and use a placeholder named as <code>$groundMotionRecord</code> to be later replaced by specific record names. The analysis time is labelled as <code>$duration</code>. It can be changed for different records. The model script will look like the follows.</p> Text Only<pre><code># an example of batch processing\n\nnode 1 0 0\nnode 2 1 0\n\n# set modulus ==&gt; 16\\pi^2\nmaterial Elastic1D 1 157.913670417\n\nelement T2D2 1 1 2 1 1\n\nmass 2 2 1 1\n\nfix 1 1 1\nfix 2 2 1 2\n\namplitude NZStrongMotion 1 $groundMotionRecord\n\n# apply reference acceleration ==&gt; 1m/s^2\nacceleration 2 1 1.0 1 2\n\nhdf5recorder 1 Node U1 2\n\nstep dynamic 1 $duration\nset ini_step_size 1E-2\nset fixed_step_size true\n\nintegrator Newmark 1\n\nconverger AbsIncreDisp 1 1E-12 10 1\n\nanalyze\n\nexit\n</code></pre> <p>The above model defines a SDOF structure with a period of half a second. With PGA equals unity (ground motion record is normalised), the displacement is recorded.</p>"},{"location":"Example/Miscellaneous/batch-execution/#folder-structure","title":"Folder Structure","text":"<p>The template model file <code>batch-execution.supan</code> is placed alongside the folder <code>NZStrongMotion</code> which contains example NZ strong motion records.</p> Text Only<pre><code>C:\\BATCH-EXECUTION\n\u2502   batch-execution.supan\n\u2502\n\u2514\u2500\u2500\u2500NZStrongMotion\n    20030821_121249_BDCS_N59E_A\n    20030821_121249_BDCS_S31E_A\n    20030821_121249_DCDS_N67E_A\n    20030821_121249_DCDS_S23E_A\n    20030821_121249_DGNS_S18W_A\n    20030821_121249_DGNS_S72E_A\n    20030821_121249_DKHS_N33W_A\n</code></pre> <p>To automate the task, we want to</p> <ol> <li>loop over all strong motion records</li> <li>for each record, replace placeholder <code>$groundMotionRecord</code> with the proper file name to load the record</li> <li>replace <code>$duration</code> with proper analysis duration which can be determined by the duration of record</li> <li>perform the response history analysis</li> </ol> <p>Note the recorded displacement is stored in <code>*.h5</code> file, it may be better to store them in different folder with the name of the corresponding ground motion. This can be done in two approaches:</p> <ol> <li>Create the folder first and launch <code>suanPan</code> inside that folder.</li> <li>Launch <code>suanPan</code> first, use <code>terminal</code> to create that folder, switch to that folder via <code>pwd</code> and perform the    analysis.</li> </ol> <p>Given that we are going to use Python, we can simply choose the first option.</p>"},{"location":"Example/Miscellaneous/batch-execution/#python-script","title":"Python Script","text":""},{"location":"Example/Miscellaneous/batch-execution/#load-template-first","title":"Load Template First","text":"Python<pre><code>import os\nimport shutil\nplaceholder = '$groundMotionRecord'\nduration = '$duration'\ntemplate_file = open(\"batch-execution.supan\", \"r\")\ntemplate_model = template_file.read()\n</code></pre>"},{"location":"Example/Miscellaneous/batch-execution/#load-all-record-names","title":"Load All Record Names","text":"Python<pre><code>records = os.listdir('NZStrongMotion')\n</code></pre>"},{"location":"Example/Miscellaneous/batch-execution/#loop","title":"Loop","text":"<p>Now loop over each record and perform the analysis.</p> Python<pre><code>for record in records:\nprint(\"Processing \" + record)\ntry:\n# try to create folder\nos.mkdir(record)\nexcept OSError:\n# if folder exists, remove it and create an empty one\nshutil.rmtree(record)\nos.mkdir(record)\n# switch to the created folder\nos.chdir(record)\n# create the model file by using the record name\nmodel_file = open(record + \".sp\", \"w\")\n# write modified script to the model file\n# remember now we are in the newly created folder, the record is stored in ..\\NZStrongMotion\nmodel_file.write(template_model.replace(placeholder, '..\\\\NZStrongMotion\\\\' + record).replace(duration, '100'))\n# remember to close before running the model\nmodel_file.close()\n# now invoke suanPan to run the model\n# you may need to replace suanPan with the full path to the executable file if it is not added to PATH\nos.system('suanPan -f ' + record + '.sp &gt; log.txt')\n# need to change back to parent folder\nos.chdir('..')\n</code></pre>"},{"location":"Example/Miscellaneous/batch-execution/#postprocessing","title":"Postprocessing","text":"<p>What if to postprocessing data? Since the output files are stored in <code>HDF5</code> format, one can use <code>h5py</code> to operate on those results to do whatever needed.</p>"},{"location":"Example/Solid/wave-propagation/","title":"[\u2605\u2605\u2605\u2606\u2606] Propagation of A Planar Wave","text":"<p>In this example, we demonstrate an example of wave propagation in a 2D solid.</p> <p>Essentially, it is a 2D dynamics problem. The CP4 element is used to model the solid. Various time integration methods will be used to compare their performance regarding numerical energy dispersion.</p> <p>The model script can be downloaded here.</p> <p>This model contains 16641 nodes and 16384 elements. The memory usage is about 1.2 GB.</p> <p>Due to small step size and need to export visualization data, the full analysis takes around 20 minutes to complete on an average PC platform (6 physical cores @ 3 GHz).</p>"},{"location":"Example/Solid/wave-propagation/#model","title":"Model","text":"<p>A square solid of size \\(\\(3200\\times3200\\)\\) is used. The structured mesh can be generated by using whatever mesh generator available. It is not difficult to generate an array of squares using scripting languages such as Python or Matlab. Here, Gmsh is used.</p> <p>The left and right boundary are constrained along the horizontal direction. The bottom boundary is constrained along the vertical direction. An initial velocity is assigned to the node at the centre of the top boundary.</p>"},{"location":"Example/Solid/wave-propagation/#material","title":"Material","text":"<p>Whether plane stress or plane strain assumption is adopted is not the focus of this example, we simply use a plane stress element with a unit thickness.</p> Text Only<pre><code>material Elastic2D 1 1E7 .2 1 1\n</code></pre>"},{"location":"Example/Solid/wave-propagation/#visualisation","title":"Visualisation","text":"<p>For visualisation, we define a <code>Visualisation</code> recorder. We record von Mises stress to represent the propagation of stress field.</p> Text Only<pre><code>hdf5recorder 1 Visualisation MISES width 5\n</code></pre>"},{"location":"Example/Solid/wave-propagation/#ibc","title":"IBC","text":"<p>The boundaries can be extracted by generating node groups.</p> Text Only<pre><code>generatebyrule nodegroup 1 1 1. 0. # left\ngeneratebyrule nodegroup 2 1 1. 3200. # right\ngeneratebyrule nodegroup 3 2 1. 0. # bottom\n</code></pre> <p>Then BCs can be applied via <code>groupmultiplierbc</code>.</p> Text Only<pre><code>groupmultiplierbc 1 1 1 2\ngroupmultiplierbc 2 2 3\n</code></pre> <p>The initial condition can be applied using <code>initial</code> command.</p> Text Only<pre><code># node 322 is the centre of the top boundary (1600,3200)\ninitial velocity -1 2 322\n</code></pre>"},{"location":"Example/Solid/wave-propagation/#time-integration","title":"Time Integration","text":"<p>We use both implicit and explicit time integration methods.</p>"},{"location":"Example/Solid/wave-propagation/#implicit","title":"Implicit","text":"<p>The implicit time integration methods are the default. If no integrator is defined, a default Newmark integrator will be used.</p> <p>An implicit integrator shall be used with an implicit step.</p> Text Only<pre><code>step ImplicitDynamic 1 4\n# or just\n# step Dynamic 1 4\n</code></pre>"},{"location":"Example/Solid/wave-propagation/#explicit","title":"Explicit","text":"<p>Most explicit methods use acceleration as the primary variable, the equations of motion are often expressed as a function of acceleration. This differs from implicit methods that often use displacement as the primary variable. In order to adopt such a difference, one needs to define an <code>ExplicitDynamic</code> step, similar to the setting in ABAQUS.</p> Text Only<pre><code>step ExplicitDynamic 1 4\n</code></pre> <p>Please be aware that most displacement-based constraints cannot be used in explicit analysis.</p>"},{"location":"Example/Solid/wave-propagation/#other-settings","title":"Other Settings","text":"<p>Since we are using a linear elastic material with the CP4 elements. The elemental stiffness is symmetric. As there are no other non-linear constraints defined in the model, the global stiffness/mass matrix is also symmetric. It is possible to then turn on symmetric banded storage to save memory space.</p> <p>Also, since the system is linear, the global stiffness/mass matrix does not change once assembled. It is possible to indicate the solver to skip iterations.</p> Text Only<pre><code>set symm_mat 1\nset band_mat 1\nset linear_system 1\n</code></pre>"},{"location":"Example/Solid/wave-propagation/#results","title":"Results","text":"<p>For a not-so-rigorous comparison, different spectral radii are used for different methods, mainly for the purpose of showcasing different methods.</p> <p>Also, the chosen model parameters are quite arbitrary. Sufficently accurate results often require an accurate estimation of the highest frequency of the model, which governs the time step size.</p>"},{"location":"Example/Solid/wave-propagation/#implicit_1","title":"Implicit","text":"<p>The Bathe two-step method appears to have the best numerical dispersion performance among implicit methods.</p> <p>The GSSSS optimal scheme is also fine if the spectral radius is chosen properly.</p> <p>The second-order, unconditionally stable Newmark method has significant high-frequency noise. This explains why it is mainly used for structural dynamics in which the low-frequency response is of interest.</p> <p>The chosen time step size is 0.01 s for all three cases. The following radii are used:</p> <ul> <li>Bathe Implicit: 0.9</li> <li>GSSSS Optimal: 0.8</li> <li>Newmark: 1.0</li> </ul> <p></p>"},{"location":"Example/Solid/wave-propagation/#explicit_1","title":"Explicit","text":"<p>The explicit methods show better numerical dispersion.</p> <p>The Tchamwa method is first-order accurate, and does not require corrector.</p> <p>The Noh-Bathe two-step explicit method, as discussed in the original reference, shows superior performance. However, it requires a corrector step, which requires an additional element-wise computation for each substep. This increases the computational cost.</p> <p>The chosen time step size is 0.001 s. The following radii are used:</p> <ul> <li>Tchamwa: 0.9</li> <li>Tchamwa: 0.6</li> <li>Bathe Explicit: 0.9</li> </ul> <p></p>"},{"location":"Example/Structural/Buckling/buckling-analysis-of-a-cantilever-beam/","title":"[\u2605\u2605\u2606\u2606\u2606] Buckling Analysis of A Cantilever Beam","text":"<p>We present a buckling analysis of a cantilever beam with validations.</p> <p>Consider a cantilever beam with a length of \\(\\(L=10\\)\\) and a unit square cross-section, viz., \\(\\(b=h=1\\)\\). The elastic modulus of the material used is assumed to be \\(\\(E=1200\\)\\). So that the bending stiffness \\(\\(EI\\)\\) is</p> \\[ EI=E\\dfrac{bh^3}{12}=1200\\times\\dfrac{1}{12}=100. \\] <p>According to the Euler's formula, the critical axial load of such a cantilever beam is given as</p> \\[ P_{cr}=\\dfrac{\\pi^2EI}{(KL)^2} \\] <p>with \\(\\(K=2\\)\\) for cantilever beams.</p> <p>Substituting model properties into the formula, one could obtain</p> \\[ P_{cr}=\\dfrac{\\pi^2EI}{(KL)^2}=\\dfrac{\\pi^2\\times100}{4\\times10^2}\\approx2.4674. \\]"},{"location":"Example/Structural/Buckling/buckling-analysis-of-a-cantilever-beam/#model-geometry","title":"Model Geometry","text":"<p>We use the <code>B21</code> element to model the problem. Since <code>B21</code> incorporates with sections, we need to define a proper section, the <code>Rectangle2D</code> is used. The geometry is stored in file <code>geometry.supan</code>.</p> Text Only<pre><code>! file name: geometry.supan\n! material and section\nmaterial Elastic1D 1 1200\nsection Rectangle2D 1 1 1 1\n! nodes\nnode 1 0 0\nnode 2 2 0\nnode 3 4 0\nnode 4 6 0\nnode 5 8 0\nnode 6 10 0\n! elements with 6 integration points along element chord\nelement B21 1 1 2 1 6 1\nelement B21 2 2 3 1 6 1\nelement B21 3 3 4 1 6 1\nelement B21 4 4 5 1 6 1\nelement B21 5 5 6 1 6 1\n</code></pre> <p>Note for a buckling analysis, the nonlinear geometry has been turned on, here <code>B21</code> uses a corotational formulation.</p>"},{"location":"Example/Structural/Buckling/buckling-analysis-of-a-cantilever-beam/#buckling-analysis","title":"Buckling Analysis","text":"<p>The analysis commands are stored in file <code>analysis.supan</code>. First we fix the first node and apply a reference axial compression. Theoretically, this applied axial compression force could have arbitrary magnitude in the context of ** linear** buckling analysis. However, in <code>suanPan</code>, the nonlinear (instead of linear) analysis would be performed first. So the result depends on the magnitude of applied force.</p> Text Only<pre><code>! analysis.supan\n! load model geometry first\nfile geometry.supan\n! apply bc\nfix 1 P 1\n! apply axial load on the free end\ncload 1 0 -1E-2 1 6\n</code></pre> <p>We could then create a <code>buckle</code> step and analysis the problem. Alternatively, the keyword <code>buckling</code> could be used. It shall be noted, the stiffness in nonlinear analysis may not be positive definite, thus not all matrix storage schemes are valid to solve the problem. It is recommended to use asymmetric schemes.</p> Text Only<pre><code>! analysis.supan\nstep buckle 1\nset symm_mat false\nanalyze\nexit\n</code></pre> <p>The output is</p> Text Only<pre><code>+--------------------------------------------------+\n|   __        __        suanPan is an open source  |\n|  /  \\      |  \\          FEM framework (64-bit)  |\n|  \\__       |__/  __   __          Acrux (0.1.0)  |\n|     \\ |  | |    /  | |  |                        |\n|  \\__/ |__| |    |__X |  |     maintained by tlc  |\n|                             all rights reserved  |\n+--------------------------------------------------+\n\ncurrent analysis time: 1.00000.\n\nbuckling load multiplier: 2.48778147E+02.\n\nFinished in 0.005 seconds.\n</code></pre> <p>The buckling load is then the multiplication of initial reference load and multiplier.</p> \\[ P_{cr}=2.488\\times10^2\\times1\\times10^{-2}=2.488. \\] <p>This is close to the Euler's solution. Mesh refinement could be applied to obtain closer value. The effect of different magnitudes of initial reference load is shown as below.</p> <p></p> <p>A full nonlinear bifurcation analysis is available in another page.</p>"},{"location":"Example/Structural/Contact/contact-between-beam-and-block/","title":"[\u2605\u2605\u2605\u2606\u2606] Contact Between Beam And Block","text":"<p>In this example, we showcase the simulation of a 2D node-line contact problem. The model can be downloaded. contact-between-beam-and-block.zip</p>"},{"location":"Example/Structural/Contact/contact-between-beam-and-block/#the-beam","title":"The Beam","text":"<p>Suppose there is an elastic cantilever beam with left end at \\(\\((0,0)\\)\\) fully fixed, and right end at \\(\\((2,0)\\)\\). The middle point is subjected to a displacement load.</p> <p>First, we define some nodes.</p> Text Only<pre><code>node 1 0 0\nnode 2 .5 0\nnode 3 1 0\nnode 4 1.5 0\nnode 5 2 0\n</code></pre> <p>We use <code>EB21</code> element to define the element. Accordingly, an elastic material is attached.</p> Text Only<pre><code># E=10\nmaterial Elastic1D 1 10\n\n# I=12 A=1\nelement EB21 1 1 2 12 1 1\nelement EB21 2 2 3 12 1 1\nelement EB21 3 3 4 12 1 1\nelement EB21 4 4 5 12 1 1\n\nfix 1 P 1\n\ndisplacement 1 0 -.1 2 3\n</code></pre>"},{"location":"Example/Structural/Contact/contact-between-beam-and-block/#the-block","title":"The Block","text":"<p>We use <code>CP4</code> to define the block.</p> Text Only<pre><code>node 6 1.5 -.4\nnode 7 2.5 -.4\nnode 8 2.5 -.05\nnode 9 1.5 -.15\n\n# E=10 v=0.2\nmaterial Elastic2D 2 10 .2\n\n# use material 2\nelement CP4 5 6 7 8 9 2 1.\n\nfix 2 P 6 7\n</code></pre>"},{"location":"Example/Structural/Contact/contact-between-beam-and-block/#the-contact-interaction","title":"The Contact Interaction","text":""},{"location":"Example/Structural/Contact/contact-between-beam-and-block/#penalty-function-method","title":"Penalty Function Method","text":"<p>The <code>Contact2D</code> element is used to define contact. It requires two node groups that define master and slave, respectively.</p> <p>Note the outer normal vector of master line is defined by rotating the axis by \\(\\(\\pi/2\\)\\) anticlockwise, the node sequence matters.</p> Text Only<pre><code># slave node group\nnodegroup 1 5\n\n# master node group, pay attention to the sequence\nnodegroup 2 9 8\n\n# define the contact\n# multiplier=1E6\nelement Contact2D 6 2 1 1E6\n</code></pre>"},{"location":"Example/Structural/Contact/contact-between-beam-and-block/#lagrangian-multiplier-method","title":"Lagrangian Multiplier Method","text":"<p>The <code>NodeLine</code> contact constraint can be applied in order to properly account for contact interaction. Each constraint requires three nodes: master \\(\\(i\\)\\), master \\(\\(j\\)\\) and slave \\(\\(k\\)\\). Again the outer normal vector of master line is defined by rotating the axis by \\(\\(\\pi/2\\)\\) anticlockwise, the node sequence matters.</p> Text Only<pre><code>constraint NodeLine 3 9 8 5\n</code></pre>"},{"location":"Example/Structural/Contact/contact-between-beam-and-block/#other-settings-and-analysis","title":"Other Settings and Analysis","text":"<p>It would be good to define a <code>Visualisation</code> recorder so that animations can be generated later by ParaView.</p> Text Only<pre><code>hdf5recorder 1 Visualisation U2\n</code></pre> <p>Now define the step and perform the analysis.</p> Text Only<pre><code>step static 1\nset ini_step_size 1E-2\nset fixed_step_size 1\n\nconverger RelIncreDisp 2 1E-10 10 1\n\nanalyze\n\nexit\n</code></pre>"},{"location":"Example/Structural/Contact/contact-between-beam-and-block/#result","title":"Result","text":""},{"location":"Example/Structural/Contact/contact-between-beam-and-block/#remarks","title":"Remarks","text":"<p>The contact itself is implemented as an element thus the contact force cannot be directly spotted in the resistance of corresponding nodes.</p> <p>The master lines and slave nodes do not rely on the specific elements connected. Thus, the node-line contact can be applied to any 2D problems with various element types including truss, beam, membrane, etc.</p> <p>To define a single contact element is not a difficult task but for large scale problems, it may be quite cumbersome as all potential contact pairs need to be defined. For better performance, it is recommended to have few master lines in each element while a couple of contact elements can be defined so that contact detection can be run in parallel.</p>"},{"location":"Example/Structural/Contact/contact-in-3d-space/","title":"[\u2605\u2605\u2605\u2605\u2606] Contact In 3D Space","text":"<p>The simplest case in 3D space would be node to triangular facet contact.</p> <p>In this example, we show how to model 3D contact problems by using both penalty function method and Lagrangian multiplier method.</p> <p>The model scripts can be downloaded.</p>"},{"location":"Example/Structural/Contact/contact-in-3d-space/#the-model","title":"The Model","text":"<p>The contact itself does not need to be defined on any discrete surfaces of elements. Instead, the facet is always formulated by the given three nodes. Thus, contacts can be defined on, for examples, plate/shell surfaces, cube/tetrahedron surfaces, or even three nodes only.</p> <p>Here we define a square flat shell with one edge clamped.</p> Text Only<pre><code>node 1 0 0 0\nnode 2 5 0 0\nnode 3 10 0 0\nnode 4 0 5 0\nnode 5 5 5 0\nnode 6 10 5 0\n\nelement dkts3 1 1 2 5 1 1\nelement dkts3 2 5 4 1 1 1\nelement dkts3 3 2 3 6 1 1\nelement dkts3 4 6 5 2 1 1\n\nmaterial Elastic2D 1 1000 .2\n\ngenerate nodegroup 1 1 3 4\n\ngroupmultiplierbc 1 encastre 1\n</code></pre> <p>A 3D beam cantilever beam is defined on top of the shell.</p> Text Only<pre><code>node 10 8.5 2 .1\nnode 11 11.5 2 .1\nnode 12 14.5 2 .1\n\norientation B3DL 1 0. 0. 1.\n\nmaterial Elastic1D 2 10\n\nsection Rectangle3D 1 12 1 2\n\nelement B31 10 10 11 1 1\nelement B31 11 11 12 1 1\n\nfix2 2 encastre 12\n</code></pre> <p>Once the deformed free end reaches the shell, contact occurs.</p>"},{"location":"Example/Structural/Contact/contact-in-3d-space/#define-contact","title":"Define Contact","text":"<p>The facet is defined by nodes <code>3</code>, <code>6</code> and <code>10</code>. The slave node is <code>2</code>.</p> Text Only<pre><code>constraint NodeFacet 3 2 3 6 10\n</code></pre>"},{"location":"Example/Structural/Contact/contact-in-3d-space/#results","title":"Results","text":"<p>After configuring analysis, it can be performed.</p> Text Only<pre><code>hdf5recorder 1 Visualisation U3\n\nstep static 1 1.000e+00\nset ini_step_size 1.000e-1\nset fixed_step_size true\n\nconverger RelIncreDisp 1 1E-10 20 1\n\ncload 1 0 -50. 3 11\n\nanalyze\n\nexit\n</code></pre> <p>The animation can be shown as follows.</p> <p></p>"},{"location":"Example/Structural/Dynamics/bouncing-of-a-ball/","title":"[\u2605\u2605\u2605\u2606\u2606] Bouncing of A Ball","text":"<p>In this example we show the application of the <code>RigidWall</code> and  <code>RestitutionWall</code> constraints. It is also possible to define a  rigid wall with finite dimension. The model script can be downloaded.</p> <p>A mass point is used to idealize the ball. As this is a dynamics problem of rigid body, there is no need to define any material models to provide stiffness matrix. For this reason, it is possible to just define a point mass at the target point.</p> Text Only<pre><code># define a node at (-1,2)\nnode 1 -1 2\n# define a unit point mass element at node 1, both DoF 1 and DoF 2 are activated\nmass 1 1 1 1 2\n</code></pre> <p>No matter how the gravity load is applied, it is required to define a constant amplitude that provides a constant level of either gravity force or acceleration. We define a proper amplitude first.</p> Text Only<pre><code>amplitude Constant 1\n</code></pre> <p>To apply the gravity, we use a constant vertical acceleration load, to do so,</p> Text Only<pre><code># define a acceleration load of magnitude -1 using amplitude 1 on DoF 2 of node 1\nacceleration 1 1 -1 2 1\n</code></pre> <p>Alternatively, a vertical load can be applied</p> Text Only<pre><code>cload 1 1 -1 2 1\n</code></pre> <p>Since the initial state is always in equilibrium, an initial condition can be added.</p> Text Only<pre><code># assign initial acceleration of maginutde of -1 on DoF 2 of node 1\ninitial acc -1 2 1\n</code></pre>"},{"location":"Example/Structural/Dynamics/bouncing-of-a-ball/#free-fall","title":"Free Fall","text":"<p>Now the model is ready to run a free fall simulation.</p> Text Only<pre><code>step dynamic 1 1\nset ini_step_size 1E-1\nset fixed_step_size 1\nconverger RelIncreDisp 1 1E-8 10 1\nanalyze\npeek node 1\nexit\n</code></pre> <p>A default Newmark time integration algorithm will be assigned if no valid integrator is defined. The output is</p> Text Only<pre><code>Node 1:\n  -1.0000   2.0000\nDisplacement:\n        0  -0.5000\nResistance:\n        0        0\nVelocity:\n        0  -1.0000\nAcceleration:\n        0  -1.0000\n</code></pre> <p>The analytical displacement can be simply computed as</p> \\[ u=\\dfrac{1}{2}at^2=\\dfrac{1}{2}. \\]"},{"location":"Example/Structural/Dynamics/bouncing-of-a-ball/#rigid-wall-constraint","title":"Rigid Wall Constraint","text":"<p>We define two infinite rigid wall constraints inclined \\(\\(\\pi/4\\)\\) and \\(\\(3\\pi/4\\)\\) to form a right angle. The ball can bounce between two walls. Two walls are both anchored at the origin and have infinite dimension, the outer normals are \\(\\((1,1)\\)\\) and \\(\\((-1,1)\\)\\), respectively. The penalty factor is chosen to be \\(\\(0.1\\)\\) in this particular example.  Accounting for the time step defined below (\\(\\(0.005\\)\\)), the actual penalty factor applied to the effective stiffness is \\(\\(0.1/0005/0.005=4000\\)\\).</p> Text Only<pre><code>rigidwall 1 0 0 1 1 1E-1\nrigidwall 2 0 0 -1 1 1E-1\n</code></pre> <p>The penalty factor can be altered to achieve different levels of satisfactions of the constraint. But higher values also result in greater high frequency noise.</p> <p>It may be of interest to record the motion of the ball.</p> Text Only<pre><code>hdf5recorder 1 Node U 1\nhdf5recorder 2 Node V 1\nhdf5recorder 3 Node A 1\n</code></pre> <p>Then configure the analysis,</p> Text Only<pre><code>step dynamic 1 40\nset ini_step_size 5E-3\nset fixed_step_size 1\n\nconverger RelIncreDisp 1 1E-8 7 1\n\nanalyze\n</code></pre> <p>The results are shown as follows.</p> <p></p> <p>The energy of the system is not conserved. To alleviate this problem, one can use the  <code>RestitutionWall</code> constraint.</p>"},{"location":"Example/Structural/Dynamics/bouncing-of-a-ball/#restitution-wall-constraint","title":"Restitution Wall Constraint","text":""},{"location":"Example/Structural/Dynamics/bouncing-of-a-ball/#elastic-collision","title":"Elastic Collision","text":"<p>The constraints can be replaced by</p> Text Only<pre><code>restitutionwall 1 0 0 1 1 1. 1E4\nrestitutionwall 2 0 0 -1 1 1. 1E4\n</code></pre> <p>Here the coefficient of restitution is set to 1.</p> <p></p>"},{"location":"Example/Structural/Dynamics/bouncing-of-a-ball/#plastic-collision","title":"Plastic Collision","text":"<p>One can define a plastic collision by using a coefficient of restitution smaller than unity.</p> Text Only<pre><code>restitutionwall 1 0 0 1 1 .9 1E4\nrestitutionwall 2 0 0 -1 1 .9 1E4\n</code></pre> <p></p>"},{"location":"Example/Structural/Dynamics/computing-response-spectrum/","title":"[\u2605\u2606\u2606\u2606\u2606] Response Spectrum","text":"<p>Minimum version: v2.6</p> <p>The model script can be downloaded. computing-response-spectrum.zip</p>"},{"location":"Example/Structural/Dynamics/computing-response-spectrum/#introduction","title":"Introduction","text":"<p>Imaging you are asked to compute the response spectra of a collection of accelerograms which may be obtained from some earthquake event. How would you do it?</p> <p>According to the definition, the response spectrum is the maximum response of structures with different natural frequencies to the same earthquake.</p> <p>A natural approach is to:</p> <ol> <li>Create a SDOF linear mass-spring-dashpot model with proper parameters that result in the desired natural    frequencies and damping ratios.</li> <li>Perform full response history analysis for each frequency point.</li> <li>Compute the maximum response at each frequency point.</li> <li>Plot the response spectrum.</li> </ol> <p>This is fine, but extremely inefficient. For linear systems, you may have known that Duhamel's integral can be used to compute the response. Indeed, Duhamel's integral is a de facto practice for computing response spectra, especially in the field of seismology.</p> <p>However, even Duhamel's integral is not sufficiently performant. A blazing fast algorithm is proposed by Lee. The algorithm is implemented as the <code>response_spectrum</code> and the <code>sdof_response</code> command.</p> <p>In this example, we will demonstrate how to use the <code>response_spectrum</code> and <code>sdof_response</code> commands to compute the response spectra and compare the results with the full response history analysis.</p>"},{"location":"Example/Structural/Dynamics/computing-response-spectrum/#model","title":"Model","text":"<p>To allow comparison, we define a minimum SDOF model.</p> Text Only<pre><code># rha.sp\n\nnode 1 0 0\nnode 2 1 0\n\nmaterial Elastic1D 1 1.57913670417430E2\n\nelement T2D2 1 1 2 1 1\n\nmass 2 2 1 1\n\nfix2 1 1 1\nfix2 2 2 1 2\n\nmodifier Rayleigh 1 0 0.003183098862 0. 0. 1\n\namplitude Tabular 1 EZ\n\ncload 1 1 -1 1 2\n\nplainrecorder 1 Node U 2\nplainrecorder 2 Node V 2\nplainrecorder 3 Node A 2\n\nstep dynamic 1 15\nset ini_step_size 1E-2\nset fixed_step_size 1\n\nintegrator Newmark 1\n\nconverger AbsIncreDisp 1 1E-13 10 1\n\nanalyze\n\nsave recorder 1 2 3\n\nexit\n</code></pre> <p>We assume the frequency of the SDOF model is \\(\\(2\\)\\) Hz, which is equivalent to a natural frequency of \\(\\(4\\pi\\)\\) rad/s. The damping ratio is chosen to be a typical value \\(\\(0.02\\)\\).</p> <p>Assuming a unit mass and a stiffness proportional damping model, this gives the following parameters.</p> \\[ m=1,\\quad{}\\omega_n=4\\pi,\\quad{}k=\\omega_n^2m=16\\pi^2. \\] <p>For damping, assuming \\(\\(c=a_1k\\)\\), then</p> \\[ c=2\\zeta\\sqrt{mk}=a_1k,\\quad{}a_1=2\\zeta/\\omega_n=0.003183098862. \\] <p>The provided acceleration is sampled with a sampling interval of \\(\\(0.03\\)\\) s. To improve the accuracy of the response history analysis, the time step size is set to \\(\\(0.01\\)\\) s.</p> <p>Note since we are applying acceleration as inertial force, the amplitude of the acceleration is \\(\\(-1\\)\\).</p>"},{"location":"Example/Structural/Dynamics/computing-response-spectrum/#sdof-response","title":"SDOF Response","text":"<p>The <code>sdof_response</code> command can be used to compute the response.</p> Text Only<pre><code># sdof.sp\n\nsdof_response EZ 2 0.02\n\nexit\n</code></pre> <p>The result will be saved to <code>EZ_sdof_response</code>.</p>"},{"location":"Example/Structural/Dynamics/computing-response-spectrum/#analyse-and-compare","title":"Analyse and Compare","text":"<p>We can now run <code>rha.sp</code> and <code>sdof.sp</code> to obtain two sets of results.</p> Python<pre><code>import os\nfrom shutil import which\nif os.name == 'nt':\nexe_name = 'suanPan.exe'\nelse:\nexe_name = 'suanpan'\nif which(exe_name):\nos.system(f'{exe_name} -np -f rha.sp')\nos.system(f'{exe_name} -np -f sdof.sp')\n</code></pre> <p>Now let's try to plot the results.</p> Python<pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nwith open('EZ_sdof_response', 'r') as f:\nsdof = np.loadtxt(f)\nwith open('R1-U2.txt', 'r') as f:\ndisplacement = np.loadtxt(f)\nwith open('R2-V2.txt', 'r') as f:\nvelocity = np.loadtxt(f)\nwith open('R3-A2.txt', 'r') as f:\nacceleration = np.loadtxt(f)\nfig = plt.figure(figsize=(8, 8), dpi=300)\nax1 = fig.add_subplot(311)\nfor index, record, label in zip(\n[1, 2, 3], [displacement, velocity, acceleration], ['Displacement', 'Velocity', 'Acceleration']):\nax = fig.add_subplot(310 + index)\nax.plot(sdof[:, 0], sdof[:, index], 'r-', label='SDOF')\nax.plot(record[:, 0], record[:, 1], 'b-', label='RHA')\nax.set_ylabel(label)\nax.legend()\nfig.tight_layout()\nfig.savefig('time_response.png')\nplt.close()\n</code></pre> <p>The results are shown below.</p> <p></p> <p>It is evident that Lee's algorithm is accurate. If one pays attention to the wall clock time required by two approaches, Lee's algorithm is much faster than the full response history analysis. On an average platform, Lee's algorithm is  100 times faster (indicative). There are a few things to note.</p> <ol> <li>The response history analysis often requires a small step size --- a fraction of sampling interval of     acceleration record. This is to ensure the accuracy of the result.</li> <li>Lee's algorithm is essentially an IIR filter. It only requires two multiplications per time step. The sampling     interval can be directly used to compute the response.</li> <li>With Lee's algorithm, in a more general setting, velocity and acceleration responses would be computed as the     scaled difference of displacement and velocity responses, respectively. They are also blazing fast to compute.</li> <li>To compute response spectrum, as we only need the maximum response, further optimisation can be made. See Lee's     paper for further discussions.</li> </ol>"},{"location":"Example/Structural/Dynamics/computing-response-spectrum/#response-spectrum_1","title":"Response Spectrum","text":""},{"location":"Example/Structural/Dynamics/computing-response-spectrum/#initial-attempt","title":"Initial Attempt","text":"<p>We have gained some confidence in the reliability of the result. The <code>response_spectrum</code> command essentially calls the <code>sdof_response</code> command to compute the maximum response at each frequency. Now we can use it to compute response  spectrum.</p> Text Only<pre><code># spectrum.sp\n\nresponse_spectrum EZ period 0.02\n\nexit\n</code></pre> <p>We provide a vector of periods of interest. The result will be saved to <code>EZ_response_spectrum</code>. The spectra can be  plotted.</p> Python<pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nwith open('EZ_response_spectrum', 'r') as f:\nspectrum = np.loadtxt(f)\nfig = plt.figure(figsize=(8, 8), dpi=300)\nax1 = fig.add_subplot(311)\nax1.plot(spectrum[:, 0], spectrum[:, 1], 'r-', label='SD')\nax1.set_ylabel('Displacement')\nax1.set_xlabel('Period')\nax1.legend()\nax2 = fig.add_subplot(312)\nax2.plot(spectrum[:, 0], spectrum[:, 2], 'r-', label='SV')\nax2.plot(spectrum[:, 0], 2 * np.pi * spectrum[:, 1] / spectrum[:, 0], 'b-', label='PSV')\nax2.set_ylabel('Velocity')\nax2.set_xlabel('Period')\nax2.legend()\nax3 = fig.add_subplot(313)\nax3.plot(spectrum[:, 0], spectrum[:, 3], 'r-', label='SA')\nax3.plot(spectrum[:, 0], 2 * np.pi * 2 * np.pi * spectrum[:, 1] / spectrum[:, 0] / spectrum[:, 0], 'b-', label='PSA')\nax3.set_ylabel('Acceleration')\nax3.set_xlabel('Period')\nax3.legend()\nfig.tight_layout()\nfig.savefig('response_spectrum.png')\nplt.close()\n</code></pre> <p></p>"},{"location":"Example/Structural/Dynamics/computing-response-spectrum/#refine-the-result","title":"Refine the Result","text":"<p>As the sampling interval of the provided acceleration record is \\(\\(0.03\\)\\) s, it appears to be too large to obtain  accurate result. How to tell that? Given that the damping ratio is small, SA and PSA should be close.</p> <p>We can try to refine the result by using a smaller interval. To this end, we first create a new record by linear  interpolation.</p> Python<pre><code>import numpy as np\nEZ = np.loadtxt('EZ')\ntime = np.arange(0, 10, 0.001)\namplitude = np.interp(time, EZ[:, 0], EZ[:, 1])\nnp.savetxt('EZ_refined', np.column_stack((time, amplitude)))\n</code></pre> <p>Now we can run the analysis again.</p> Text Only<pre><code># spectrum_refined.sp\n\nresponse_spectrum EZ_refined freq 0.02\n\nexit\n</code></pre> <p>The results are shown as follows.</p> <p></p>"},{"location":"Example/Structural/Dynamics/dynamic-analysis-of-a-portal-frame/","title":"[\u2605\u2605\u2606\u2606\u2606] Dynamic Analysis of A Portal Frame","text":"<p>A portal frame is analyzed using viscous damper as energy dissipater.</p> <p>The model script can be downloaded. dynamic-analysis-of-a-portal-frame.zip</p>"},{"location":"Example/Structural/Dynamics/dynamic-analysis-of-a-portal-frame/#model-description","title":"Model Description","text":"<p>Consider a simple portal frame with the following configurations.</p> <p></p> <p>Then</p> \\[ EI_c=2\\times10^5\\times3.18\\times10^6=6.36\\times10^{13}~\\mathrm{Nmm^2}=0.636~\\mathrm{MNm^2}. \\] <p>Since the moment of inertia of the beam is about ten times larger than that of column, it is fair to assume the beam is rigid. So the horizontal translation stiffness is</p> \\[ K=2K_c=2\\times\\dfrac{12EI}{L^3}=2\\times\\dfrac{12\\times0.636~\\mathrm{MNm^2}}{5^3~\\mathrm{m^3}}=122.112~\\mathrm{kN/m}. \\] <p>Hence, the period is</p> \\[ t=\\dfrac{2\\pi}{\\omega}=2\\pi\\sqrt{\\dfrac{M}{K}}=2\\pi\\sqrt{\\dfrac{10~\\mathrm{t}}{122.112~\\mathrm{kN/m}}}\\approx1.800~ \\mathrm{s}. \\]"},{"location":"Example/Structural/Dynamics/dynamic-analysis-of-a-portal-frame/#simulation-setup","title":"Simulation Setup","text":"<p>First we define nodes, materials, sections and point masses, we use <code>B21</code> as elements.</p> Text Only<pre><code>! length = meter\n! mass = tonne\n! force = kilo Newton\nnode 1 0 0\nnode 2 0 5\nnode 3 5 5\nnode 4 5 0\n\nmaterial Elastic1D 1 200E6\n\nsection NZ2D 250UB25.7 1 1 0.001 6\nsection NZ2D 100UC14.8 2 1 0.001 6\n\nelement B21 1 1 2 2 6\nelement B21 2 2 3 1 6\nelement B21 3 3 4 2 6\n\nelement Mass 4 2 5 1\nelement Mass 5 3 5 1\n\nfix 1 P 1 4\n</code></pre>"},{"location":"Example/Structural/Dynamics/dynamic-analysis-of-a-portal-frame/#model-analysis","title":"Model Analysis","text":"<p>By defining a <code>frequency</code> step we can obtain the eigenvalue.</p> Text Only<pre><code>step frequency 1 1\nanalyze\npeek eigenvalue\n</code></pre> <p>The output is</p> Text Only<pre><code>+--------------------------------------------------+\n|   __        __        suanPan is an open source  |\n|  /  \\      |  \\          FEM framework (64-bit)  |\n|  \\__       |__/  __   __          Acrux (0.1.0)  |\n|     \\ |  | |    |  \\ |  |                        |\n|  \\__/ |__| |    |__X |  |     maintained by tlc  |\n|                             all rights reserved  |\n+--------------------------------------------------+\n\nEigenvalues:\n   11.2068\n\nFinished in 0.006 seconds.\n</code></pre> <p>Hence, the corresponding period is</p> \\[ t=\\dfrac{2\\pi}{\\sqrt{11.2068}}\\approx1.877~\\mathrm{s}. \\] <p>There is a difference of about \\(\\(5\\%\\)\\), which may stem from flexible beam. Meanwhile, the computed moment of inertia may be different from the values given in section property table.</p>"},{"location":"Example/Structural/Dynamics/dynamic-analysis-of-a-portal-frame/#dynamic-analysis","title":"Dynamic Analysis","text":"<p>Now we run a time history analysis. The El Centro (NS component) ground motion is used.</p> <p>First we define the recorder to record response.</p> Text Only<pre><code>hdf5recorder 1 Node U1 2 3\n</code></pre> <p>Then the step. We define a dynamic step with a duration of fifty seconds.</p> Text Only<pre><code>step dynamic 1 50.\n</code></pre> <p>Normally we use fixed time step.</p> Text Only<pre><code>set fixed_step_size true\nset ini_step_size 1E-2\n</code></pre> <p>The ground motion amplitude is loaded from external file.</p> Text Only<pre><code>amplitude Tabular 1 ELNS\n</code></pre> <p>Now we apply acceleration on horizontal DoFs.</p> Text Only<pre><code>acceleration 1 1 9.83 1\n</code></pre> <p>The Newmark algorithm would be used. We adopt absolute displacement increment as convergence criterion.</p> Text Only<pre><code>integrator Newmark 1\nconverger AbsIncreDisp 1 1E-5 20 1\n</code></pre> <p>The model is now ready for analysis.</p> Text Only<pre><code>analyze\n</code></pre> <p>The displacement history is shown as follows.</p> <p></p> <p>Since no damping is defined, the system oscillates. Next we use a damper as energy dissipater.</p>"},{"location":"Example/Structural/Dynamics/dynamic-analysis-of-a-portal-frame/#damped-model","title":"Damped Model","text":"<p>A viscous damper can be defined.</p> Text Only<pre><code>material Viscosity01 2 1. 1E1\nelement Damper01 6 1 3 2\n</code></pre> <p>So the damping coefficient is \\(\\(\\eta=10~\\mathrm{kNms^{-1}}\\)\\). The damping force is simply \\(\\(F=\\eta\\cdot{}v\\)\\).</p> <p>Rerun the analysis and the damped displacement history is given as follows.</p> <p></p>"},{"location":"Example/Structural/Dynamics/integrating-preprocessing-with-python/","title":"[\u2605\u2605\u2605\u2605\u2605] Integrating Preprocessing with Python","text":"<p>Minimum version: v2.5</p> <p>In this example, we demonstrate how to use python to preprocess data by creating a frame structure. This example requires some Python familiarity. However, as we are developing a frame structure which contains mainly frame elements, the procedure is relatively straightforward.</p>"},{"location":"Example/Structural/Dynamics/integrating-preprocessing-with-python/#objective","title":"Objective","text":"<p>We are going to create a three--storey frame as shown below.</p> <p></p>"},{"location":"Example/Structural/Dynamics/integrating-preprocessing-with-python/#prerequisites","title":"Prerequisites","text":"<p>We are going to find section properties from AISC table, which is available online.</p> Python<pre><code>import pandas\nsection_table = pandas.read_excel(\n'https://www.aisc.org/globalassets/aisc/manual/v15.0-shapes-database/aisc-shapes-database-v15.0.xlsx',\nsheet_name=1,\nusecols='A:CF')\nprint(section_table.head())\n</code></pre> Text Only<pre><code>Database v15.0\n  Type EDI_Std_Nomenclature AISC_Manual_Label T_F      W      A     d    ddet  \\\n0    W              W44X335           W44X335   F  335.0   98.5    44      44   \n1    W              W44X290           W44X290   F  290.0   85.4  43.6  43.625   \n2    W              W44X262           W44X262   F  262.0   77.2  43.3   43.25   \n3    W              W44X230           W44X230   F  230.0   67.8  42.9  42.875   \n4    W              W40X655           W40X655   T  655.0  193.0  43.6  43.625\n\n  Ht  h  ...   rts    ho   PA PA2   PB   PC   PD   T  WGi WGo  \n0  \u2013  \u2013  ...  4.24  42.2  132   \u2013  148  104  120  38  5.5   \u2013  \n1  \u2013  \u2013  ...   4.2    42  131   \u2013  147  103  119  38  5.5   \u2013  \n2  \u2013  \u2013  ...  4.17  41.9  131   \u2013  147  102  118  38  5.5   \u2013  \n3  \u2013  \u2013  ...  4.13  41.7  130   \u2013  146  102  118  38  5.5   \u2013  \n4  \u2013  \u2013  ...  4.71  40.1  132   \u2013  149  104  121  34  7.5   \u2013\n\n[5 rows x 84 columns]\n</code></pre> <p>Section properties such as area and moment of inertia can be extracted from this table using section designations. It is possible to define such a function now.</p> Python<pre><code>def from_table(designation: str):\nindex = section_table.index[section_table['AISC_Manual_Label'] == designation].tolist()\nassert len(index) == 1\na = section_table.at[index[0], 'A']  # area\nsx = section_table.at[index[0], 'Sx']  # elastic modulus\nix = section_table.at[index[0], 'Ix']  # moment of inertia\nzx = section_table.at[index[0], 'Zx']  # plastic modulus\nreturn a, sx, ix, zx\n</code></pre> <p>Then we can use this function to extract section properties from the table. For example,</p> Python<pre><code>print(from_table('W44X230'))\n</code></pre> Text Only<pre><code>(67.8, 971.0, 20800.0, 1100.0)\n</code></pre>"},{"location":"Example/Structural/Dynamics/integrating-preprocessing-with-python/#geometry-of-the-frame-structure","title":"Geometry of the Frame Structure","text":"<p>For simplicity, we assume the frame structure has the same column/beam section for all the columns/beams on the same floor. Under such a condition, two lists of section designations can be provided so that elements can be created. Similarly, geometry information such as floor height, bay span, as well as floor mass, can be provided in the same way.</p> <p>For example, we can define several lists as follows.</p> Python<pre><code>girder = ['W21X68', 'W21X68', 'W21X68']  # floor 1 2 3\ncolumn = ['W14X193', 'W14X159', 'W14X159']  # column 1 2 3\nmass = [10., 10., 10.]  # floor 1 2 3\nspan = [240., 240.]  # bay span 1 2\nheight = [120., 120., 120.]  # floor height 1 2 3\n</code></pre>"},{"location":"Example/Structural/Dynamics/integrating-preprocessing-with-python/#generate-node-grid","title":"Generate Node Grid","text":"<p>Given that span and height are given, it is possible to calculate the absolute position of the nodes.</p> Python<pre><code>import numpy as np\nx_coor = np.cumsum(span)\ny_coor = np.cumsum(height)\nx_coor = np.insert(x_coor, 0, 0.)\ny_coor = np.insert(y_coor, 0, 0.)\nprint(x_coor, y_coor)\ndel span, height\n</code></pre> Text Only<pre><code>[  0. 240. 480.] [  0. 120. 240. 360.]\n</code></pre> <p>By using the above coordinates, we can create a grid of nodes. A simple <code>Node</code> class is defined to represent nodes.</p> Python<pre><code>from dataclasses import dataclass\n@dataclass\nclass Node:\ntag: int\nx: float\ny: float\ndef write_to(self, f_handler):\nf_handler.write(f'node {self.tag} {self.x:.2f} {self.y:.2f}\\n')\nnode_pool: dict = {}\nnode_grid = np.zeros((len(y_coor), len(x_coor))).astype(int)\nnode_tag = 1\nwith open('node.sp', 'w') as f:\nfor i in range(len(x_coor)):\nfor j in range(len(y_coor)):\nnode = Node(node_tag, x_coor[i], y_coor[j])\nnode.write_to(f)\nnode_pool[node_tag] = node\nnode_grid[j, i] = node_tag\nnode_tag += 1\ndel node_tag\nwith open('node.sp', 'r') as f:\nprint(f.read())\n</code></pre> Text Only<pre><code>node 1 0.00 0.00\nnode 2 0.00 120.00\nnode 3 0.00 240.00\nnode 4 0.00 360.00\nnode 5 240.00 0.00\nnode 6 240.00 120.00\nnode 7 240.00 240.00\nnode 8 240.00 360.00\nnode 9 480.00 0.00\nnode 10 480.00 120.00\nnode 11 480.00 240.00\nnode 12 480.00 360.00\n</code></pre> <p>The <code>node_grid</code> can be used to generate elements.</p>"},{"location":"Example/Structural/Dynamics/integrating-preprocessing-with-python/#generate-beam-elements","title":"Generate Beam Elements","text":"<p>Starting with the second row, beam elements can be generated by looping over each row.</p> Python<pre><code>from math import sqrt\ne = 29  # mpsi, Young's modulus\nfy = .05  # mpsi, yield stress\nhardening = .01  # isotropic hardening ratio\nnm_size = 1.15  # initial surface size\nsection_pool: dict = {}\nelement_pool: dict = {}\n@dataclass\nclass Section:\ntag: int\nname: str\nfp: float\nmp: float\nea: float\nei: float\nmult: float\ndef __init__(self, tag, name):\nself.tag = tag\nself.name = name\n_a, _sx, _ix, _zx = from_table(name)\nself.fp = fy * _a\nself.mp = fy * _sx\nself.ea = e * _a\nself.ei = e * _ix\nself.mult = fy * _zx\ndef write_to(self, f_handler, d, h):\nf_handler.write(\nf'section NM2D3 {self.tag} {self.ea:.4e} {self.ei:.4e} '  # basic section properties\nf'{self.fp:.4e} {self.mp:.4e} {d} '  # yield forces\nf'{h} 0. 0. {self.mult / self.mp - 1:.4f} 1. '  # hardening configurations\nf'0.\\n')  # linear density\n@dataclass\nclass Element:\ntag: int\nnode_i: Node\nnode_j: Node\nsection: Section\nelement_length: float\ndef __init__(self, tag, _node_i, _node_j, _section):\nself.tag = tag\nself.node_i = _node_i\nself.node_j = _node_j\nself.section = _section\nself.element_length = sqrt((_node_i.x - _node_j.x) ** 2 + (_node_i.y - _node_j.y) ** 2)\ndef write_to(self, f_handler):\nf_handler.write(f'element NMB21 {self.tag} {self.node_i.tag} {self.node_j.tag} {self.section.tag}\\n')\nelement_tag = 1\nsection_tag = 1\nwith open('beam.sp', 'w') as f:\nfor i in range(1, len(y_coor)):\nsection = Section(section_tag, girder[i - 1])\nsection.write_to(f, nm_size, hardening)\nsection_pool[section_tag] = section\nfor j in range(len(x_coor) - 1):\nnode_i = node_grid[i, j]\nnode_j = node_grid[i, j + 1]\nelement = Element(element_tag, node_pool[node_i], node_pool[node_j], section)\nelement.write_to(f)\nelement_pool[element_tag] = element\nelement_tag += 1\nsection_tag += 1\nwith open('beam.sp', 'r') as f:\nprint(f.read())\n</code></pre> Text Only<pre><code>section NM2D3 1 5.8000e+02 4.2920e+04 1.0000e+00 7.0000e+00 1.15 0.01 0. 0. 0.1429 1. 0.\nelement NMB21 1 2 6 1\nelement NMB21 2 6 10 1\nsection NM2D3 2 5.8000e+02 4.2920e+04 1.0000e+00 7.0000e+00 1.15 0.01 0. 0. 0.1429 1. 0.\nelement NMB21 3 3 7 2\nelement NMB21 4 7 11 2\nsection NM2D3 3 5.8000e+02 4.2920e+04 1.0000e+00 7.0000e+00 1.15 0.01 0. 0. 0.1429 1. 0.\nelement NMB21 5 4 8 3\nelement NMB21 6 8 12 3\n</code></pre>"},{"location":"Example/Structural/Dynamics/integrating-preprocessing-with-python/#generate-column-elements","title":"Generate Column Elements","text":"<p>Similarly, column elements can be generated by looping over each column.</p> Python<pre><code>with open('column.sp', 'w') as f:\nfor i in range(len(y_coor) - 1):\nsection = Section(section_tag, column[i])\nsection.write_to(f, nm_size, hardening)\nsection_pool[section_tag] = section\nfor j in range(len(x_coor)):\nnode_i = node_grid[i, j]\nnode_j = node_grid[i + 1, j]\nelement = Element(element_tag, node_pool[node_i], node_pool[node_j], section)\nelement.write_to(f)\nelement_pool[element_tag] = element\nelement_tag += 1\nsection_tag += 1\nwith open('column.sp', 'r') as f:\nprint(f.read())\n</code></pre> Text Only<pre><code>section NM2D3 4 1.6472e+03 6.9600e+04 2.8400e+00 1.5500e+01 1.15 0.01 0. 0. 0.1452 1. 0.\nelement NMB21 7 1 2 4\nelement NMB21 8 5 6 4\nelement NMB21 9 9 10 4\nsection NM2D3 5 1.3543e+03 5.5100e+04 2.3350e+00 1.2700e+01 1.15 0.01 0. 0. 0.1299 1. 0.\nelement NMB21 10 2 3 5\nelement NMB21 11 6 7 5\nelement NMB21 12 10 11 5\nsection NM2D3 6 1.3543e+03 5.5100e+04 2.3350e+00 1.2700e+01 1.15 0.01 0. 0. 0.1299 1. 0.\nelement NMB21 13 3 4 6\nelement NMB21 14 7 8 6\nelement NMB21 15 11 12 6\n</code></pre>"},{"location":"Example/Structural/Dynamics/integrating-preprocessing-with-python/#fibre-based-elements","title":"Fibre Based Elements","text":"<p>The similar procedure can be used to generate fibre based elements with slight modifications. Here we use <code>F21</code> element. It relies on sections, and designations can be directly used to create sections. In this example, we use <code>US2D</code> category.</p> Python<pre><code>with open('fibre_frame.sp', 'w') as f:\nf.write(f'material Bilinear1D 1 {e} {fy} {hardening}\\n\\n')\nfor v in section_pool.values():\nf.write(f'section US2D {v.name} {v.tag} 1\\n')\nf.write('\\n')\nfor v in element_pool.values():\nf.write(f'element F21 {v.tag} {v.node_i.tag} {v.node_j.tag} {v.section.tag}\\n')\nwith open('fibre_frame.sp', 'r') as f:\nprint(f.read())\n</code></pre> Text Only<pre><code>material Bilinear1D 1 29 0.05 0.01\n\nsection US2D W21X68 1 1\nsection US2D W21X68 2 1\nsection US2D W21X68 3 1\nsection US2D W14X193 4 1\nsection US2D W14X159 5 1\nsection US2D W14X159 6 1\n\nelement F21 1 2 6 1\nelement F21 2 6 10 1\nelement F21 3 3 7 2\nelement F21 4 7 11 2\nelement F21 5 4 8 3\nelement F21 6 8 12 3\nelement F21 7 1 2 4\nelement F21 8 5 6 4\nelement F21 9 9 10 4\nelement F21 10 2 3 5\nelement F21 11 6 7 5\nelement F21 12 10 11 5\nelement F21 13 3 4 6\nelement F21 14 7 8 6\nelement F21 15 11 12 6\n</code></pre>"},{"location":"Example/Structural/Dynamics/integrating-preprocessing-with-python/#generate-mass","title":"Generate Mass","text":"<p>For simplicity, we only apply horizontal mass to each node, the procedure is similar to that of frame elements.</p> <p>To keep code modular, we define a mass grid to store mass at each node.</p> Python<pre><code>column_num = len(x_coor)\nif 1 == column:\nportions = 1.\nelse:\nportions = 2. * (column_num - 1)\n# unit conversion\nportions *= 12 * 1000\n# calculate tributary mass by assuming uniform density\n# thus exterior nodes take half of the mass of interior nodes\nmass_grid = np.zeros((len(y_coor), column_num))\nfor i in range(1, len(y_coor)):\nfor j in range(column_num):\nmass_grid[i, j] = mass[i - 1] / portions\nfor j in range(1, column_num - 1):\nmass_grid[i, j] *= 2.\nprint(mass_grid)\ndel column_num, portions\n</code></pre> Text Only<pre><code>[[0.         0.         0.        ]\n [0.00020833 0.00041667 0.00020833]\n [0.00020833 0.00041667 0.00020833]\n [0.00020833 0.00041667 0.00020833]]\n</code></pre> <p>Now we assign mass to each node.</p> Python<pre><code>with open('mass.sp', 'w') as f:\nfor node_tag, mass in zip(node_grid.flatten(), mass_grid.flatten()):\nif mass == 0.:\ncontinue\nf.write(f'element Mass {element_tag} {node_tag} {mass :.4e} 1 2\\n')\nelement_tag += 1\nwith open('mass.sp', 'r') as f:\nprint(f.read())\n</code></pre> Text Only<pre><code>element Mass 16 2 2.0833e-04 1 2\nelement Mass 17 6 4.1667e-04 1 2\nelement Mass 18 10 2.0833e-04 1 2\nelement Mass 19 3 2.0833e-04 1 2\nelement Mass 20 7 4.1667e-04 1 2\nelement Mass 21 11 2.0833e-04 1 2\nelement Mass 22 4 2.0833e-04 1 2\nelement Mass 23 8 4.1667e-04 1 2\nelement Mass 24 12 2.0833e-04 1 2\n</code></pre>"},{"location":"Example/Structural/Dynamics/integrating-preprocessing-with-python/#analysis-settings","title":"Analysis Settings","text":"<p>The basic geometry of the model is defined in <code>node.sp</code>, <code>beam.sp</code>, <code>column.sp</code> and <code>mass.sp</code>. We import those files in the main script.</p> Python<pre><code>file_list = ['node.sp', 'beam.sp', 'column.sp', 'mass.sp']\nmain_file = open('three-storey-frame.sp', 'w')\nfor file in file_list:\nmain_file.write(f'file {file}\\n')\n</code></pre> <p>The boundary conditions can be assigned by simply fixing all bottom nodes.</p> Python<pre><code>main_file.write(f'fix 1 P 1 {\" \".join(str(tag) for tag in node_grid[0, :])}\\n')\npass\n</code></pre> <p>The ground motion shall be applied. The <code>ELNS</code> file contains one of the accelerograms of the 1940 El Centro Earthquake. It is normalised so that the maximum amplitude is unity, we assign a PGA of \\(\\(0.5g\\)\\).</p> Python<pre><code>pga = .5\nmain_file.write(f'\\namplitude Tabular 1 ELNS\\n')\n# 1 g = 386.0885826772 in/s2\nmain_file.write(f'\\nacceleration 1 1 {386.0885826772 * pga:.5e} 1\\n')\npass\n</code></pre> <p>For results, we can, for example, record the nodal displacement history.</p> Python<pre><code>recorder_tag = 1\nmain_file.write(f'\\nhdf5recorder {recorder_tag} Node U ' + ' '.join([str(tag) for tag in node_pool.keys()]) + '\\n')\npass\n</code></pre> <p>For illustration, we can also record element yield flag at both ends so that the corresponding plastic hinge distribution can be generated. The yield flag is not generally available in other elements.</p> Python<pre><code>recorder_tag += 1\nmain_file.write(\nf'\\nhdf5recorder {recorder_tag} Element YF ' + ' '.join([str(tag) for tag in element_pool.keys()]) + '\\n')\npass\n</code></pre> <p>We keep writing dynamic analysis step and the corresponding settings into the file.</p> Python<pre><code># dynamic step\nduration = 40.\ntime_step = 1E-2\nmain_file.write(f'\\nstep dynamic 1 {duration:.3e}\\n')\nmain_file.write(f'set ini_step_size {time_step:.2e}\\n')\nmain_file.write('set fixed_step_size true\\n')\nmain_file.write('set sparse_mat true\\n')\nmain_file.write('set system_solver SuperLU\\n\\n')\nmain_file.write('converger AbsIncreDisp 1 1E-10 10 true\\n\\n')\n# damping model\nmain_file.write('integrator LeeNewmarkFull 1 .25 .5 \\\\\\n'\n'-type0 2.66040e-02 1.87264e-01 \\\\\\n'\n'-type0 2.66170e-02 5.30209e+00 \\\\\\n'\n'-type0 2.66310e-02 2.82431e+01 \\\\\\n'\n'-type0 2.70320e-02 1.51584e+02 \\\\\\n'\n'-type0 2.65990e-02 9.96227e-01 \\\\\\n'\n'-type0 3.90780e-02 1.00100e-03 \\\\\\n'\n'-type0 2.70050e-02 6.56300e-03 \\\\\\n'\n'-type0 2.66190e-02 3.51830e-02 \\\\\\n'\n'-type0 3.91040e-02 9.95802e+02\\n')\nmain_file.write('\\nanalyze\\n')\nmain_file.write(f'\\nsave recorder {\" \".join([str(tag + 1) for tag in range(recorder_tag)])}\\n')\nmain_file.write('\\nexit\\n')\npass\n</code></pre> <p>Do not forget to close the main file.</p> Python<pre><code>main_file.close()\nwith open('three-storey-frame.sp', 'r') as f:\nprint(f.read())\n</code></pre> Text Only<pre><code>file node.sp\nfile beam.sp\nfile column.sp\nfile mass.sp\nfix 1 P 1 1 5 9\n\namplitude Tabular 1 ELNS\n\nacceleration 1 1 1.93044e+02 1\n\nhdf5recorder 1 Node U 1 2 3 4 5 6 7 8 9 10 11 12\n\nhdf5recorder 2 Element YF 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\n\nstep dynamic 1 4.000e+01\nset ini_step_size 1.00e-02\nset fixed_step_size true\nset sparse_mat true\nset system_solver SuperLU\n\nconverger AbsIncreDisp 1 1E-10 10 true\n\nintegrator LeeNewmarkFull 1 .25 .5 \\\n-type0 2.66040e-02 1.87264e-01 \\\n-type0 2.66170e-02 5.30209e+00 \\\n-type0 2.66310e-02 2.82431e+01 \\\n-type0 2.70320e-02 1.51584e+02 \\\n-type0 2.65990e-02 9.96227e-01 \\\n-type0 3.90780e-02 1.00100e-03 \\\n-type0 2.70050e-02 6.56300e-03 \\\n-type0 2.66190e-02 3.51830e-02 \\\n-type0 3.91040e-02 9.95802e+02\n\nanalyze\n\nsave recorder 1 2\n\nexit\n</code></pre> <p>Finally, let's pack everything into an archive so that it can be downloaded.</p> Python<pre><code>import os\nfrom zipfile import ZipFile\nfile_list.append('fibre_frame.sp')\nfile_list.append('three-storey-frame.sp')\nfile_list.append('ELNS')\nwith ZipFile('three-storey-frame.zip', 'w') as f:\nfor file in file_list:\nf.write(file)\n</code></pre>"},{"location":"Example/Structural/Dynamics/integrating-preprocessing-with-python/#run-analysis","title":"Run Analysis","text":"<p>The analysis can be run by calling the executable.</p> <p>The online documentation is not calling the executable, but it is possible to run the analysis locally with the application available.</p> Python<pre><code>from shutil import which\ndef run_analysis():\nif os.name == 'nt':\nexe_name = 'suanPan.exe'\nelse:\nexe_name = 'suanpan'\nif which(exe_name):\nos.system(f'{exe_name} -np -f three-storey-frame.sp')\nrun_analysis()\n</code></pre>"},{"location":"Example/Structural/Dynamics/integrating-preprocessing-with-python/#roof-displacement-history","title":"Roof Displacement History","text":"<p>The result file will be generated and stored in <code>.h5</code> file. We can read the file and plot the results.</p> Python<pre><code>import h5py\nimport matplotlib.pyplot as plt\nimport glob\ndef plot_result():\nh5_file = glob.glob('*U.h5')\nif len(h5_file) == 0:\nreturn\nplt.figure(figsize=(10, 7))\nwith h5py.File(h5_file[0], 'r') as result_file:\nfor group in result_file.values():\nfor key, data in group.items():\nplt.plot(data[:, 0], data[:, 1] / max(y_coor) * 100., label=key)\nplt.xlabel('Time (s)')\nplt.ylabel('Drift (%)')\nplt.legend()\nplt.show()\nplot_result()\n</code></pre> <p></p> <p>Clean up the files to end this example.</p> Python<pre><code>for file in file_list:\nif file == 'ELNS':\ncontinue\nif os.path.exists(file):\nos.remove(file)\n</code></pre> <p>Let's create some TikZ commands to be used to plot plastic hinge distribution.</p> Python<pre><code>tikz: list = []\n# generate coordinates to represent nodal positions\nfor node in node_pool.values():\ntikz.append(f'\\\\coordinate(N{node.tag})at({node.x / 1E2},{node.y / 1E2});')\n# draw frame elements\nfor element in element_pool.values():\nnode_i = element.node_i\nnode_j = element.node_j\nif node_i.x == node_j.x:\n# vertical columns\ntikz.append(\nf'\\\\draw[line width=1mm](N{element.node_i.tag})--(N{element.node_j.tag})node[midway,fill=white,font=\\\\tiny,rotate=90]{{{element.section.name}}};')\nelse:\n# horizontal beams\ntikz.append(\nf'\\\\draw[line width=1mm](N{element.node_i.tag})--(N{element.node_j.tag})node[midway,fill=white,font=\\\\tiny]{{{element.section.name}}};')\nhinge_label = '[fill=red,circle,draw,inner sep=0,minimum size=3mm]'\nh5_file = glob.glob('*YF.h5')\nif len(h5_file) &gt; 0:\nwith h5py.File(h5_file[0], 'r') as h_file:\nh5_prefix = h5_file[0].split('.')[0]\nfor g in h_file.values():\nfor k, v in g.items():\nelement_tag = int(k.replace(h5_prefix, ''))\nnode_i = element_pool[element_tag].node_i.tag\nnode_j = element_pool[element_tag].node_j.tag\nif v[:, 1].max() &gt; .5:\ntikz.append(f'\\\\node{hinge_label}at($(N{node_i})!.1!(N{node_j})$){{}};')\nif v[:, 2].max() &gt; .5:\ntikz.append(f'\\\\node{hinge_label}at($(N{node_i})!.9!(N{node_j})$){{}};')\nwith open(f'DIST.tex', 'w') as f:\nf.write('\\\\begin{tikzpicture}[scale=2]\\n')\nf.write('\\n'.join(tikz))\nf.write('\\n\\\\end{tikzpicture}\\n')\nwith open(f'DIST.tex', 'r') as f:\nprint(f.read())\n</code></pre> Text Only<pre><code>\\begin{tikzpicture}[scale=2]\n\\coordinate(N1)at(0.0,0.0);\n\\coordinate(N2)at(0.0,1.2);\n\\coordinate(N3)at(0.0,2.4);\n\\coordinate(N4)at(0.0,3.6);\n\\coordinate(N5)at(2.4,0.0);\n\\coordinate(N6)at(2.4,1.2);\n\\coordinate(N7)at(2.4,2.4);\n\\coordinate(N8)at(2.4,3.6);\n\\coordinate(N9)at(4.8,0.0);\n\\coordinate(N10)at(4.8,1.2);\n\\coordinate(N11)at(4.8,2.4);\n\\coordinate(N12)at(4.8,3.6);\n\\draw[line width=1mm](N2)--(N6)node[midway,fill=white,font=\\tiny]{W21X68};\n\\draw[line width=1mm](N6)--(N10)node[midway,fill=white,font=\\tiny]{W21X68};\n\\draw[line width=1mm](N3)--(N7)node[midway,fill=white,font=\\tiny]{W21X68};\n\\draw[line width=1mm](N7)--(N11)node[midway,fill=white,font=\\tiny]{W21X68};\n\\draw[line width=1mm](N4)--(N8)node[midway,fill=white,font=\\tiny]{W21X68};\n\\draw[line width=1mm](N8)--(N12)node[midway,fill=white,font=\\tiny]{W21X68};\n\\draw[line width=1mm](N1)--(N2)node[midway,fill=white,font=\\tiny,rotate=90]{W14X193};\n\\draw[line width=1mm](N5)--(N6)node[midway,fill=white,font=\\tiny,rotate=90]{W14X193};\n\\draw[line width=1mm](N9)--(N10)node[midway,fill=white,font=\\tiny,rotate=90]{W14X193};\n\\draw[line width=1mm](N2)--(N3)node[midway,fill=white,font=\\tiny,rotate=90]{W14X159};\n\\draw[line width=1mm](N6)--(N7)node[midway,fill=white,font=\\tiny,rotate=90]{W14X159};\n\\draw[line width=1mm](N10)--(N11)node[midway,fill=white,font=\\tiny,rotate=90]{W14X159};\n\\draw[line width=1mm](N3)--(N4)node[midway,fill=white,font=\\tiny,rotate=90]{W14X159};\n\\draw[line width=1mm](N7)--(N8)node[midway,fill=white,font=\\tiny,rotate=90]{W14X159};\n\\draw[line width=1mm](N11)--(N12)node[midway,fill=white,font=\\tiny,rotate=90]{W14X159};\n\\node[fill=red,circle,draw,inner sep=0,minimum size=3mm]at($(N2)!.1!(N6)$){};\n\\node[fill=red,circle,draw,inner sep=0,minimum size=3mm]at($(N2)!.9!(N6)$){};\n\\node[fill=red,circle,draw,inner sep=0,minimum size=3mm]at($(N7)!.9!(N8)$){};\n\\node[fill=red,circle,draw,inner sep=0,minimum size=3mm]at($(N6)!.1!(N10)$){};\n\\node[fill=red,circle,draw,inner sep=0,minimum size=3mm]at($(N6)!.9!(N10)$){};\n\\node[fill=red,circle,draw,inner sep=0,minimum size=3mm]at($(N3)!.1!(N7)$){};\n\\node[fill=red,circle,draw,inner sep=0,minimum size=3mm]at($(N3)!.9!(N7)$){};\n\\node[fill=red,circle,draw,inner sep=0,minimum size=3mm]at($(N7)!.1!(N11)$){};\n\\node[fill=red,circle,draw,inner sep=0,minimum size=3mm]at($(N7)!.9!(N11)$){};\n\\node[fill=red,circle,draw,inner sep=0,minimum size=3mm]at($(N4)!.1!(N8)$){};\n\\node[fill=red,circle,draw,inner sep=0,minimum size=3mm]at($(N8)!.9!(N12)$){};\n\\node[fill=red,circle,draw,inner sep=0,minimum size=3mm]at($(N1)!.1!(N2)$){};\n\\node[fill=red,circle,draw,inner sep=0,minimum size=3mm]at($(N5)!.1!(N6)$){};\n\\node[fill=red,circle,draw,inner sep=0,minimum size=3mm]at($(N9)!.1!(N10)$){};\n\\end{tikzpicture}\n</code></pre>"},{"location":"Example/Structural/Dynamics/mass-spring-dashpot-system/","title":"[\u2605\u2605\u2606\u2606\u2606] Mass-Spring-Dashpot System","text":"<p>This example is taken from the ABAQUS benchmark manual, see section 2.6.1. The original problem is also reported in the research paper, see 10.1002/nme.1620170902.</p> <p>The model can be downloaded.</p>"},{"location":"Example/Structural/Dynamics/mass-spring-dashpot-system/#the-system","title":"The System","text":"<p>The configuration of the model is shown below.</p> <p></p>"},{"location":"Example/Structural/Dynamics/mass-spring-dashpot-system/#numerical-model","title":"Numerical Model","text":""},{"location":"Example/Structural/Dynamics/mass-spring-dashpot-system/#nodes","title":"Nodes","text":"<p>There are two DoFs in the system, two masses are connected to fixed points via nonlinear elastic springs. In order to do so, we define four nodes.</p> Text Only<pre><code>node 1 0 0\nnode 2 1 0\nnode 3 2 0\nnode 4 3 0\n</code></pre> <p>Here we use unit distance between two adjacent nodes. If the elements used are based on strain and strain rate, the unit distance is the only correct choice. If the elements used are based on displacement and velocity, the unit distance is not a must.</p>"},{"location":"Example/Structural/Dynamics/mass-spring-dashpot-system/#materials","title":"Materials","text":"<p>The left spring uses a \\(\\(\\tanh\\)\\) function. To model it, we use Tanh1D material.</p> Text Only<pre><code>material Tanh1D 1 1000\n</code></pre> <p>The right spring uses a \\(\\(\\sinh\\)\\) function. To model it, we use Sinh1D material.</p> Text Only<pre><code>material Sinh1D 3 1000\n</code></pre> <p>The middle spring is a linear spring, we simply use Elastic1D material.</p> Text Only<pre><code>material Elastic1D 2 100\n</code></pre> <p>The dashpot is linear. We use \\(\\(\\alpha=1\\)\\) in Viscosity01 material. The viscosity coefficient is \\(\\(5\\)\\).</p> Text Only<pre><code>material Viscosity01 4 1 5\n</code></pre>"},{"location":"Example/Structural/Dynamics/mass-spring-dashpot-system/#elements","title":"Elements","text":"<p>The springs can be modelled by using either T2D2, which uses strain and strain rate as the basic quantities, or Spring01, which uses displacement and velocity as the basic quantities.</p> Text Only<pre><code>element Spring01 1 1 2 1\nelement Spring01 2 2 3 2\nelement Spring01 3 3 4 3\n</code></pre> <p>For a linear dashpot, we use Damper01.</p> Text Only<pre><code>element Damper01 4 2 3 4\n</code></pre> <p>In addition to the above, it is necessary to define two mass elements.</p> Text Only<pre><code>mass 5 2 1 1\nmass 6 3 1 1\n</code></pre>"},{"location":"Example/Structural/Dynamics/mass-spring-dashpot-system/#ibc","title":"IBC","text":"<p>The vertical DoFs of all nodes shall be fixed. The horizontal DoFs of the first and last nodes shall be fixed.</p> Text Only<pre><code>fix2 1 1 1 4\nfix2 2 2 1 2 3 4\n</code></pre> <p>The initial condition can be applied to node 2 via</p> Text Only<pre><code>initial velocity 100 1 2\n</code></pre>"},{"location":"Example/Structural/Dynamics/mass-spring-dashpot-system/#load","title":"Load","text":"<p>To apply a step load, one shall use tabular amplitude to define the load curve. The following table can be stored in file <code>h</code>.</p> Text Only<pre><code>0 0\n0.499999999999 0\n0.5 1\n0.55 1\n0.550000000001 0\n100 0\n</code></pre> <p>Then the load can be applied such that</p> Text Only<pre><code>amplitude Tabular 1 h\n\ncload 1 1 3000 1 3\n</code></pre>"},{"location":"Example/Structural/Dynamics/mass-spring-dashpot-system/#response","title":"Response","text":"<p>To record response, we define two recorders, one for displacement, one for velocity.</p> Text Only<pre><code>hdf5recorder 1 Node U1 2 3\nhdf5recorder 2 Node V1 2 3\n</code></pre>"},{"location":"Example/Structural/Dynamics/mass-spring-dashpot-system/#step-and-analysis","title":"Step and Analysis","text":"<p>The remaining settings are pretty standard. We use a dynamic step with a default integration scheme (Newmark). If one wishes, other integration schemes can be used.</p> Text Only<pre><code>step dynamic 1 1\nset ini_step_size 1E-3\nset fixed_step_size 1\n\nconverger RelIncreDisp 1 1E-11 10 1\n\nanalyze\n\nsave recorder 1 2\n\nexit\n</code></pre>"},{"location":"Example/Structural/Dynamics/mass-spring-dashpot-system/#results","title":"Results","text":"<p>One could compare the results with the original results in the paper.</p> <p></p> <p></p>"},{"location":"Example/Structural/Dynamics/multi-support-excitation/","title":"[\u2605\u2605\u2606\u2606\u2606] Multi-Support Excitation","text":"<p>In this example, we illustrate how to perform response history analysis with multiple support excitations.</p> <p>The model can be downloaded here.</p> <p>The multiple support excitation refers to different prescribed motions at various supports. The general discussion of linear elastic systems, as presented in typical textbooks (see for example Chopra, Dynamics of Structures, 5th Edition | Pearson) , is somehow not suitable to numerical implementation.</p> <p>The implementation in <code>suanPan</code> converts whatever support excitations applied to prescribed displacements and the displacement controlled algorithm <code>MPDC</code> is automatically enabled to solve the system.</p> <p>Thus, support excitations in forms of displacement, velocity and acceleration are supported.</p>"},{"location":"Example/Structural/Dynamics/multi-support-excitation/#a-simple-model","title":"A Simple Model","text":"<p>Here we first create a simple cantilever beam with additional point mass at the free end. The basic geometry related commands are stored in file <code>geometry.sp</code>.</p> Text Only<pre><code># geometry.sp\n\nnode 1 0 0\nnode 2 0 1\n\nmaterial Elastic1D 1 100 .1\n\nsection Rectangle2D 1 12 1 1\n\nelement B21 1 1 2 1 6\n\nmass 2 2 10 1\n\nhdf5recorder 1 Node U1 1 2\n\namplitude Tabular 1 EZ\n</code></pre> <p>The analysis setting consists of a dynamic step with <code>Newmark</code> integrator. Those settings are stored in <code>setting.sp</code> file.</p> Text Only<pre><code># setting.sp\n\nstep dynamic 1 30\nset ini_step_size 1E-2\nset fixed_step_size true\n\nintegrator Newmark 1\n\nconverger RelIncreDisp 1 1E-10 4 1\n\nanalyze\n\nsave recorder 1\n\nexit\n</code></pre>"},{"location":"Example/Structural/Dynamics/multi-support-excitation/#apply-excitation-on-all-nodes","title":"Apply Excitation On All Nodes","text":"<p>To apply acceleration excitation on all nodes, the boundary conditions need to be assigned in a normal, conventional way so that no rigid body motion is allowed.</p> Text Only<pre><code>file geometry.sp\n\nfix 1 P 1\n\n# on DoF 1 node 2\nacceleration 2 1 -.2 1 2\n\nfile setting.sp\n</code></pre> <p>It shall be noted \\(-\\ddot{u}_g\\) is applied.</p>"},{"location":"Example/Structural/Dynamics/multi-support-excitation/#apply-excitation-on-support","title":"Apply Excitation On Support","text":"<p>To apply acceleration excitation on support, the corresponding DoF should not be constrained. Thus, rigid body motions are expected.</p> Text Only<pre><code>file geometry.sp\n\nfix 1 2 1\nfix 2 3 1\n\n# on DoF 1 node 1\nsupportacceleration 2 1 .2 1 1\n\nfile setting.sp\n</code></pre> <p>Now it is ready to perform the analysis.</p>"},{"location":"Example/Structural/Dynamics/multi-support-excitation/#result","title":"Result","text":"<p>Here the displacement of the free end is plotted.</p> <p></p> <p>It shall be noted that since rigid body motions are present when excitations are applied to the supports, the relative displacement needs to be obtained by computing the difference between displacements of target DoF and support.</p>"},{"location":"Example/Structural/Dynamics/particle-collision/","title":"[\u2605\u2605\u2605\u2605\u2606] Simulation of Particle Collision","text":"<p>In this example, we illustrate the contact problem by simulating a 2D particle collision problem. The model can be downloaded here.</p>"},{"location":"Example/Structural/Dynamics/particle-collision/#general-information","title":"General Information","text":"<p>The container is assumed to be a square with edge length of \\(\\(10\\)\\). A certain number of nodes are randomly generated within the container with randomly generated initial velocities. A small program is written to generate the model script. One could compile the <code>Generator.cpp</code> file and run it with the number of particles needed. For example,</p> Bash<pre><code>g++ -o Generator.exe Generator.cpp\nGenerator.exe 20\n</code></pre> <p>The model file will be generated as <code>Collision.supan</code>.</p>"},{"location":"Example/Structural/Dynamics/particle-collision/#collision","title":"Collision","text":"<p>The collision force \\(\\(F\\)\\) is assumed to be a function of distance \\(\\(d\\)\\) between two particles.</p> \\[ F(d)=\\alpha\\ln\\left(\\dfrac{d}{s}\\right), \\] <p>where \\(\\(s\\)\\) is the approximate size of particles, \\(\\(\\alpha\\)\\) is a factor that can be used to adjust response. To define such a collision, one can use</p> Text Only<pre><code>particlecollision2d 1 2.\n</code></pre> <p>in which \\(\\(s=2\\)\\) and \\(\\(\\alpha\\)\\) is defaulted to be unity.</p>"},{"location":"Example/Structural/Dynamics/particle-collision/#container-boundary","title":"Container Boundary","text":"<p>The four edges of the container can be assigned by using the rigid wall constraint. For example,</p> Text Only<pre><code>rigidwall 2 5 0 -1 0\nrigidwall 3 0 5 0 -1\nrigidwall 4 -5 0 1 0\nrigidwall 5 0 -5 0 1\n</code></pre>"},{"location":"Example/Structural/Dynamics/particle-collision/#other-caveats","title":"Other Caveats","text":"<p>It shall be noted that a full matrix storage scheme shall be enabled to perform a collision simulation, since any two particles can collide with each other based on different initial conditions, there is no way to obtain a sparse/banded matrix in advance.</p> Text Only<pre><code>set band_mat false\nset symm_mat false\n</code></pre>"},{"location":"Example/Structural/Dynamics/particle-collision/#output","title":"Output","text":"<p>The global kinetic energy can be recorded by using</p> Text Only<pre><code>hdf5recorder 1 Global KE\n</code></pre> <p>Besides, it may be helpful to visualize the collision progress, to do that, a <code>Visualisation</code> recorder can be defined.</p> Text Only<pre><code>hdf5recorder 2 Visualisation U every 20 width 4\n</code></pre>"},{"location":"Example/Structural/Dynamics/particle-collision/#result","title":"Result","text":"<p>The kinetic energy history is obtained as follows. It can be seen that the total energy level is increasing with the number of collisions. The parameters can be further adjusted for more realistic results. Here the model is presented for the purpose of illustration.</p> <p></p> <p>The animation is presented as follows.</p> <p></p>"},{"location":"Example/Structural/Dynamics/response-history-analysis-of-an-elastic-coupled-wall/","title":"[\u2605\u2605\u2605\u2606\u2606] Response History Analysis of An Elastic Coupled Wall","text":"<p>In this page, we perform eigen analysis and response history analysis of an elastic coupled wall model.</p> <p>The wall model is a simplified version of the example shown in section 7.2 of this paper: 10.1016/j.engstruct.2020.110760.</p> <p>The model can be downloaded.</p>"},{"location":"Example/Structural/Dynamics/response-history-analysis-of-an-elastic-coupled-wall/#model-brief","title":"Model Brief","text":"<p>The geometry is summarized in the following figure.</p> <p></p> <p>Definitions of nodes, elements, materials, boundary conditions are stored in <code>node.supan</code> and <code>element.supan</code>. Use proper commands to load files.</p> Text Only<pre><code>file node.supan\nfile element.supan\n</code></pre>"},{"location":"Example/Structural/Dynamics/response-history-analysis-of-an-elastic-coupled-wall/#eigen-analysis","title":"Eigen Analysis","text":"<p>Before performing the eigen analysis, the system is double-checked to be symmetric. In fact, as eigen analysis is normally conducted on elastic structures, which are most likely to be symmetric, it is in general not problematic as long as elasto-plastic behavior is not involved.</p> <p>Now we define a <code>Frequency</code> step to compute ten eigenvalues of the generalized eigen problem.</p> Text Only<pre><code>step Frequency 1 10\n</code></pre> <p>Invoke analysis and check the eigenvalues.</p> Text Only<pre><code>peek eigenvalue\n</code></pre> <p>The output is shown as follows.</p> Text Only<pre><code>Eigenvalues:\n   3.6759e+02\n   1.1518e+04\n   4.3152e+04\n   6.0047e+04\n   6.8965e+04\n   1.1525e+05\n   1.8269e+05\n   2.2550e+05\n   3.0590e+05\n   3.1665e+05\n</code></pre> <p>Thus, the period of the first mode can be computed as</p> \\[ t_1=\\dfrac{2\\pi}{\\omega}=\\dfrac{2\\pi}{\\sqrt{367.59}}\\approx0.33~\\mathrm{s}. \\]"},{"location":"Example/Structural/Dynamics/response-history-analysis-of-an-elastic-coupled-wall/#response-history-analysis","title":"Response History Analysis","text":""},{"location":"Example/Structural/Dynamics/response-history-analysis-of-an-elastic-coupled-wall/#ground-motion","title":"Ground Motion","text":"<p>We use one of the recordings of 2011 Christchurch Earthquake, the original raw recording can be obtained from this page. Please check NZStrongMotion for more details. The chosen record has a tag of <code>20110221_235142_LPCC</code>, the PGA is \\(\\(8.91~\\mathrm{m/s^2}\\)\\).</p> <p>After downloading the processed recording file, the following command can be used to define the amplitude.</p> Text Only<pre><code>amplitude NZStrongMotion 1 20110221_235142_LPCC\n</code></pre> <p>The acceleration is applied to the structure, note <code>NZStrongMotion</code> produces normalized (dimensionless) amplitudes, to apply an accelerogram of target PGA, the corresponding magnitude shall be adjusted to be equal to that PGA. In this example, we assign a PGA of \\(\\(0.4g\\)\\).</p> Text Only<pre><code>acceleration 1 1 3.92 1\n</code></pre>"},{"location":"Example/Structural/Dynamics/response-history-analysis-of-an-elastic-coupled-wall/#damping-model","title":"Damping Model","text":"<p>The Lee's damping model is chosen as an illustration. Knowing that \\(\\(\\omega_1=\\sqrt{367.59}=19.17~\\mathrm{rad/s}\\)\\), we assign a single basic function at \\(\\(\\omega_1\\)\\) with \\(\\(5\\%\\)\\) damping ratio.</p> Text Only<pre><code>integrator LeeNewmark 1 .25 .5 .05 19.17\n</code></pre>"},{"location":"Example/Structural/Dynamics/response-history-analysis-of-an-elastic-coupled-wall/#other-settings","title":"Other Settings","text":"<p>We define a dynamic step and perform the analysis with the time step of \\(\\(0.005~\\mathrm{s}\\)\\) for \\(\\(60~\\mathrm{s}\\)\\).</p> Text Only<pre><code>step dynamic 1 60\nset ini_step_size 5E-3\nset fixed_step_size 1\n\nintegrator LeeNewmark 1 .25 .5 .05 19.17\n\nconverger RelIncreDisp 1 1E-8 10 1\n\nanalyze\n</code></pre>"},{"location":"Example/Structural/Dynamics/response-history-analysis-of-an-elastic-coupled-wall/#some-stats","title":"Some Stats","text":"<p>This example consists of \\(\\(83\\)\\) nodes, equivalent to \\(\\(249\\)\\) DoFs. With one basic function used in the damping model, the size of matrix solved is about \\(\\(500\\times500\\)\\). On recent machines, the response history analysis can be done within one minute. The solving time increases almost linearly with an increasing number of basic functions used in the damping model.</p>"},{"location":"Example/Structural/Dynamics/response-history-analysis-of-an-elastic-coupled-wall/#result","title":"Result","text":"<p>We show roof displacement history to close this example.</p> <p></p>"},{"location":"Example/Structural/Dynamics/triple-pendulum/","title":"[\u2605\u2605\u2605\u2605\u2606] Triple Pendulum","text":"<p>Minimum version: v2.4</p> <p>The model can be downloaded here.</p> <p>The main purpose of this example is two-fold:</p> <ol> <li>to illustrate how a dynamic system can be analysed, and</li> <li>to show different performance of different time integration methods.</li> </ol>"},{"location":"Example/Structural/Dynamics/triple-pendulum/#model","title":"Model","text":"<p>Such a model for pendulum can be established using two main approaches. As a triple pendulum, the model has four nodes.</p> Text Only<pre><code>node 1 0 0\nnode 2 0 -2\nnode 3 0 -3\nnode 4 0 -5\n\nfix2 1 P 1\n</code></pre> <p>The first node is pinned so that it does not move.</p>"},{"location":"Example/Structural/Dynamics/triple-pendulum/#with-rigid-links","title":"With Rigid Links","text":"<p>By using rigid truss elements, the inextensible links can be approximated given that if the rigidity is sufficiently large. Define the corresponding truss elements and point masses. Note here since the fixed node <code>1</code> is connected to the truss element <code>1</code>, there is no need to assign mass to it.</p> Text Only<pre><code># with rigid links\nmaterial Elastic1D 1 1E7\n\nelement T2D2 1 1 2 1 1 true\nelement T2D2 2 2 3 1 1 true\nelement T2D2 3 3 4 1 1 true\n\nelement Mass 4 2 20 1 2\nelement Mass 5 3 10 1 2\nelement Mass 6 4 20 1 2\n</code></pre> <p>Note the nonlinear geometry switch is on to account for large displacement (but still small deformation).</p>"},{"location":"Example/Structural/Dynamics/triple-pendulum/#with-constraints","title":"With Constraints","text":"<p>Alternatively, the <code>FixedLength</code> constraint can be used to apply the inextensible constraints.</p> Text Only<pre><code>constraint FixedLength2D 10 1 2\nconstraint FixedLength2D 11 2 3\nconstraint FixedLength2D 12 3 4\n\nelement Mass 1 1 1 1 2 ! important\nelement Mass 2 2 20 1 2\nelement Mass 3 3 10 1 2\nelement Mass 4 4 20 1 2\n</code></pre> <p>Note here, compared to the previous approach, since the fixed node <code>1</code> is now not connected to any truss elements,  it will be associated to nothing if no point mass is assigned to it. This is not allowed. Such an 'isolated' dummy  node will be identified and automatically disabled during the initialisation stage. In order to avoid this, it is  necessary to assign a point mass to it.</p>"},{"location":"Example/Structural/Dynamics/triple-pendulum/#initial-conditions-and-other-setup","title":"Initial Conditions and Other Setup","text":"<p>An initial velocity is assigned to node <code>3</code>.</p> Text Only<pre><code>initial velocity 25 1 3\n</code></pre> <p>The gravity load is assigned in form of constant force.</p> Text Only<pre><code>amplitude Constant 1\ncload 1 1 -200 2 2\ncload 2 1 -100 2 3\ncload 3 1 -200 2 4\n</code></pre> <p>There is no essential difference whether to assign the gravity load to node <code>1</code> as it is fixed. The applied load  will be balanced out by the resistance. This only affects how the results shall be processed.</p>"},{"location":"Example/Structural/Dynamics/triple-pendulum/#analyse","title":"Analyse","text":"<p>The analysis is performed with the Newmark integration method.</p> Text Only<pre><code>step dynamic 1 100\nset ini_step_size 1E-3\nset fixed_step_size 1\nset symm_mat 0\n\nintegrator Newmark 1\n\nconverger AbsIncreDisp 1 1E-10 10 1\n\nanalyze\n</code></pre>"},{"location":"Example/Structural/Dynamics/triple-pendulum/#results","title":"Results","text":"<p>The animation is presented as follows.</p> <p></p>"},{"location":"Example/Structural/Dynamics/triple-pendulum/#whats-next","title":"What's Next?","text":"<p>Everything seems to be working fine, which appears to be good. So what's next? If the results are carefully examined, one would notice some unexpected behaviour. For ones who have a good background of dynamics, it must be noticed that  he Newmark method has no algorithmic damping. It is also not ideal in terms of energy/momentum conservation.</p> <p>If one plots the acceleration history, one can notice that the acceleration is not physically meaningful.</p> <p></p> <p>Given that the Newmark method has no algorithmic damping, the high frequency noise cannot be suppressed. Try the extra  two models using <code>BatheTwoStep</code> and <code>GSSSS</code> methods in the archive.</p> <p>If one instead uses the <code>GSSSS</code> method with identical spectral radii, which is  equivalent to the <code>generalised alpha</code> method, the acceleration  history can be plotted as follows.</p> <p></p> <p>All in all, as long as the system may result in high frequency response, the use of the Newmark method is discouraged.</p> <p>The high frequency response may stem from either very large stiffness or very small mass. The former case may happen  when parts of the system are very rigid. The application of penalty method often results in large stiffness  components. The latter case may happen when the mass is under integrated or even lumped. Both are somehow inevitable  in practical simulations. One shall consider other time integration methods to obtain more reliable results.</p>"},{"location":"Example/Structural/Hybrid/vibration-of-a-displaced-beam/","title":"[\u2605\u2605\u2605\u2606\u2606] Vibration of A Displaced Beam","text":"<p>We consider an analysis that combines both static and dynamic steps. A simple cantilever beam with point mass is displaced in the static step and released in the dynamic step.</p> <p>The model can be dowloaded.</p>"},{"location":"Example/Structural/Hybrid/vibration-of-a-displaced-beam/#model-definition","title":"Model Definition","text":"<p>First, we define two nodes at \\(\\((0,0)\\)\\) and \\(\\((1,0)\\)\\).</p> Text Only<pre><code>node 1 0 0\nnode 2 1 0\n</code></pre> <p>To simply the example, we use elastic material and the <code>EB21</code> element, so that there is no need to define beam sections. A point mass of magnitude of \\(\\(2\\)\\) is applied to node \\(\\(2\\)\\) DoF \\(\\(2\\)\\).</p> Text Only<pre><code>material Elastic1D 1 10\nelement EB21 1 1 2 12 1 1\nelement Mass 2 2 2 2\n</code></pre> <p>Then we fix point \\(\\(1\\)\\).</p> Text Only<pre><code>fix 1 P 1\n</code></pre> <p>We record the displacement of node \\(\\(2\\)\\) as the result.</p> Text Only<pre><code>hdf5recorder 1 Node U2 2\n</code></pre>"},{"location":"Example/Structural/Hybrid/vibration-of-a-displaced-beam/#static-step","title":"Static Step","text":"<p>For the static step, a displacement load is applied on node \\(\\(2\\)\\) DoF \\(\\(2\\)\\). The absolute increment displacement is tested for convergence.</p> Text Only<pre><code>step static 1 1\nset ini_step_size .1\n\ndisplacement 1 0 1 2 2\n\nconverger AbsIncreDisp 1 1E-8 3 1\n</code></pre>"},{"location":"Example/Structural/Hybrid/vibration-of-a-displaced-beam/#dynamic-step","title":"Dynamic Step","text":"<p>A dynamic step with step size of \\(\\(2\\)\\) can then be defined. There is no need to define any load in this step. The previous displacement load is by default active for only one step. Hence, in this dynamic step, the displacement load is automatically suspended. A default <code>Newmark</code> integrator will be automatically defined if there is no valid integrator.</p> Text Only<pre><code>step dynamic 2 2\nset ini_step_size .02\nset fixed_step_size 1\n\nconverger AbsIncreDisp 2 1E-8 3 1\n</code></pre>"},{"location":"Example/Structural/Hybrid/vibration-of-a-displaced-beam/#run-analysis","title":"Run Analysis","text":"Text Only<pre><code>analyze\n\nsave recorder 1\n\nexit\n</code></pre>"},{"location":"Example/Structural/Hybrid/vibration-of-a-displaced-beam/#result","title":"Result","text":"<p>The displacement history can be plotted as follows.</p> <p></p>"},{"location":"Example/Structural/IGA/linear-analysis-of-a-single-element/","title":"[\u2605\u2605\u2605\u2605\u2605] Linear Analysis of A Single Element","text":"<p>In this example, we show a very basic analysis using isogeometric analysis and compare the result with the traditional finite element analysis.</p> <p>The model can be downloaded here linear-analysis-of-a-single-element.zip.</p>"},{"location":"Example/Structural/IGA/linear-analysis-of-a-single-element/#geometry","title":"Geometry","text":"<p>We analyze a single quadrilateral element with arbitrary lengths of edges. For traditional finite element analysis that uses isoparametric mapping, it is required to define four nodes that represent the vertexes of the quadrilateral. For example,</p> Text Only<pre><code># FEA\nnode 1 0 0\nnode 2 .5 0\nnode 3 .75 1\nnode 4 0 1\n</code></pre> <p>For isogeometric analysis, the geometry is controlled by the control nodes, which form control polygon in higher dimensions. Since NURBS is used, for each control node, a weight shall be assigned. This means for an \\(\\(n\\)\\) dimensional problem, the control nodes shall have size of \\(\\(n+1\\)\\). In this 2D example, we use the same <code>node</code> command to define control nodes, the size shall be handled properly.</p> Text Only<pre><code># IGA\nnode 1 0 0 1\nnode 2 .5 0 1\nnode 3 .75 1 1\nnode 4 0 1 1\n</code></pre> <p>Here we use unity for all four nodes. For the geometry (linear) considered, NURBS falls back to B-Spline, which is sufficient.</p>"},{"location":"Example/Structural/IGA/linear-analysis-of-a-single-element/#element","title":"Element","text":"<p>In FEA, each element is defined by the nodes ordered anticlockwise. So to define a <code>CP4</code> element with unit thickness and material model with tag \\(\\(1\\)\\), the following command can be used.</p> Text Only<pre><code># FEA\nelement CP4 1 1 2 3 4 1 1\n</code></pre> <p>In IGA, a different strategy is used. Each patch that consists of a number of elements is considered as a giant element, hence the number of control nodes is not known in advance. Meanwhile, the knot vectors may have various lengths. In <code>suanPan</code>, a key-value style definition is used. Please refer to the corresponding page for more details of <code>PatchQuad</code> element. In this example, the following command is used. Please note the order of control nodes is different from that in FEA.</p> Text Only<pre><code>element PatchQuad 1 -node 1 2 4 3 -material 1 -thickness 1 -knotx 0 0 1 1 -knoty 0 0 1 1\n</code></pre>"},{"location":"Example/Structural/IGA/linear-analysis-of-a-single-element/#other-parts","title":"Other Parts","text":"<p>The rest of the model is pretty simple, as long as BCs and loads are defined, the model is ready to be analyzed.</p> Text Only<pre><code>fix 1 1 1\nfix 2 2 1 2\ncload 1 0 1 2 3 4\nstep static 1\nanalyze\nexit\n</code></pre>"},{"location":"Example/Structural/Optimization/evolutionary-structural-optimization/","title":"[\u2605\u2605\u2605\u2605\u2605] Evolutionary Structural Optimization of A Cantilever Beam","text":"<p>In this example, the optimization of a loaded panel is performed by using the BESO method. The model can be downloaded here.</p>"},{"location":"Example/Structural/Optimization/evolutionary-structural-optimization/#design-domain","title":"Design Domain","text":"<p>The design domain has a dimension of \\(\\(100\\times40\\)\\) with left side fully fixed. At the center of the right side, a point load is applied. The panel is discretized with \\(\\(4000\\)\\) <code>CP4</code> elements.</p> <p>The node and elements are defined in files <code>node.supan</code> and <code>element.supan</code>. They can be loaded.</p> Text Only<pre><code>file node.supan\nfile element.supan\n</code></pre> <p>The boundary condition is applied to a group that selects all nodes on \\(\\(x=0\\)\\).</p> Text Only<pre><code>generatebyrule nodegroup 1 1 1. 0.\ngroupmultiplierbc 1 P 1\n</code></pre>"},{"location":"Example/Structural/Optimization/evolutionary-structural-optimization/#the-optimization-step","title":"The Optimization Step","text":"<p>To perform structural optimization, a <code>Optimization</code> step needs to be defined.</p> Text Only<pre><code>step Optimization 1\n</code></pre> <p>To define a proper rule to update the model by adding/deleting elements, one can use the <code>StrainEnergyEvolution</code> criterion. The following command defines a strain energy based evolution rule with an increment step of \\(\\(2\\%\\)\\) to reach the final design level \\(\\(50\\%\\)\\), that is to remove \\(\\(50\\%\\)\\) elements.</p> Text Only<pre><code>criterion StrainEnergyEvolution 1 2 50 1 1 40\n</code></pre>"},{"location":"Example/Structural/Optimization/evolutionary-structural-optimization/#result","title":"Result","text":""},{"location":"Example/Structural/Statics/bending-of-a-cantilever-beam/","title":"[\u2605\u2605\u2605\u2605\u2606] Bending of A Cantilever Beam","text":"<p>In this example, we show the application of 3D beam elements <code>B31</code> and <code>F31</code> with corotational transformation <code>B3DC</code>.</p> <p>The model can be downloaded.</p>"},{"location":"Example/Structural/Statics/bending-of-a-cantilever-beam/#the-model","title":"The Model","text":"<p>A simple cantilever beam is bent at the free end. Since the load and displacements are normalised, geometry does not affect results. Here we simply choose the following parameters: beam length \\(\\(L=20\\)\\), section dimension \\(\\(b\\times{}h=2\\times2\\)\\) and elastic modulus \\(\\(E=10\\)\\).</p> <p>Here five elements are used. Consequently, six nodes shall be defined.</p> Text Only<pre><code>node 1 0 0 0\nnode 3 4 0 0\nnode 4 8 0 0\nnode 5 12 0 0\nnode 6 16 0 0\nnode 2 20 0 0\n</code></pre> <p>The <code>Rectangle3D</code> section can be used.</p> Text Only<pre><code>material Elastic1D 1 10\n# size 2x2 using material 1\nsection Rectangle3D 1 2 2 1\n</code></pre> <p>Assuming the beam is in the \\(\\(xy\\)\\) plane, then strong axis aligns with global \\(\\(z\\)\\). To define 3D beam elements, its section orientation shall be defined. The corotational formulation that supports nonlinear geometry is used.</p> Text Only<pre><code># defining local strong axis pointing to global (0 0 -1)\norientation B3DC 1 0 0 -1.\n</code></pre> <p>Now define the elements. Replacing <code>F31</code> with <code>B31</code> to use displacement based elements.</p> Text Only<pre><code>element F31 1 1 3 1 1 5 true\nelement F31 2 3 4 1 1 5 true\nelement F31 3 4 5 1 1 5 true\nelement F31 4 5 6 1 1 5 true\nelement F31 5 6 2 1 1 5 true\n</code></pre> <p>It is known from the beam theory that a perfect circle would be formed if the free end is applied with an out-of-plane moment of magnitude \\(\\(M=\\alpha{}M_0=\\alpha\\dfrac{2\\pi{}EI}{L}\\)\\) with load ratio \\(\\(\\alpha=1\\)\\), which can be computed to be 4.188790205. For two circles, \\(\\(\\alpha=2\\)\\).</p> <p>Next, we apply boundary condition and load, define recorders to record free end displacements.</p> Text Only<pre><code># E is the shortcut for (1 2 3 4 5 6) all six DoFs\nfix2 1 E 1\n\n# apply two circles\ncload 1 0 8.377580410 6 2\n\nplainrecorder 1 Node U1 2\nplainrecorder 2 Node U2 2\n</code></pre> <p>It shall be noted since nonlinear geometry is adopted, the stiffness may not be symmetric anymore, it is necessary to switch off symmetric matrix storage to ensure correct results are computed. Since not all nonlinear geometry problems are asymmetric, the program itself has no mechanism to check if it is appropriate to use symmetric/asymmetric storage.</p> Text Only<pre><code>step static 1\nset ini_step_size 1E-2\nset fixed_step_size true\n\nset symm_mat false ! important\n\nconverger RelIncreDisp 1 1E-8 10 1\n\nanalyze\n</code></pre>"},{"location":"Example/Structural/Statics/bending-of-a-cantilever-beam/#results","title":"Results","text":"<p>Normalised displacement components are shown in the following figure.</p> <p></p> <p>Since VTK does not have a proper cell type for beams, linear lines are used to represent beams. Here is the animation of deformation.</p> <p></p>"},{"location":"Example/Structural/Statics/bifurcation-of-a-cantilever-beam/","title":"[\u2605\u2605\u2605\u2606\u2606] Bifurcation of A Cantilever Beam","text":"<p>Here we run a full nonlinear geometry analysis of the cantilever beam shown in another page. Buckling Analysis of A Cantilever Beam</p> <p>To numerically run a bifurcation analysis, initial perturbation must be introduced. Either geometry imperfection or initial load can be applied. Here we use initial transverse load.</p> <p>Since the perturbation does not change its magnitude throughout the analysis procedure, we shall define a constant amplitude associated with the initial transverse load. The magnitude of the initial load shall be relatively small.</p> Text Only<pre><code>! load model geometry\nfile geometry.supan\n\n! a constant amplitude\namplitude Constant 1\n\n! define the transverse initial load\ncload 2 1 1E-4 2 6\n</code></pre> <p>We use arc length method to track the behavior, this is not necessary for this particular example as there is no snap-through nor snap-back. The reference load is applied on the free end. For stopping criterion, we use minimum displacement at the free end.</p> Text Only<pre><code>! reference load of magnitude -1 along DoF 1 of node 6\nstep arclength 1 6 1 -1\n\n! use asymmetric matrix storage\nset symm_mat 0\n\n! stop analysis when displacement DoF 1 of node 6 hit -10\ncriterion MinDisplacement 1 6 1 -10\n\nconverger AbsIncreDisp 1 1E-8 5 1\n\nanalyze\n\nexit\n</code></pre> <p>The response is shown as follows.</p> <p></p> <p>The buckling load is just under \\(\\(2.5\\)\\), agrees with the previous linear buckling analysis.</p>"},{"location":"Example/Structural/Statics/double-edge-notched-specimen/","title":"[\u2605\u2605\u2605\u2606\u2606] Double Edge Notched Specimen","text":"<p>The double edge notched specimen was investigated by Nooru-Mohamed (1992).</p> <p>This example is taken from the thesis. The details of the model can be seen in Section 6.3.</p> <p>The model can be downloaded here.</p>"},{"location":"Example/Structural/Statics/double-edge-notched-specimen/#model-setup","title":"Model Setup","text":"<p>The definitions of nodes and elements can be seen in <code>element_f.supan</code> and <code>node_f.supan</code>.</p> <p>To ease the work of defining boundary conditions and load, some node groups can be defined first.</p> <p>In total four edges will be used, here the <code>generatebypoint</code> command is used to find all relevant nodes.</p> Text Only<pre><code># find all nodes on the line segment defined by (0,0) and (200,0)\ngeneratebypoint nodegroup 1 0. 0. 200. 0.\n\n# find all nodes on the line segment defined by (200,0) and (200,100)\ngeneratebypoint nodegroup 2 200. 0. 200. 100.\n\n# find all nodes on the line segment defined by (0,200) and (200,200)\ngeneratebypoint nodegroup 3 0. 200. 200. 200.\n\n# find all nodes on the line segment defined by (0,100) and (0,200)\ngeneratebypoint nodegroup 4 0. 100. 0. 200.\n</code></pre> <p>The boundary conditions are explicitly assigned to the corresponding node groups.</p> Text Only<pre><code># for all four edges, the drilling DoFs are constrained\ngrouppenaltybc 1 3 1 2 3 4\n\n# constrain horizontal movement of edge 2\ngrouppenaltybc 2 1 2\n# constrain vertical movement of edge 1\ngrouppenaltybc 3 2 1\n</code></pre> <p>Two displacement loads are applied. Two files <code>h</code> and <code>v</code> are used to define the amplitudes.</p> Text Only<pre><code># horizontal dispalcement to generate a 5kN total horizontal tension force\namplitude Tabular 1 h\ngroupdisplacement 1 1 -16.5E-3 1 4\n\namplitude Tabular 2 v\ngroupdisplacement 2 2 .1 2 3\n</code></pre> <p>If VTK is enabled, it is possible to record the distribution of tension damage at each converged substep.</p> Text Only<pre><code>hdf5recorder 1 Visualisation KAPPAT width 3 scale 0\n</code></pre> <p>Since we are not interested in the displacement, <code>scale</code> is simply set to zero. The output file are automatically numbered with a total width of four. It is changed to three in this example. The generated <code>.vtk</code> files can be loaded into ParaView as a group to generate animations.</p> <p>The analysis has a duration of two seconds. In the first second, the horizontal tension is applied, then the vertical load is applied.</p> Text Only<pre><code>step static 1 2\nset fixed_step_size 1\nset ini_step_size 5E-3\n\nconverger RelIncreDisp 1 1E-4 20 1\n</code></pre>"},{"location":"Example/Structural/Statics/double-edge-notched-specimen/#results","title":"Results","text":"<p>Results are shown as follows, which agree with experimental results.</p> <p></p> <p></p>"},{"location":"Example/Structural/Statics/double-edge-notched-specimen/#element-deletion","title":"Element Deletion","text":"<p>It is possible to further define a criterion so that for elements that exceed a certain value of \\(\\(\\kappa_t\\)\\), they are removed from the model. This is an approach adopted widely to simulate crack propagation.</p> Text Only<pre><code>criterion MaxHistory 1 KAPPAT .8\n</code></pre> <p>The animation of crack development is shown as follows.</p> <p></p>"},{"location":"Example/Structural/Statics/lees-frame/","title":"[\u2605\u2605\u2605\u2606\u2606] Lee's Frame","text":"<p>The Lee's frame is shown as follows.</p> <p></p> <p>The model can be downloaded. lees-frame.supan</p>"},{"location":"Example/Structural/Statics/lees-frame/#model-setup","title":"Model Setup","text":"<p>Since this is an elastic analysis, we use <code>EB21</code> element to model this problem. To suppress axial deformation, a large area of \\(\\(500\\)\\) is assigned. The node and element definitions can be established as follows.</p> Text Only<pre><code>node 1 0 0\nnode 2 0 1\nnode 3 0 2\nnode 4 0 3\nnode 5 0 4\nnode 6 0 5\nnode 7 1 5\nnode 8 2 5\nnode 9 3 5\nnode 10 4 5\nnode 11 5 5\n\nelement EB21 1 1 2 500. 1. 1 1\nelement EB21 2 2 3 500. 1. 1 1\nelement EB21 3 3 4 500. 1. 1 1\nelement EB21 4 4 5 500. 1. 1 1\nelement EB21 5 5 6 500. 1. 1 1\nelement EB21 6 6 7 500. 1. 1 1\nelement EB21 7 7 8 500. 1. 1 1\nelement EB21 8 8 9 500. 1. 1 1\nelement EB21 9 9 10 500. 1. 1 1\nelement EB21 10 10 11 500. 1. 1 1\n\nmaterial Elastic1D 1 10\n\nfix 1 1 1 11\nfix 2 2 1 11\n</code></pre> <p>Both snap-back and snap-through are involved in this example, the arc length method shall be used. A reference load of magnitude \\(\\(-1\\)\\) is applied on the DoF 2 of node 7.</p> Text Only<pre><code>step arclength 1 7 2 -1\n</code></pre> <p>Here the magnitude of reference load matters. A proper selection of reference load may help to converge. The algorithm automatically scale the arc length so a stopping criterion shall be applied. If no solver is defined. To customize the solving strategy, it is possible to define a <code>Ramm</code> solver.</p> Text Only<pre><code>solver Ramm 1 .05 true\nset max_iteration 1000\n</code></pre> <p>The above command defines a <code>Ramm</code> solver using a fixed arc length of \\(\\(0.5\\)\\). By default, a maximum of \\(\\(1000\\)\\) sub steps are allowed, this may not be sufficient, to change it the <code>set</code> command can be called.</p> Text Only<pre><code>criterion MinDisplacement 1 7 2 -3.8\n</code></pre> <p>With the above criterion, when the negative displacement of DoF2 of node 7 reaches \\(\\(-3.8\\)\\), the analysis stops.</p> <p>Now the model can be analyzed.</p> Text Only<pre><code>analyze\n</code></pre>"},{"location":"Example/Structural/Statics/lees-frame/#result","title":"Result","text":"<p>The sign of vertical displacement is flipped.</p>"},{"location":"Example/Structural/Statics/notched-beam-under-cyclic-loading/","title":"[\u2605\u2605\u2605\u2606\u2606] Notched Beam Under Cyclic Loading","text":"<p>The model scripts can be downloaded from here.</p> <p>This example is taken from section 1.1.7 in the manual \"ABAQUS Example Problems Guide\". Additional references are available:</p> <ol> <li>https://doi.org/10.1002/nme.1620362210</li> <li>https://doi.org/10.1002/cnm.1630040606</li> </ol>"},{"location":"Example/Structural/Statics/notched-beam-under-cyclic-loading/#geometry","title":"Geometry","text":"<p>The model is depicted as follows.</p> <p></p>"},{"location":"Example/Structural/Statics/notched-beam-under-cyclic-loading/#material-parameters","title":"Material Parameters","text":"<p>The Armstrong-Frederick model is used to model the behavior of the rolled steel. An elastic modulus of \\(\\(E=210~\\mathrm{GPa}\\)\\) and a Poisson's ratio of \\(\\(\\nu=0.3\\)\\) are used. The initial yield stress is \\(\\(\\sigma_y=200~\\mathrm{MPa}\\)\\).</p>"},{"location":"Example/Structural/Statics/notched-beam-under-cyclic-loading/#isotropic-hardening","title":"Isotropic Hardening","text":"<p>The same exponential function with a saturated limit is used in both AF model and the ABAQUS implementation.</p> \\[ k(p)=\\sigma_y+k_s(1-e^{-mp})+k_lp, \\] <p>in which the following parameters are used: \\(\\(k_s=2000~\\mathrm{MPa}\\)\\), \\(\\(m=0.26\\)\\) and \\(\\(k_l=0~\\mathrm{MPa}\\)\\).</p>"},{"location":"Example/Structural/Statics/notched-beam-under-cyclic-loading/#kinematic-hardening","title":"Kinematic Hardening","text":"<p>A slightly different rule is used in the ABAQUS implementation compared to that in the AF model. The linear part of the back stress \\(\\(\\beta\\)\\) is proportional to the shifted stress \\(\\(\\eta\\)\\), rather than its unit direction \\(\\(n=\\dfrac{\\eta}{|\\eta|}\\)\\). Please refer to the description of the AF model for the meanings of those symbols.</p> <p>In the ABAQUS implementation, the following rate form is used.</p> \\[ \\mathrm{d}\\beta=C\\dfrac{1}{\\sigma_y}\\left(s-\\beta\\right)p-\\gamma\\beta{}p, \\] <p>in which \\(\\(C=25.5~\\mathrm{GPa}\\)\\) and \\(\\(\\gamma=81\\)\\) are used.</p> <p>The AF model uses the following form.</p> \\[ \\mathrm{d}\\beta=a\\dfrac{s-\\beta}{|s-\\beta|}p-b\\beta{}p. \\] <p>In this form, the parameter \\(\\(C\\)\\) shall be defined as a function. For simplicity, a constant but smaller value can be used for \\(\\(a&lt;C\\)\\) while \\(\\(b=\\gamma\\)\\).</p>"},{"location":"Example/Structural/Statics/notched-beam-under-cyclic-loading/#initial-condition","title":"Initial Condition","text":"<p>Initial accumulated plastic strain and back stress are defined so that</p> \\[ p_0=0.43,\\qquad\\beta_0=\\begin{bmatrix}128&amp;-181&amp;53&amp;0&amp;0&amp;0\\end{bmatrix}^\\mathrm{T}. \\]"},{"location":"Example/Structural/Statics/notched-beam-under-cyclic-loading/#numerical-model","title":"Numerical Model","text":"<p>The following commands can be used to define the model. Note since it is a plane strain problem, the corresponding wrapper is used. Also note due to the different implementation of kinematic hardening, exact result is not possible.</p> Text Only<pre><code>material ArmstrongFrederick 1 2.1E5 .3 2E2 2E3 0 .26 2E4 81\ninitial material history 1 .43 128 -181 53\nmaterial PlaneStrain 2 1\n</code></pre>"},{"location":"Example/Structural/Statics/notched-beam-under-cyclic-loading/#results","title":"Results","text":"<p>The response of the root of the notch is plotted as follows.</p> <p></p> <p>The deformation is shown.</p> <p></p>"},{"location":"Example/Structural/Statics/rc-section-analysis/","title":"[\u2605\u2605\u2605\u2606\u2606] Reinforced Concrete Section Analysis","text":"<p>In this page, the analysis of a rectangular reinforced concrete section of a 2D beam is performed to compute the full plastic moment. This is achieved by using the <code>SingleSection2D</code> element. There is no need to create a larger model.</p> <p>The model can be downloaded. rc-section-analysis.supan</p>"},{"location":"Example/Structural/Statics/rc-section-analysis/#section-definition","title":"Section Definition","text":"<p>The section configuration is shown as follows.</p> <p></p>"},{"location":"Example/Structural/Statics/rc-section-analysis/#model-development","title":"Model Development","text":"<p>The <code>SingleSection2D</code> element is NOT a connector element. Only one node is required to define the element. First we define an arbitrary node.</p> Text Only<pre><code>node 1 0 0\n</code></pre> <p>For material models, we use a simple concrete model that adopts Tsai's backbone <code>ConcreteTsai</code> and the <code>MPF</code> steel model.</p> Text Only<pre><code>material ConcreteTsai 1 30. 3. 2. 2. 2. 2. .2 2E-3 1E-4\nmaterial MPF 2 2E5 400 .01\n</code></pre> <p>With the above definition, we have \\(\\(f_c=30~\\text{MPa}\\)\\), \\(\\(f_t=3~\\text{MPa}\\)\\), \\(\\(\\varepsilon_c=0.002\\)\\), \\(\\(\\varepsilon_t=0.0001\\)\\), \\(\\(E=200~\\text{GPa}\\)\\) and \\(\\(f_y=400~\\text{MPa}\\)\\). For detailed material definitions, please refer to the corresponding pages.</p> <p>Now we define a rectangular concrete section with the dimension of \\(\\(400~\\text{mm}\\times500~\\text{mm}\\)\\) and nine integration points along section height. Since it is a 2D section, it is meaningless to define multiple integration points along \\(\\(z\\)\\) axis. All 2D sections only use 1D integration schemes along \\(\\(y\\)\\) axis.</p> Text Only<pre><code>section Rectangle2D 2 400. 500. 1 9\n</code></pre> <p>Now define some rebars. The eccentricities are \\(\\(\\pm220~\\text{mm}\\)\\) and \\(\\(0~\\text{mm}\\)\\).</p> Text Only<pre><code>section Bar2D 3 900. 2 220.\nsection Bar2D 4 900. 2 -220.\nsection Bar2D 5 600. 2 0.\n</code></pre> <p>To combine those independent sections into a whole, we use the <code>Fibre2D</code> section. It is a wrapper that wraps all valid sections into one piece. Accordingly, a <code>SingleSection2D</code> element can be defined.</p> Text Only<pre><code>section Fibre2D 1 2 3 4 5\nelement SingleSection2D 1 1 1\n</code></pre> <p>Before defining steps, we first create two recorders to record nodal reactions and displacements.</p> Text Only<pre><code>hdf5recorder 1 Node RF 1\nhdf5recorder 2 Node U 1\n</code></pre> <p>If the axial deformation shall be suppressed, the first DoF needs to be restrained. Here, instead of doing that, we apply an axial force of \\(\\(10\\%\\)\\) section capacity, which is \\(\\(600~\\text{kN}\\)\\).</p> Text Only<pre><code>step static 1\nset ini_step_size 1E-1\nset fixed_step_size 1\nset symm_mat 0\n\ncload 1 0 -6E5 1 1\n\nconverger AbsIncreDisp 1 1E-10 20 1\n</code></pre> <p>Now in the second step, a rotation of \\(\\(10^{-4}\\)\\) is applied on the second DoF.</p> Text Only<pre><code>step static 2\nset ini_step_size 1E-2\nset fixed_step_size 1\nset symm_mat 0\n\ndisplacement 2 0 1E-4 2 1\n\nconverger AbsIncreDisp 2 1E-10 20 1\n</code></pre>"},{"location":"Example/Structural/Statics/rc-section-analysis/#result","title":"Result","text":"<p>Perform the analysis, the rotation versus moment can be plotted. The maximum moment under such a loading configuration is about \\(\\(350~\\text{kNm}\\)\\).</p> <p></p> <p>Users with relative background may help to justify the result.</p>"},{"location":"Example/Structural/Statics/truss-roof/","title":"[\u2605\u2606\u2606\u2606\u2606] Linear Analysis of A Truss Roof","text":"<p>The model can be downloaded. truss-roof.zip</p>"},{"location":"Example/Structural/Statics/truss-roof/#model","title":"Model","text":""},{"location":"Example/Structural/Statics/truss-roof/#node","title":"Node","text":"<p>A 2D truss model is developed. To define nodes, use the <code>node</code> command. As this is a 2D model, each node is defined by two coordinates, thus the command looks like this: <code>node &lt;tag&gt; &lt;x&gt; &lt;y&gt;</code>.</p> Text Only<pre><code># file: node\nnode  1 15  0\nnode  2 15  7\nnode  3 20  7.5\nnode  4 25  0\nnode  5 30  0\nnode  6 35  0\nnode  7 35  4\nnode  8 30  6\nnode  9 25  7\nnode  10  10  0\nnode  11  5 0\nnode  12  5 4\nnode  13  10  6\nnode  14  0 0\nnode  15  20  0\nnode  16  40  0\n</code></pre> <p>Here we define 16 nodes. The truss roof has a span of 40 and an apex height of 7.5.</p>"},{"location":"Example/Structural/Statics/truss-roof/#element","title":"Element","text":"<p>To model truss elements, we use the <code>T2D2</code> element. (Yes! The same designation as in ABAQUS!)</p> Text Only<pre><code># file: element\nelement T2D2 1 1 2 1 0.2 ! element 1 connecting nodes 1 and 2 using material 1 with cross-sectional area 0.2\nelement T2D2 2 3 2 1 0.2\nelement T2D2 3 4 3 1 0.2\nelement T2D2 4 5 4 1 0.2\nelement T2D2 5 6 5 1 0.2\n# ...\n</code></pre> <p>Here the first five elements are shown. The cross sectional area can be directly specified with <code>T2D2</code>. Alternatively, the truss section can be built up manually using basic shapes, see the <code>T2D2S</code> element for details.</p> <p>You may have noticed that the material model used is not defined. Do not worry, for model definitions, the order is not important, see Structure for explanation.</p>"},{"location":"Example/Structural/Statics/truss-roof/#load-and-bc","title":"Load and BC","text":"<p>Definitions of nodes and elements are stored in files <code>node</code> and <code>element</code>. We load it first using <code>file</code> command.</p> Text Only<pre><code># file: truss-roof.supan\nfile node\nfile element\n</code></pre> <p>For material, we simply define an elastic <code>Elastic1D</code> material with a Young's modulus of \\(\\(3E4\\)\\).</p> Text Only<pre><code># file: truss-roof.supan\nmaterial Elastic1D 1 30E3\n</code></pre> <p>The left-most node <code>14</code> is fixed, while the right-most node <code>16</code> is roller supported. This means for node <code>14</code>, both x and y displacements are fixed, while for node <code>16</code>, only y displacement is fixed. One can use either <code>fix</code> (penalty method) or <code>fix2</code> (multiplier method) to apply homogeneous boundary conditions. Both shall lead to the same result.</p> Text Only<pre><code># file: truss-roof.supan\nfix2 1 1 14 ! fix x-displacement (dof 1) of node 14\nfix2 2 2 14 16 ! fix y-displacement (dof 2) of nodes 14 and 16\n</code></pre> <p>For load, we apply a vertical <code>displacement</code> load on top of the apex.</p> Text Only<pre><code># file: truss-roof.supan\ndisplacement 1 0 -1 2 3 ! a displacement load with tag 1 on node 3 dof 2 (vertical) with a magnitude of -1\n</code></pre> <p>The second parameter <code>0</code> is a placeholder for <code>amplitude</code>, a <code>0</code> means a default <code>Ramp</code> is used.</p>"},{"location":"Example/Structural/Statics/truss-roof/#analysis","title":"Analysis","text":"<p>A simple static step is required to analyse the model.</p> Text Only<pre><code># file: truss-roof.supan\nstep static 1\nset ini_step_size 1\nset fixed_step_size true\n\nanalyze ! perform analysis\n</code></pre>"},{"location":"Example/Structural/Statics/truss-roof/#probe-result","title":"Probe Result","text":"<p>It is possible to probe the simple results of the analysis, for example, one can check the displacement and resistance of node <code>3</code> by using the <code>peek</code> command. To record various results, one may want to use <code>recorder</code> command.</p> Text Only<pre><code>peek node 3\n</code></pre> <p>The following printout shall be expected.</p> Text Only<pre><code>Node 3:\nCoordinate:\n   20.0000    7.5000\nDisplacement:\n   0.2238  -1.0000\nResistance:\n  -1.7053e-13  -7.4093e+01\n</code></pre>"},{"location":"Example/Structural/Statics/truss-roof/#bye","title":"Bye","text":"<p>Do not forget to quit.</p> Text Only<pre><code>exit\n</code></pre>"},{"location":"Example/Structural/Statics/truss-roof/#results","title":"Results","text":"<p>The deformation is shown.</p> <p></p>"},{"location":"Example/Structural/Statics/uniform-tension-of-a-rubber-specimen/","title":"[\u2605\u2605\u2606\u2606\u2606] Uniform Tension of A Rubber Specimen","text":"<p>In this page, a rubber specimen is modelled using solid elements and Mooney-Rivlin material.</p> <p>Only a quarter of the specimen is modelled considering symmetry. The geometry can be seen as follows. The model can be downloaded. uniform-tension-of-a-rubber-specimen.zip</p> <p></p>"},{"location":"Example/Structural/Statics/uniform-tension-of-a-rubber-specimen/#model-setup","title":"Model Setup","text":"<p>The node and element information can be seen in <code>node.supan</code> and <code>element.supan</code>, the mesh is generated by ABAQUS, it is easy to adapt ABAQUS input file to be used here. <code>C3D8</code> element with full integration and nonlinear geometry is used.</p> Text Only<pre><code>file node.supan\nfile element.supan\n</code></pre> <p>After loading nodes and elements, a <code>MooneyRivlin</code> material is defined with \\(\\(C_1=80~\\text{MPa}\\)\\), \\(\\(C_2=20~\\text{MPa}\\)\\) and \\(\\(K=10^6~\\text{MPa}\\)\\). This is a regularized version of Mooney-Rivlin model that allows a certain degree of dilatation. The \\(\\(D_1\\)\\) parameter used in ABAQUS is the inverse of bulk modulus so that \\(\\(D_1=0\\)\\) means fully incompressible. The displacement of magnitude of \\(\\(10\\)\\) along \\(\\(x\\)\\) axis is applied on the free end. A static step with an initial step size of \\(\\(0.01\\)\\) is used. With <code>fixed_step_size</code> off, the algorithm automatically scale step size based on convergence performance.</p> Text Only<pre><code>material MooneyRivlin 1 1E6 80 20\n</code></pre> <p>To generate the node groups to be used to apply boundary conditions, here the <code>generatebyplane</code> command is used.</p> Text Only<pre><code># all nodes on plane x=0\ngeneratebyplane nodegroup 1 1. 0. 0. 0.\n# all nodes on plane y=0\ngeneratebyplane nodegroup 2 0. 1. 0. 0.\n# all nodes on plane z=0\ngeneratebyplane nodegroup 3 0. 0. 1. 0.\n# all nodes on plane x=20\ngeneratebyplane nodegroup 4 1. 0. 0. -20.\n</code></pre> <p>Now BCs and loads can be applied.</p> Text Only<pre><code>grouppenaltybc 1 1 1\ngrouppenaltybc 2 2 2\ngrouppenaltybc 3 3 3\n\ngroupdisplacement 1 0 10 1 4\n</code></pre> <p>Setup steps and perform the analysis.</p> Text Only<pre><code>step static 1\nset fixed_step_size 0\nset ini_step_size 1E-2\nset symm_mat 0\n\nconverger AbsIncreDisp 1 1E-8 10 1\n\nanalyze\n\nexit\n</code></pre>"},{"location":"Example/Structural/Statics/uniform-tension-of-a-rubber-specimen/#result","title":"Result","text":""},{"location":"Library/Amplitude/Amplitude/","title":"Amplitude","text":"<p>The <code>Amplitude</code> class holds arbitrary functions (of time) and provides magnitudes of anything that changes with time, such as load and constraint. The concept is identical to that of the amplitude in ABAQUS.</p> <p>There are a few universal patterns. Special databases, such as New Zealand ground motion database, are also implemented.</p> <ul> <li>Universal<ul> <li>Constant</li> <li>Linear/Ramp</li> <li>Cosine/Sine</li> <li>Modulated</li> <li>Decay</li> <li>Tabular</li> <li>Combine</li> </ul> </li> <li>Special<ul> <li>NZ Strong Motion</li> </ul> </li> </ul>"},{"location":"Library/Amplitude/Special/NZStrongMotion/","title":"NZ Strong Motion","text":"<p>The original NZ strong motion database can be downloaded from this page.</p> <p>The ground motions are processed and compiled into separate files. Please download the archive first before using any recordings. Users may need 7-Zip to unpack the archive.</p> type link acceleration download velocity download displacement download <p>The archive contains all 756 displacement, velocity and acceleration histories along three directions. That totals 6804 records.</p> <p>The script used to process the original data is available here.</p>"},{"location":"Library/Amplitude/Special/NZStrongMotion/#syntax","title":"Syntax","text":"Text Only<pre><code>amplitude NZStrongMotion (1) (2)\n# (1) int, unique amplitude tag\n# (2) string, record name\n</code></pre> <p>It must be noted that the amplitudes are normalized so that the maximum absolute magnitude is unity. Hence, to achieve a target PGA/PGV/PGD, it shall be assigned to the magnitude of the applied load.</p>"},{"location":"Library/Amplitude/Special/NZStrongMotion/#usage","title":"Usage","text":"<p>For example, to load the accelerogram <code>20110221_235142_CSHS_N76W_A</code>, which is one of the 2011 Christchurch earthquake recordings, user shall first extract the file <code>20110221_235142_CSHS_N76W_A</code> from <code>NZStrongMotion.7z</code> and place it where the program can locate, for example, the current working folder.</p> <p>To define such an amplitude, one can use</p> Text Only<pre><code>amplitude NZStrongMotion 1 20110221_235142_CSHS_N76W_A\n</code></pre>"},{"location":"Library/Amplitude/Special/NZStrongMotion/#explanation-of-file-format","title":"Explanation of File Format","text":"<p>The format of original file can be seen here.</p> <p>The processed archive first extract accelerogram name from the file, then read how many acceleration values shall be read and the interval between two records, then read all values and scale them by multiplying each by \\(\\(1000\\)\\) and store them into an integer array. The array has the following layout.</p> index value (\\(\\(\\times1000\\)\\)) 0 time interval of the record in seconds 1 absolute maximum record value 2 value at first time point 3 value at second time point 4 value at third time point 5 ..."},{"location":"Library/Amplitude/Universal/Combine/","title":"Combine","text":"<p>The <code>Combine</code> amplitude can combine multiple amplitudes together by multiplication so that</p> \\[ A(t)=\\Pi_{i=1}^nA_i(t)\\quad\\text{for}\\quad{}t&gt;t_0. \\]"},{"location":"Library/Amplitude/Universal/Combine/#syntax","title":"Syntax","text":"Text Only<pre><code>amplitude Combine (1) [(2)...]\n# (1) int, unique amplitude tag\n# [(2)...] int, tags of amplitude that need to be combined\n</code></pre>"},{"location":"Library/Amplitude/Universal/Constant/","title":"Constant","text":"<p>The <code>Constant</code> amplitude defines a simple unit constant input.</p> \\[ A(t)=1\\quad\\text{for}\\quad{}t&gt;t_0. \\] <p>In the above definition, \\(\\(t_0\\)\\) is the (pseudo) start time of the step in which the amplitude is defined.</p>"},{"location":"Library/Amplitude/Universal/Constant/#syntax","title":"Syntax","text":"Text Only<pre><code>amplitude Constant (1)\n# (1) int, unique amplitude tag\n</code></pre>"},{"location":"Library/Amplitude/Universal/Decay/","title":"Decay","text":"<p>The <code>Decay</code> amplitude uses a decaying exponential function.</p> \\[ A(t)=A_0\\exp(-\\dfrac{t-t_o}{t_d})\\quad\\text{for}\\quad{}t&gt;t_0. \\]"},{"location":"Library/Amplitude/Universal/Decay/#syntax","title":"Syntax","text":"Text Only<pre><code>amplitude Decay (1) (2) (3)\n# (1) int, unique amplitude tag\n# (2) double, initial amplitude A_0\n# (3) double, speed control parameter t_d\n</code></pre>"},{"location":"Library/Amplitude/Universal/Linear/","title":"Linear/Ramp","text":"<p>The <code>Linear</code> amplitude increases proportionally with time so that</p> \\[ A(t)=V\\langle{}t-t_0\\rangle\\quad\\text{for}\\quad{}t&gt;t_0. \\] <p>The <code>Ramp</code> amplitude is in fact a simplified version with unit slope. It adopts unit time length no matter what the current step is and remains unity after that.</p> \\[ A(t)=\\left\\{\\begin{array}{rl}\\langle{}t-t_0\\rangle,&amp;t&lt;t_0+1,\\\\1,&amp;t\\ge{}t_0+1.\\end{array}\\right. \\] <p>The <code>Ramp</code> amplitude is the default amplitude that would be used if no valid amplitude is defined.</p>"},{"location":"Library/Amplitude/Universal/Linear/#syntax","title":"Syntax","text":"Text Only<pre><code>amplitutde Linear (1) (2)\n# (1) int, unique amplitude tag\n# (2) double, slope V\n\namplitude Ramp (1)\n# (1) int, unique amplitude tag\n</code></pre>"},{"location":"Library/Amplitude/Universal/Modulated/","title":"Modulated","text":"<p>The <code>Modulated</code> amplitude defines the following functions.</p> \\[ A(t)=A_0\\Pi_{i=1}^{n}\\sin(2\\pi\\omega_i{}(t-t_0))\\quad\\text{for}\\quad{}t&gt;t_0. \\] <p>In the above definition, \\(\\(t_0\\)\\) is the (pseudo) start time of the step in which the amplitude is defined, \\(\\(\\omega_i\\)\\) is the circular frequency.</p>"},{"location":"Library/Amplitude/Universal/Modulated/#syntax","title":"Syntax","text":"Text Only<pre><code>amplitude Modulated (1) (2) (3) [(4)...]\n# (1) int, unique tag\n# (2) double, base amplitude A_0\n# (3) double, first frequency \\omega_0\n# [(4)...] double, optional frequencies for higher modes\n</code></pre>"},{"location":"Library/Amplitude/Universal/Tabular/","title":"Tabular","text":"<p>The <code>Tabular</code> amplitude reads external tabular amplitude, interpolation is performed when necessary.</p> <p>There should be exactly two columns in the external file. The first column is time point, and the second one shall be the amplitude.</p>"},{"location":"Library/Amplitude/Universal/Tabular/#syntax","title":"Syntax","text":"Text Only<pre><code>amplitude Tabular (1) (2)\n# (1) int, unique amplitude tag\n# (2) string, external file name\n</code></pre>"},{"location":"Library/Amplitude/Universal/TabularSpline/","title":"TabularSpline","text":"<p>The <code>TabularSpline</code> amplitude reads external tabular amplitude, interpolation is performed when necessary.</p> <p>There should be exactly two columns in the external file. The first column is time point, and the second one shall be the amplitude.</p> <p>The cubic spline interpolation is used. The first derivatives of two ends (of the interpolated curve) are set to  zero. See this page for more details.</p>"},{"location":"Library/Amplitude/Universal/TabularSpline/#syntax","title":"Syntax","text":"Text Only<pre><code>amplitude TabularSpline (1) (2)\n# (1) int, unique amplitude tag\n# (2) string, external file name\n</code></pre>"},{"location":"Library/Amplitude/Universal/Trig/","title":"Trigonometric","text":"<p>The amplitude is computed based on the following summation.</p> <p>For <code>Sine</code>,</p> \\[ A(t)=\\sum{}a_i\\sin(i\\dfrac{2\\pi}{T_0}(t-t_0)=\\sum{}a_i\\sin(if_0(t-t_0))\\quad\\text{for}\\quad{}t&gt;t_0. \\] <p>For <code>Cosine</code>,</p> \\[ A(t)=\\sum{}a_i\\cos(i\\dfrac{2\\pi}{T_0}(t-t_0))=\\sum{}a_i\\cos(if_0(t-t_0))\\quad\\text{for}\\quad{}t&gt;t_0. \\] <p>In above equations, \\(\\(T_0\\)\\) is the base period and \\(\\(f_0\\)\\) is base frequency accordingly. In the above definition, \\(\\(t_0\\)\\) is the (pseudo) start time of the step in which the amplitude is defined.</p>"},{"location":"Library/Amplitude/Universal/Trig/#syntax","title":"Syntax","text":"Text Only<pre><code>amplitude Sine (1) (2) (3) [(4)...]\namplitude Cosine (1) (2) (3) [(4)...]\n# (1) int, unique tag\n# (2) double, base period T_0\n# (3) double, amplitude at base period/frequency a_0\n# [(4)...] double, optional amplitudes at higher periods a_i\n</code></pre>"},{"location":"Library/Amplitude/Universal/Trig/#example","title":"Example","text":"Text Only<pre><code>amplitude Sine 1 10. 2.\n</code></pre> \\[ A(t)=2\\sin(\\dfrac{\\pi}{5}(t-t_0)). \\] Text Only<pre><code>amplitude Sine 1 10. 2. 4.\n</code></pre> \\[ A(t)=2\\sin(0.2\\pi{}(t-t_0))+4\\sin(0.4\\pi{}(t-t_0)). \\]"},{"location":"Library/Constraint/Constraint/","title":"Constraint","text":"<p>There are a number of different approaches to implement constraints in a FEM context. Interested readers can check out the relevant documentations of ABAQUS, or this slides for a brief introductory summary on linear constraints.</p>"},{"location":"Library/Constraint/Constraint/#overview","title":"Overview","text":"<p>Not all approaches are suitable for general applications. Accounting for efficacy and universality, the penalty function method and the Lagrange multiplier method are implemented for most constraints.</p> <p>Both methods do not alter the size of the system, or, in other words, they retain/reuse the unconstrained system. Consequently, there is no need to reallocate memory for the constrained system.</p> <p>Generally speaking, the penalty function method directly modifies the unconstrained system by introducing penalty factors into the system. The larger the penalty factor, the more strictly the constraint is enforced. However, the system tends to become ill-conditioned with large penalty factors.</p> <p>The Lagrange multiplier method uses the border matrices to exactly enforce the constraint. The solving cost is higher than the penalty function method, as it is not known in advance if the specific constraint (especially the inequality constraints) should be active or not before the unconstrained system is solved.</p>"},{"location":"Library/Constraint/Constraint/#difference-between-two-methods-with-examples","title":"Difference Between Two Methods With Examples","text":"<p>Here we show a very simple example to illustrate the difference between the two methods. The homogeneous Dirichlet type boundary condition (<code>fix</code> and <code>fix2</code>) is used.</p> <p>The following model defines a simple elastic cantilever beam subjected to end load. The size of the system shall be \\(\\(6\\)\\) (three DoFs per node with two nodes). The fixed end is constrained so three DoFs are constrained, one DoF is loaded and the other two are free.</p> Text Only<pre><code>node 1 0 0\nnode 2 1 0\nmaterial Elastic1D 1 10\nelement EB21 1 1 2 12 1 1\n\n# use penalty function method\nfix 1 P 1\n\n# to change penalty factor\n# set constraint_multiplier 1E12\n\n# to use Lagrange multiplier method\n# fix2 1 P 1\n\ncload 1 0 10 2 2\nstep static 1 1\nset ini_step_size 1\nset fixed_step_size true\nconverger RelIncreDisp 1 1E-11 5 1\nanalyze\nexit\n</code></pre>"},{"location":"Library/Constraint/Constraint/#penalty-function-method","title":"Penalty Function Method","text":"<p>The <code>fix</code> command implements the penalty function method, the default penalty factor is \\(\\(10^8\\)\\). The analysis results can be shown as follows.</p> Text Only<pre><code>current analysis time: 1.00000.\nrelative incremental displacement error: 1.00000E+00.\nrelative incremental displacement error: 3.10087E-09.\nrelative incremental displacement error: 2.27111E-16.\n</code></pre> <p>Although it is an elastic model, it still requires three iterations to converge. Since the default penalty factor is \\(\\(10^8\\)\\), each iteration will have an inherent error around \\(\\(10^{-8}\\)\\). Thus the second iteration gives a relative  error of \\(\\(3.10087\\times10^{-9}\\)\\).</p>"},{"location":"Library/Constraint/Constraint/#control-the-penalty-factor","title":"Control the Penalty Factor","text":"<p>To enforce stronger/weaker constraints, it is possible to use a larger penalty factor via the <code>set</code> command. For example,</p> Text Only<pre><code>set constraint_multiplier 1E3\n</code></pre> Text Only<pre><code>current analysis time: 1.00000.\nrelative incremental displacement error: 1.00000E+00.\nrelative incremental displacement error: 3.10428E-04.\nrelative incremental displacement error: 3.44025E-07.\nrelative incremental displacement error: 4.33029E-10.\nrelative incremental displacement error: 5.48739E-13.\n</code></pre> <p>Or stronger such as,</p> Text Only<pre><code>set constraint_multiplier 1E12\n</code></pre> Text Only<pre><code>current analysis time: 1.00000.\nrelative incremental displacement error: 1.00000E+00.\nrelative incremental displacement error: 3.09916E-13.\n</code></pre> <p>This is the inherent behaviour of the penalty function method. For nonlinear analysis, it is not a concern. For  linear elastic analysis, additional iterations are required to converge.</p>"},{"location":"Library/Constraint/Constraint/#lagrange-multiplier-method","title":"Lagrange Multiplier Method","text":"<p>The <code>fix2</code> command implements the Lagrange multiplier method. With which,</p> Text Only<pre><code>fix2 1 P 1\n</code></pre> <p>The corresponding iteration results are shown as follows.</p> Text Only<pre><code>current analysis time: 1.00000.\nrelative incremental displacement error: 1.00000E+00.\nrelative incremental displacement error: 4.92673E-17.\n</code></pre> <p>It can be seen that the constraint is exactly satisfied as the relative error is smaller than the machine error  (<code>DBL_EPSILON</code> is typically around \\(\\(2\\times10^{-16}\\)\\)).</p>"},{"location":"Library/Constraint/Embed2D/","title":"Embed2D","text":"<p>The <code>Embed2D</code> constraint implements the embedded constraint in 2D space via multiplier method.</p>"},{"location":"Library/Constraint/Embed2D/#syntax","title":"Syntax","text":"Text Only<pre><code>constraint Embed2D (1) (2) (3)\n# (1) int, unique constraint tag\n# (2) int, host element tag\n# (3) int, embedded node tag\n</code></pre>"},{"location":"Library/Constraint/Embed2D/#remarks","title":"Remarks","text":"<ol> <li>The <code>Embed2D</code> constraint is only implemented with linear formulation.</li> <li>Currently, the following host element types are supported: <code>CP4</code>    , <code>CP5</code>, <code>CP7</code>    and <code>CP8</code>.</li> </ol>"},{"location":"Library/Constraint/Embed3D/","title":"Embed3D","text":"<p>The <code>Embed3D</code> constraint implements the embedded constraint in 3D space via multiplier method.</p>"},{"location":"Library/Constraint/Embed3D/#syntax","title":"Syntax","text":"Text Only<pre><code>constraint Embed3D (1) (2) (3)\n# (1) int, unique constraint tag\n# (2) int, host element tag\n# (3) int, embedded node tag\n</code></pre>"},{"location":"Library/Constraint/Embed3D/#remarks","title":"Remarks","text":"<ol> <li>The <code>Embed3D</code> constraint is only implemented with linear formulation.</li> <li>Currently, the following host element types are supported: <code>C3D8</code>    and <code>C3D20</code>.</li> </ol>"},{"location":"Library/Constraint/FixedLength/","title":"FixedLength","text":"<p>The Lagrange multiplier method can be used to define constraints. Extra storage is required for the so-called auxiliary border stiffness matrix. The constraint is satisfied exactly.</p> <p>The <code>FixedLength2D</code> and <code>FixedLength3D</code> constraints behave similar to the <code>Tie</code> element, the nonlinear constraint is implemented via Lagrange multiplier method.</p> <p>It shall not be used with global damping models in dynamic analysis.</p>"},{"location":"Library/Constraint/FixedLength/#syntax","title":"Syntax","text":"Text Only<pre><code>fixedlength2d (1) (2) (3)\nfixedlength3d (1) (2) (3)\nconstraint fixedlength2d (1) (2) (3)\nconstraint fixedlength3d (1) (2) (3)\n# (1) int, unique constraint tag\n# (2) int, node tag\n# (3) int, node tag\n</code></pre>"},{"location":"Library/Constraint/MPC/","title":"MPC","text":"<p>The Lagrange multiplier method can be used to define constraints. Extra storage is required for the so-called auxiliary bordered stiffness matrix. The constraint is satisfied exactly.</p> <p>Although the <code>MPC</code> object belongs to the <code>Constraint</code> class, it behaves like a <code>Load</code> object. Hence, a proper <code>Amplitude</code> object is required to be present. If <code>0</code> is assigned to <code>[2]</code>, a default ramp function will be assigned automatically.</p> <p>Users are not expected to assign boundary conditions via <code>MPC</code> constraint or <code>Tie</code> element.</p>"},{"location":"Library/Constraint/MPC/#syntax","title":"Syntax","text":"Text Only<pre><code>mpc (1) (2) (3) [(4) (5) (6))...]\nconstraint mpc (1) (2) (3) [(4) (5) (6))...]\n# (1) int, unique constraint tag\n# (2) int, amplitude tag, can be zero\n# (3) double, right hand side of the constraint equation, the constraint is homogeneous if this parameter is zero\n# (4) int, node tag\n# (5) int, dof tag\n# (6) double, weight\n</code></pre>"},{"location":"Library/Constraint/NodeFacet/","title":"NodeFacet","text":"<p>The <code>NodeFacet</code> constraint implements 3D node-facet (triangular) contact via Lagrangian multiplier method.</p> <p>The relevant theoretical formulation on both multiplier and penalty methods is briefly discussed in this document.</p>"},{"location":"Library/Constraint/NodeFacet/#syntax","title":"Syntax","text":"Text Only<pre><code>constraint NodeFacet (1) (2) (3) (4) (5)\n# (1) int, unique constraint tag\n# (2) int, master node i tag\n# (3) int, master node j tag\n# (4) int, master node k tag\n# (5) int, slave node l tag\n</code></pre>"},{"location":"Library/Constraint/NodeLine/","title":"NodeLine","text":"<p>The <code>NodeLine</code> constraint implements 2D node-line contact via Lagrangian multiplier method.</p>"},{"location":"Library/Constraint/NodeLine/#syntax","title":"Syntax","text":"Text Only<pre><code>constraint NodeLine (1) (2) (3) (4)\n# (1) int, unique constraint tag\n# (2) int, master node i tag\n# (3) int, master node j tag\n# (4) int, slave node k tag\n</code></pre>"},{"location":"Library/Constraint/NodeLine/#remarks","title":"Remarks","text":"<ol> <li>The outer normal vector of master line is defined by rotating the master axis defined by \\(\\(\\mathbf{x}_j-\\mathbf{x}_    i\\)\\) by \\(\\(\\pi/2\\)\\) anticlockwise. Thus, the sequence of master nodes matters.</li> </ol>"},{"location":"Library/Constraint/ParticleCollision/","title":"ParticleCollision","text":"<p>The <code>ParticleCollision2D</code> and <code>ParticleCollision3D</code> constraints can be used to simulate collision of particles of uniform size.</p>"},{"location":"Library/Constraint/ParticleCollision/#syntax","title":"Syntax","text":"Text Only<pre><code>ParticleCollision2D (1) (2) (3)\nParticleCollision3D (1) (2) (3)\nconstraint ParticleCollision2D (1) (2) (3)\nconstraint ParticleCollision3D (1) (2) (3)\n# (1) int, unique constraint tag\n# (2) double, space\n# (3) double, penalty number\n</code></pre> <p>The constraint is applied to ALL particles defined in the system. Since any two particles can collide with each other, there is no way to obtain the structural topology. Thus, the full/sparse matrix storage shall be used. Parameter <code>(2)</code> controls the uniform size of particles. When any two particles are closer than the value defined in <code>(2)</code>, interaction forces will be applied. The penalty method is used in implementation, thus parameter <code>(3)</code> represents the penalty number, adjusting this value leads to different magnitudes of interaction forces.</p>"},{"location":"Library/Constraint/RestitutionWall/","title":"RestitutionWall","text":"<p>The <code>RigidWall</code> constraint essentially implements artificial springs to alter the trajectories of  nodes. The physical implication is clear but the main issue is that the conservation of energy/momentum cannot be  guaranteed.</p> <p>The <code>RestitutionWall</code> constraint adopts a different approach to ensure the assigned restitution is satisfies. If the  coefficient of restitution is set to unity, conservation of energy/momentum is guaranteed.</p>"},{"location":"Library/Constraint/RestitutionWall/#syntax","title":"Syntax","text":"<p>The rigid wall constraints are single sided. Travelling against the outer normal direction is not allowed while the  other direction is permitted.</p>"},{"location":"Library/Constraint/RestitutionWall/#1d","title":"1D","text":"<p>The 1D version takes the origin and the side of the wall as the inputs.</p> Text Only<pre><code>! infinite rigid wall by penalty\nrestitutionwall (1) (2) (3) (4) [5]\nconstraint restitutionwall (1) (2) (3) (4) [5]\n# (1) int, unique constraint tag\n# (2) double, coordinate of origin of rigid wall\n# (3) double, sign of normal direction +1 or -1\n# (4) double, restitution coefficient\n# [5] double, multiplier, default: 1E4\n</code></pre>"},{"location":"Library/Constraint/RestitutionWall/#2d","title":"2D","text":"<p>The 2D version takes the origin and either the edge vector or the normal vector as the inputs.</p> Text Only<pre><code>! infinite rigid wall by penalty\nrigidwall (1) (2...3) (4...5) (6) [7]\nconstraint rigidwall (1) (2...3) (4...5) (6) [7]\n# (1) int, unique constraint tag\n# (2...3) double, coordinates of origin of rigid wall\n# (4...5) double, vector of normal direction\n# (6) double, restitution coefficient\n# [7] double, multiplier, default: 1E4\n\n! finite rigid wall by penalty\nfiniterigidwall (1) (2...3) (4...5) (6) [7]\nconstraint finiterigidwall (1) (2...3) (4...5) (6) [7]\n# (1) int, unique constraint tag\n# (2...3) double, coordinates of origin of rigid wall\n# (4...5) double, vector of wall edge\n# (6) double, restitution coefficient\n# [7] double, multiplier, default: 1E4\n</code></pre>"},{"location":"Library/Constraint/RestitutionWall/#3d","title":"3D","text":"<p>The 3D version takes the origin and the normal vector as the inputs. Alternatively, two edges can be specified to  define a finite wall.</p> Text Only<pre><code>! infinite rigid wall by penalty\nrigidwall (1) (2...4) (5...7) (8) [9]\nconstraint rigidwall (1) (2...4) (5...7) (8) [9]\n# (1) int, unique constraint tag\n# (2...4) double, coordinates of origin of rigid wall\n# (5...7) double, vector of normal direction\n# (8) double, coefficient of restitution\n# [9] double, multiplier, default: 1E4\n\n! finite rigid wall by penalty\nfiniterigidwall (1) (2...4) (5...7) (8...10) (11) [12]\nconstraint finiterigidwall (1) (2...4) (5...7) (8...10) (11) [12]\n# (1) int, unique constraint tag\n# (2...4) double, coordinates of origin of rigid wall\n# (5...7) double, vector of first edge\n# (8...10) double, vector of second edge\n# (11) double, coefficient of restitution\n# [12] double, multiplier, default: 1E4\n</code></pre>"},{"location":"Library/Constraint/RestitutionWall/#assumptions","title":"Assumptions","text":"<p>It is assumed that the collision occurs within a very short time. As a result, the change of acceleration is not  reflected at either \\(\\(t_n\\)\\) or \\(\\(t_{n+1}\\)\\). The assumptions adopted are shown in the following figure.</p> <p></p>"},{"location":"Library/Constraint/RestitutionWall/#example","title":"Example","text":"<p>See Bouncing of A Ball.</p> <p>Another validation can be downloaded.</p> <p></p> <p>The kinetic energy is conserved.</p> <p></p>"},{"location":"Library/Constraint/RigidWall/","title":"RigidWall","text":"<p>The <code>RigidWall</code> constraint implements the contact between model and the assigned rigid walls. The rigid walls can have either finite or infinite dimensions.</p>"},{"location":"Library/Constraint/RigidWall/#theory","title":"Theory","text":"<p>Two methods are implemented, namely, the multiplier method and the penalty method.</p>"},{"location":"Library/Constraint/RigidWall/#multiplier-method","title":"Multiplier Method","text":"<p>The implementation is identical to a conventional constraint.</p>"},{"location":"Library/Constraint/RigidWall/#penalty-method","title":"Penalty Method","text":"<p>The impenetrable condition is implemented by adding resisting forces to the right hand of the equation. The force \\(\\(F\\)\\) is proportional to the penetration \\(\\(U_p\\)\\).</p> \\[ F=\\dfrac{\\alpha}{\\Delta{}t^2}U_p, \\] <p>where \\(\\(\\Delta{}t\\)\\) is the time increment of current substep, \\(\\(\\alpha\\)\\) is the multiplier. The denominator \\(\\(\\Delta{}t^2\\)\\) is included to produce (relatively) objective results. The determination of multiplier \\(\\(\\alpha\\)\\) often requires trial and error. In general, too large values shall be avoided.</p>"},{"location":"Library/Constraint/RigidWall/#syntax","title":"Syntax","text":"<p>The rigid wall constraints are single sided. Travelling against the outer normal direction is not allowed while the  other direction is permitted.</p>"},{"location":"Library/Constraint/RigidWall/#1d","title":"1D","text":"<p>The 1D version takes the origin and the side of the wall as the inputs.</p> Text Only<pre><code>! infinite rigid wall by penalty\nrigidwall (1) (2) (3) [4]\nconstraint rigidwall (1) (2) (3) [4]\n# (1) int, unique constraint tag\n# (2) double, coordinate of origin of rigid wall\n# (3) double, sign of normal direction +1 or -1\n# [4] double, multiplier, default: 1E4\n\n! infinite rigid wall by multiplier\nrigidwallmultiplier (1) (2) (3)\nconstraint rigidwallmultiplier (1) (2) (3)\n# (1) int, unique constraint tag\n# (2) double, coordinate of origin of rigid wall\n# (3) double, sign of normal direction +1 or -1\n</code></pre>"},{"location":"Library/Constraint/RigidWall/#2d","title":"2D","text":"<p>The 2D version takes the origin and either the edge vector or the normal vector as the inputs.</p> Text Only<pre><code>! infinite rigid wall by penalty\nrigidwall (1) (2...3) (4...5) [6]\nconstraint rigidwall (1) (2...3) (4...5) [6]\n# (1) int, unique constraint tag\n# (2...3) double, coordinates of origin of rigid wall\n# (4...5) double, vector of normal direction\n# [6] double, multiplier, default: 1E4\n\n! infinite rigid wall by multiplier\nrigidwallmultiplier (1) (2...3) (4...5)\nconstraint rigidwallmultiplier (1) (2...3) (4...5)\n# (1) int, unique constraint tag\n# (2...3) double, coordinates of origin of rigid wall\n# (4...5) double, vector of normal direction\n\n! finite rigid wall by penalty\nfiniterigidwall (1) (2...3) (4...5) [6]\nconstraint finiterigidwall (1) (2...3) (4...5) [6]\n# (1) int, unique constraint tag\n# (2...3) double, coordinates of origin of rigid wall\n# (4...5) double, vector of wall edge\n# [6] double, multiplier, default: 1E4\n\n! finite rigid wall by multiplier\nfiniterigidwallmultiplier (1) (2...3) (4...5)\nconstraint finiterigidwallmultiplier (1) (2...3) (4...5)\n# (1) int, unique constraint tag\n# (2...3) double, coordinates of origin of rigid wall\n# (4...5) double, vector of wall edge\n</code></pre>"},{"location":"Library/Constraint/RigidWall/#3d","title":"3D","text":"<p>The 3D version takes the origin and the normal vector as the inputs. Alternatively, two edges can be specified to  define a finite wall.</p> Text Only<pre><code>! infinite rigid wall by penalty\nrigidwall (1) (2...4) (5...7) [8]\nconstraint rigidwall (1) (2...4) (5...7) [8]\n# (1) int, unique constraint tag\n# (2...4) double, coordinates of origin of rigid wall\n# (5...7) double, vector of normal direction\n# [8] double, multiplier, default: 1E4\n\n! infinite rigid wall by multiplier\nrigidwallmultiplier (1) (2...4) (5...7)\nconstraint rigidwallmultiplier (1) (2...4) (5...7)\n# (1) int, unique constraint tag\n# (2...4) double, coordinates of origin of rigid wall\n# (5...7) double, vector of normal direction\n\n! finite rigid wall by penalty\nfiniterigidwall (1) (2...4) (5...7) (8...10) [11]\nconstraint finiterigidwall (1) (2...4) (5...7) (8...10) [11]\n# (1) int, unique constraint tag\n# (2...4) double, coordinates of origin of rigid wall\n# (5...7) double, vector of first edge\n# (8...10) double, vector of second edge\n# [11] double, multiplier, default: 1E4\n\n! finite rigid wall by multiplier\nfiniterigidwallmultiplier (1) (2...4) (5...7) (8...10)\nconstraint finiterigidwallmultiplier (1) (2...4) (5...7) (8...10)\n# (1) int, unique constraint tag\n# (2...4) double, coordinates of origin of rigid wall\n# (5...7) double, vector of first edge\n# (8...10) double, vector of second edge\n</code></pre>"},{"location":"Library/Constraint/RigidWall/#remarks","title":"Remarks","text":"<ol> <li>The normal vector of finite rigid walls is computed by cross product between two edges defined. Beware of the order.</li> <li>The penalty function method can be used in both static and dynamic analysis.</li> <li>The multiplier method can only be used in static analysis.</li> <li>Both methods do not perform well in dynamic analysis, to conserve energy and momentum, users may use the     <code>RestitutionWall</code> constraint instead.</li> </ol>"},{"location":"Library/Converger/Converger/","title":"Converger","text":"<p>Though the term <code>converger</code> is not a valid word, it is used to denote the object that provide information about if the system converges.</p>"},{"location":"Library/Converger/Converger/#syntax","title":"Syntax","text":"<p>All convergers, except for <code>Logic</code> and <code>FixedNumber</code>, share the same definition.</p> Text Only<pre><code>converger (1) (2) (3) (4) [5]\n# (1) string, converger type\n# (2) int, unique tag\n# (3) double, tolerance\n# (4) int, maximum iteration\n# [5] bool string, print switch, default: false\n</code></pre>"},{"location":"Library/Converger/Converger/#available-convergers","title":"Available Convergers","text":"<p>Currently, following convergers are available.</p> <ul> <li>AbsDisp</li> <li>AbsError</li> <li>AbsIncreDisp</li> <li>AbsIncreEnergy</li> <li>AbsIncreAcc</li> <li>AbsResidual</li> <li>RelDisp</li> <li>RelError</li> <li>RelIncreDisp</li> <li>RelIncreEnergy</li> <li>RelIncreAcc</li> <li>RelResidual</li> <li>FixedNumber</li> <li>Logic</li> </ul>"},{"location":"Library/Converger/Absolute/AbsDisp/","title":"AbsDisp","text":"<p>Absolute Displacement</p> <p>This converger tests the following norm,</p> \\[ \\left|\\mathbf{U}\\right|\\leqslant{}tol. \\] <p>where \\(\\(\\mathbf{U}\\)\\) denotes the total displacement of the system (with all trial displacement increments accounted). This means</p> \\[ \\mathbf{U}=\\mathbf{U}_n+\\sum_{i=1}^{k}\\Delta\\mathbf{U}^i, \\] <p>where \\(\\(\\mathbf{U}_n\\)\\) denotes the converged displacement at the beginning of current sub-step and \\(\\(\\Delta\\mathbf{U}^i\\)\\) denote all displacement increments/corrections generated by all iterations of the sub-step.</p>"},{"location":"Library/Converger/Absolute/AbsError/","title":"AbsError","text":"<p>Absolute Error</p> <p>This converger tests the following ratio,</p> \\[ \\left|\\mathbf{E}\\right|\\leqslant{}tol. \\] <p>where \\(\\(\\mathbf{E}\\)\\) denotes the error vector set by other solvers, etc..</p>"},{"location":"Library/Converger/Absolute/AbsIncreAcc/","title":"AbsIncreAcc","text":"<p>Absolute Acceleration Increment</p> <p>In the governing equation,</p> \\[ \\mathbf{M\\Delta{}A=R}, \\] <p>this converger tests the norm of displacement increment, viz.,</p> \\[ \\left|\\mathbf{\\Delta{}A}\\right|\\leqslant{}tol. \\] <p>The equation of motion based on acceleration is conventionally the governing equation in explicit analysis.</p>"},{"location":"Library/Converger/Absolute/AbsIncreDisp/","title":"AbsIncreDisp","text":"<p>Absolute Displacement Increment</p> <p>In the governing equation,</p> \\[ \\mathbf{K\\Delta{}U=R}, \\] <p>this converger tests the norm of displacement increment, viz.,</p> \\[ \\left|\\mathbf{\\Delta{}U}\\right|\\leqslant{}tol. \\]"},{"location":"Library/Converger/Absolute/AbsIncreEnergy/","title":"AbsIncreEnergy","text":"<p>Absolute Energy Increment</p> <p>In the governing equation,</p> \\[ \\mathbf{K\\Delta{}U=R}, \\] <p>this converger tests the magnitude of the product of displacement increment and residual, viz.,</p> \\[ \\left|\\mathbf{\\Delta{}U\\cdot{}R}\\right|\\leqslant{}tol. \\]"},{"location":"Library/Converger/Absolute/AbsResidual/","title":"AbsResidual","text":"<p>Absolute Residual</p> <p>In the governing equation,</p> \\[ \\mathbf{K\\Delta{}U=R}, \\] <p>this converger tests the norm of residual,</p> \\[ \\left|\\mathbf{R}\\right|\\leqslant{}tol. \\]"},{"location":"Library/Converger/Other/FixedNumber/","title":"FixedNumber","text":"<p>The algorithm iterates at most a fixed number of times. Even if the system does not converge, the analysis goes on.</p>"},{"location":"Library/Converger/Other/FixedNumber/#syntax","title":"Syntax","text":"Text Only<pre><code>converger FixedNumber (1) (2) [3]\n# (1) int, unique tag\n# (2) int, maximum iteration\n# [3] bool string, print switch, default: false\n</code></pre>"},{"location":"Library/Converger/Other/Logic/","title":"Logic","text":"<p>Sometimes, it is necessary to apply multiple convergers.</p> <p>The <code>Logic</code> family provides some logical combinations of convergers so that it is convenient to chain arbitrary number of convergers together.</p>"},{"location":"Library/Converger/Other/Logic/#syntax","title":"Syntax","text":"Text Only<pre><code>converger LogicAND (1) (2) (3)\nconverger LogicOR (1) (2) (3)\nconverger LogicXOR (1) (2) (3)\n# (1) int, unique converger tag\n# (2) int, tag of first converger in logical operation\n# (3) int, tag of second converger in logical operation\n</code></pre>"},{"location":"Library/Converger/Other/Logic/#example","title":"Example","text":"<p>Let's assume by default the relative increment of displacement <code>RelIncreDisp</code> converger is preferred. However, when performing a response history analysis, when the first displacement increment of some substep is close to zero, then a small relative increment of displacement is not achievable due to machine precision. In this case, we want to add another converger using absolute increment of displacement <code>AbsIncreDisp</code> converger so that when absolute increment displacement is small enough, the analysis is continued.</p> <p>It is possible to use <code>LogicOR</code> to achieve this.</p> Text Only<pre><code>converger RelIncreDisp 1 1E-10 10 true\nconverger AbsIncreDisp 2 1E-10 10 true\nconverger LogicOR 3 1 2\n</code></pre> <p>Note the last defined converger in any step will be used for that particular step. In this case, converger <code>3</code> using <code>LogicOR</code> would be used.</p> <p>The following definition does not work.</p> Text Only<pre><code>converger LogicOR 3 1 2\nconverger RelIncreDisp 1 1E-10 10 true\nconverger AbsIncreDisp 2 1E-10 10 true\n</code></pre> <p>The chained convergers would be initialised recursively. This means it is possible to chain arbitrary number of convergers together. For example,</p> Text Only<pre><code>converger RelIncreDisp 1 1E-10 10 true\nconverger AbsIncreDisp 2 1E-10 10 true\nconverger LogicOR 3 1 2\nconverger AbsResidual 4 1E-10 10 true\nconverger LogicAND 5 3 4\n</code></pre> <p>Eventually, the converger <code>5</code> will be used, in which convergers <code>1</code>, <code>2</code> and <code>4</code> will be called in order.</p>"},{"location":"Library/Converger/Relative/RelDisp/","title":"RelDisp","text":"<p>Relative Displacement</p> <p>In the governing equation,</p> \\[ \\mathbf{K\\Delta{}U=R}, \\] <p>this converger tests the following ratio,</p> \\[ \\left|\\mathbf{\\dfrac{\\Delta{}U}{U}}\\right|\\leqslant{}tol. \\] <p>where \\(\\(\\mathbf{\\Delta{}U}\\)\\) denotes the displacement increment of the current sub-step and \\(\\(\\mathbf{U}\\)\\) denotes the total displacement of the system.</p>"},{"location":"Library/Converger/Relative/RelError/","title":"RelError","text":"<p>Relative Error</p> <p>This converger tests the following ratio,</p> \\[ \\left|\\mathbf{\\dfrac{E}{U}}\\right|\\leqslant{}tol. \\] <p>where \\(\\(\\mathbf{E}\\)\\) denotes the error vector set by other solvers, etc., and \\(\\(\\mathbf{U}\\)\\) denotes the total displacement of the system.</p>"},{"location":"Library/Converger/Relative/RelIncreAcc/","title":"RelIncreAcc","text":"<p>Relative Acceleration Increment</p> <p>In the governing equation,</p> \\[ \\mathbf{M\\Delta{}A=R}, \\] <p>this converger tests the following ratio,</p> \\[ \\left|\\mathbf{\\dfrac{\\Delta{}A^k}{\\sum_{i=0}^{k}\\Delta{}A^i}}\\right|\\leqslant{}tol. \\] <p>where \\(\\(\\mathbf{\\Delta{}A^k}\\)\\) denotes the acceleration increment of the \\(\\(k\\)\\)-th iteration.</p>"},{"location":"Library/Converger/Relative/RelIncreDisp/","title":"RelIncreDisp","text":"<p>Relative Displacement Increment</p> <p>In the governing equation,</p> \\[ \\mathbf{K\\Delta{}U=R}, \\] <p>this converger tests the following ratio,</p> \\[ \\left|\\mathbf{\\dfrac{\\Delta{}U^k}{\\sum_{i=0}^{k}\\Delta{}U^i}}\\right|\\leqslant{}tol. \\] <p>where \\(\\(\\mathbf{\\Delta{}U^k}\\)\\) denotes the displacement increment of the \\(\\(k\\)\\)-th iteration.</p>"},{"location":"Library/Converger/Relative/RelIncreEnergy/","title":"RelIncreEnergy","text":"<p>Relative Energy Increment</p> <p>In the governing equation,</p> \\[ \\mathbf{K\\Delta{}U=R}, \\] <p>this converger tests the magnitude of the product of displacement increment and residual, viz.,</p> \\[ \\left|\\mathbf{\\Delta{}U\\cdot{}R}\\right|\\leqslant{}tol. \\]"},{"location":"Library/Converger/Relative/RelResidual/","title":"RelResidual","text":"<p>Relative Residual</p> <p>In the governing equation,</p> \\[ \\mathbf{K\\Delta{}U=R}, \\] <p>this converger tests the norm of residual,</p> \\[ \\left|\\mathbf{R}\\right|\\leqslant{}tol. \\]"},{"location":"Library/Criterion/Criterion/","title":"Criterion","text":"<p>What is a <code>Criterion</code>? The <code>Criterion</code>, as the name implies, is some sort of criterion that may or may not be satisfied by some quantities of the model.</p> <p>The main motivation to have a <code>Criterion</code> is to terminate the <code>ArcLength</code> analysis. In a typical <code>ArcLength</code> analysis, neither the displacement nor the resistance is known in advance. There should be a way to determine when to stop the analysis.</p> <p>A <code>Criterion</code> provides such a functionality. If the <code>Criterion</code> is satisfied, an <code>exit</code> flag will be sent out so that the analysis will stop.</p> <p>Due to its designed functionality, a <code>Criterion</code> can also be used to early-stop the analysis.</p>"},{"location":"Library/Criterion/MaxDisplacement/","title":"MaxDisplacement","text":"<p>The <code>MaxDisplacement</code> criterion tests the displacement of the specified node, if it is greater the given value, the analysis is terminated.</p>"},{"location":"Library/Criterion/MaxDisplacement/#syntax","title":"Syntax","text":"Text Only<pre><code>criterion MaxDisplacement (1) (2) (3) (4)\n# (1) int, unique criterion tag\n# (2) int, node\n# (3) int, dof\n# (4) double, limit\n</code></pre>"},{"location":"Library/Criterion/MaxHistory/","title":"MaxHistory","text":"<p>The <code>MaxHisotry</code> criterion tests the specified historical variable, if it exceeds the given value, the corresponding element is disabled.</p>"},{"location":"Library/Criterion/MaxHistory/#syntax","title":"Syntax","text":"Text Only<pre><code>criterion MaxHisotry (1) (2) (3)\n# (1) int, unique criterion tag\n# (2) string, history vairable type\n# (3) double, limit\n</code></pre>"},{"location":"Library/Criterion/MaxResistance/","title":"MaxResistance","text":"<p>The <code>MaxResistance</code> criterion tests the resistance of the specified node, if it is greater than the given value, the analysis is terminated.</p>"},{"location":"Library/Criterion/MaxResistance/#syntax","title":"Syntax","text":"Text Only<pre><code>criterion MaxResistance (1) (2) (3) (4)\n# (1) int, unique criterion tag\n# (2) int, node\n# (3) int, dof\n# (4) double, limit\n</code></pre>"},{"location":"Library/Criterion/MinDisplacement/","title":"MinResistance","text":"<p>The <code>MinResistance</code> criterion tests the resistance of the specified node, if it is smaller than the given value, the analysis is terminated.</p>"},{"location":"Library/Criterion/MinDisplacement/#syntax","title":"Syntax","text":"Text Only<pre><code>criterion MinResistance (1) (2) (3) (4)\n# (1) int, unique criterion tag\n# (2) int, node\n# (3) int, dof\n# (4) double, limit\n</code></pre>"},{"location":"Library/Criterion/MinResistance/","title":"MinDisplacement","text":"<p>The <code>MinDisplacement</code> criterion tests the displacement of the specified node, if it is smaller than the given value, the analysis is terminated.</p>"},{"location":"Library/Criterion/MinResistance/#syntax","title":"Syntax","text":"Text Only<pre><code>criterion MinDisplacement (1) (2) (3) (4)\n# (1) int, unique criterion tag\n# (2) int, node\n# (3) int, dof\n# (4) double, limit\n</code></pre>"},{"location":"Library/Criterion/StrainEnergyEvolution/","title":"StrainEnergyEvolution","text":"<p>This <code>StrainEnergyEvolution</code> criterion implements the BSEO Method. It can be used in structural optimization. To define one,</p> Text Only<pre><code>criterion StrainEnergyEvolution (1) (2) (3) [4] [5] [6] [7] [8]\n# (1) int, unique criterion tag\n# (2) int, increment of rejection level in percentage\n# (3) int, target rejection level in percentage\n# [4] double, weight of central element, used in averaging\n# [5] int, number of iterations of averaging\n# [6] int, reactivation rate in percentage\n# [7] double, propagation weight\n# [8] double, tolerance\n</code></pre>"},{"location":"Library/Criterion/StrainEnergyEvolution/#caveat","title":"Caveat","text":"<ol> <li>It is recommended to use consecutive tags for elements starting from \\(\\(1\\)\\). Large tags will increase memory usage.</li> </ol>"},{"location":"Library/Criterion/StrainEnergyEvolution/#theory","title":"Theory","text":"<p>Readers can refer to the monograph Evolutionary Topology Optimization of Continuum Structures: Methods and Applications for detailed discussion of the Bi-directional Evolutionary Structural Optimization Method.</p> <p>Here a brief introduction is presented to explain what the <code>StrainEnergyEvolution</code> criterion does to the model.</p> <p>To perform optimization with <code>StrainEnergyEvolution</code>, a <code>Optimization</code> step shall be defined instead of a standard static step.</p> Text Only<pre><code>step Optimization (1) [2]\n# (1) int, unique step tag\n# [2] double, step length, default: 1.0\n</code></pre> <p>The <code>ESO</code> step performs the complete static analysis step and calls the criterion to modify/update the model repeatedly until an exit signal is received. The exit signal is often returned by a proper <code>criterion</code>.</p>"},{"location":"Library/Criterion/StrainEnergyEvolution/#collect-strain-energy","title":"Collect Strain Energy","text":"<p>The first step is to collect the normalized strain energy of each element. If the element is currently inactive, the corresponding strain energy will be set to zero. The normalization uses the characteristic length of the corresponding element.</p>"},{"location":"Library/Criterion/StrainEnergyEvolution/#averaging","title":"Averaging","text":"<p>Instead of the original node based averaging procedure, which requires to compute the sensitivity parameter of the connected nodes, the <code>StrainEnergyEvolution</code> criterion uses a convolution filter type process. The averaged strain energy is updated by computing the weighted average of the strain energy of all connected elements. Say the target element, denoted with subscript \\(\\(j\\)\\), is connected to \\(\\(m=n-1\\)\\) elements. Accounting for the target element itself, there are \\(\\(n\\)\\) elements under consideration. The strain energy of each element before averaging is denoted by \\(\\(\\alpha_i\\)\\). Then the averaged strain energy of that element \\(\\(\\bar\\alpha\\)\\) can be computed by</p> \\[ \\bar\\alpha_j=\\sum^{n}_{i=1}w_i\\alpha_i,\\qquad{}w_j=Ww_i\\quad\\text{for }i\\neq{}j,\\qquad\\sum^{n}_{i=1}w_i=1. \\] <p>The parameter \\(\\(W\\)\\) is controlled by the fourth input argument <code>[4]</code>.</p> <p>For the above averaging process, each element can affect the adjacent elements, resulting in a smoothed distribution of strain energy. Such a process can be repeated several times to further average the result. The number of the averaging process is controlled by the fifth input argument <code>[5]</code>.</p>"},{"location":"Library/Criterion/StrainEnergyEvolution/#stabilization","title":"Stabilization","text":"<p>Collect all averaged strain energy into a vector and denote it with \\(\\(\\mathbf{\\alpha}^k\\)\\), it is stabilized by considering the strain energy of the previous iteration \\(\\(\\mathbf{\\alpha}^{k-1}\\)\\),</p> \\[ \\mathbf{\\alpha}^k\\leftarrow\\left(1-w_p\\right)\\mathbf{\\alpha}^{k-1}+w_p\\dfrac{1}{2}\\mathbf{\\alpha}^k. \\] <p>So even if some elements are deleted in the current iteration by accident, they can be added back to the model in the next iteration as the stabilized \\(\\(\\mathbf{\\alpha}^k\\)\\) now has some memory. The parameter \\(\\(w_p\\)\\) is controlled by input parameter <code>[7]</code>.</p>"},{"location":"Library/Criterion/StrainEnergyEvolution/#additiondeletion-of-elements","title":"Addition/Deletion of Elements","text":"<p>The rejection ratio starts from zero with an increment of \\(\\(\\Delta{}r\\)\\) till reaching the target rejection ratio \\(\\(r_ {target}\\)\\) and then stays unchanged. The increment \\(\\(\\Delta{}r\\)\\) is controlled by parameter <code>(2)</code> and the rejection ratio \\(\\(r_{target}\\)\\) is controlled by parameter <code>(3)</code>.</p> <p>For the current rejection ratio \\(\\(r\\)\\), \\(\\(r\\%\\)\\) of total elements will be removed in the current iteration. However, before removing any elements, some already removed elements will be added first, called reactivation. The number of reactivated elements is controlled by the reactivation ratio \\(\\(r_a\\)\\), which is parameter <code>[6]</code>. So \\(\\(r_a\\%\\)\\) of already removed elements will be added to the model.</p> <p>After reactivation, the number of active elements is the sum of numbers of reactivated elements and already active elements.</p> <p>The averaged strain energy of all active elements will be sorted to determine which elements shall be removed. The number of removed elements is the difference of current number of active elements and the current rejection ratio.</p>"},{"location":"Library/Criterion/StrainEnergyEvolution/#convergence","title":"Convergence","text":"<p>The convergence is achieved when the relative energy difference between two adjacent iterations is smaller than the tolerance, which is controlled by parameter <code>[8]</code>.</p>"},{"location":"Library/Element/Beam/B21/","title":"B21","text":"<p>2D Displacement Based Bernoulli Beam</p> <ul> <li>Number of Nodes: 2</li> <li>Number of DoFs: 3 (Translation, Translation, Rotation)</li> </ul>"},{"location":"Library/Element/Beam/B21/#syntax","title":"Syntax","text":"Text Only<pre><code>element B21 (1) (2) (3) (4) [5] [6]\n# (1) int, unique element tag\n# (2) int, node i\n# (3) int, node j\n# (4) int, section tag\n# [5] int, number of integration points, default: 6\n# [6] bool string, nonlinear geometry switch, default: false\n</code></pre>"},{"location":"Library/Element/Beam/B21/#remarks","title":"Remarks","text":"<ol> <li>The Lobatto integration is used by default. The number of integration points ranges from 3 to 20.</li> <li>To use the corotational formulation for nonlinearity, please turn on the switch.</li> <li>Unlike 3D beam elements, there is no need to attach an <code>orientation</code> to 2D beam elements.</li> </ol>"},{"location":"Library/Element/Beam/B21E/","title":"B21E","text":"<p>2D Displacement Based Bernoulli Beam With End Moment Release</p> <ul> <li>Number of Nodes: 2</li> <li>Number of DoFs: 3 (Translation, Translation, Rotation)</li> </ul>"},{"location":"Library/Element/Beam/B21E/#syntax","title":"Syntax","text":"Text Only<pre><code>element B21EL (1) (2) (3) (4) [5] [6]\nelement B21EH (1) (2) (3) (4) [5] [6]\n# (1) int, unique element tag\n# (2) int, node i\n# (3) int, node j\n# (4) int, section tag\n# [5] int, number of integration points, default: 6\n# [6] bool string, nonlinear geometry switch, default: false\n</code></pre>"},{"location":"Library/Element/Beam/B21E/#remarks","title":"Remarks","text":"<ol> <li>The Lobatto integration is used by default. The number of integration points ranges from 3 to 20.</li> <li>To use the corotational formulation for nonlinearity, please turn on the switch.</li> <li>To release end moment at node <code>(2)</code>, use element <code>B21EL</code> in which <code>L</code> stands for low.</li> <li>To release end moment at node <code>(3)</code>, use element <code>B21EH</code> in which <code>H</code> stands for high.</li> <li>Analysts shall ensure the node with moment released must be connected to other elements that has in-plane rotational    DoF.</li> <li>Local iterations are performed to achieve a tolerance of <code>1E-13</code>.</li> <li>Since additional rotation is involved to achieve a pinned connection, visualisation is not available.</li> <li>Unlike 3D beam elements, there is no need to attach an <code>orientation</code> to 2D beam elements.</li> </ol>"},{"location":"Library/Element/Beam/B21H/","title":"B21H","text":"<p>2D Displacement Based Bernoulli Beam With Lumped End Hinges</p> <ul> <li>Number of Nodes: 2</li> <li>Number of DoFs: 3 (Translation, Translation, Rotation)</li> </ul>"},{"location":"Library/Element/Beam/B21H/#syntax","title":"Syntax","text":"Text Only<pre><code>element B21H (1) (2) (3) (4) [5] [6]\n# (1) int, unique element tag\n# (2) int, node i\n# (3) int, node j\n# (4) int, section tag\n# [5] double, normalized length of each end hinge, default: 0.2\n# [6] bool string, nonlinear geometry switch, default: false\n</code></pre>"},{"location":"Library/Element/Beam/B21H/#remarks","title":"Remarks","text":"<ol> <li>The interior is assumed to be elastic so the response can be precomputed. For each end hinge, two integration points    are used.</li> <li>To use the corotational formulation for nonlinearity, please turn on the switch <code>[6]</code>.</li> <li>This element may not be that useful since the plastic rotation of end hinges are constrained by the displacement    interpolation function, which is a cubic polynomial.</li> <li>Unlike 3D beam elements, there is no need to attach an <code>orientation</code> to 2D beam elements.</li> </ol>"},{"location":"Library/Element/Beam/B31/","title":"B31","text":"<p>3D Displacement Based Bernoulli Beam</p> <ul> <li>Number of Nodes: 2</li> <li>Number of DoFs: 6 (Translation, Translation, Translation, Rotation, Rotation, Rotation)</li> </ul>"},{"location":"Library/Element/Beam/B31/#syntax","title":"Syntax","text":"Text Only<pre><code>element B31 (1) (2) (3) (4) (5) [6] [7]\n# (1) int, unique element tag\n# (2) int, node i\n# (3) int, node j\n# (4) int, section tag\n# (5) int, orientation tag\n# [6] int, number of integration points, default: 5\n# [7] int, nonlinear geometry switch, default: false\n</code></pre>"},{"location":"Library/Element/Beam/B31/#remarks","title":"Remarks","text":"<ol> <li>The Lobatto integration is used by default. The number of integration points ranges from 3 to 20.</li> <li>Please check <code>orientation</code> for its definition.</li> <li>To use the corotational formulation for nonlinearity, please attach a corotational formulation enabled <code>orientation</code>.</li> </ol>"},{"location":"Library/Element/Beam/Beam/","title":"Beam Element Overview","text":""},{"location":"Library/Element/Beam/Beam/#local-cs","title":"Local CS","text":"<p>The beam section possesses a local coordinate system that differs from the global coordinate system. The local \\(\\(x\\)\\)-axis is aligned with beam cord. Strong axis is represented by local \\(\\(z\\)\\)-axis while weak axis is represented by local \\(\\(y\\)\\)-axis. The local \\(\\(xyz\\)\\) axes form a right-handed coordinate system.</p>"},{"location":"Library/Element/Beam/Beam/#orientation","title":"Orientation","text":"<p>For 2D beams, it is assumed that local \\(\\(z\\)\\)-axis coincides with global \\(\\(z\\)\\)-axis so that there is no need to explicitly define any orientation for 2D beams.</p> <p>For 3D beams, local \\(\\(z\\)\\)-axis shall be defined in the associated section orientation.</p>"},{"location":"Library/Element/Beam/Beam/#local-deformation","title":"Local Deformation","text":"<p>The local deformation vector consists of six components, namely,</p> \\[ \\mathbf{d}=\\begin{bmatrix} u&amp;\\theta_{zi}&amp;\\theta_{zj}&amp;\\theta_{yi}&amp;\\theta_{yj}&amp;\\theta_{xj}-\\theta_{xi} \\end{bmatrix}. \\] <p>They correspond to axial elongation, strong axis rotation at first and second node, weak axis rotation at first and second node, and torsion rotation.</p> <p>For 2D beams, only the first three are present.</p> <p>Any sections shall take the above deformation vector over element length, that is,</p> \\[ \\mathbf{d}/L \\] <p>as input and produce the corresponding force conjugates (section resistance) as the output. Please note the  deformation vector is normalised by element length. This offers some convenience so that sections are independent  of element properties. The same section can be used for different elements with different element lengths.</p>"},{"location":"Library/Element/Beam/Beam/#which-element-to-be-used","title":"Which Element To Be Used?","text":"<p>A few different general purpose beam elements are available.</p>"},{"location":"Library/Element/Beam/Beam/#displacement-based","title":"Displacement Based","text":"<p>The <code>B21</code> and <code>B31</code> are classic Bernoulli beam elements, which are probably the first beam  elements introduced in any FEM textbooks. They are displacement based elements, meaning that the displacement  profile along beam chord always follows the Hermite polynomial. This is fine for elastic analysis but may not be  suitable for plastic analysis. The nonlinear response is often over stiff. Accuracy can be improved by mesh  refinement, but it appears a bit cumbersome to define multiple elements within the same span/floor with interior  nodes do not connect additional frames.</p> <p>To model hinge connection at one of two ends, one can use <code>B21E</code> so that either the first or the second  end has zero moment. To specify the explicit plastic hinge length, one can use <code>B21H</code>. Plasticity is only  allowed at ends with a fixed length while the interior remains elastic.</p>"},{"location":"Library/Element/Beam/Beam/#force-based","title":"Force Based","text":"<p>The force based beam elements appear to be superior in all cases. This category includes <code>F21</code> and  <code>F31</code> elements. The moment distribution along beam chord is always linear in absence of distributed load. It  is shown that force based elements result in less error with the same number of integration points, and converges  faster with increasing number of integration points, see <code>this paper</code>.</p> <p>Typically, five to seven integration points would be sufficient for each element. Mesh refinement is often not  necessary and can be alternatively replaced by adding more integration points to a single element.</p>"},{"location":"Library/Element/Beam/Beam/#generalised-plasticity-based","title":"Generalised Plasticity Based","text":"<p>Without using sections, it is possible to model nonlinear beams at element level. The <code>NMB21</code> and  <code>NMB31</code> are two examples of generalised plasticity based beam elements. The efficiency of this type of  elements is the best of the three as there are no sections, no integration points. Only local plasticity iterations  are performed. The applicability mainly depends on the nonlinear behaviour of <code>NMSection</code>.</p>"},{"location":"Library/Element/Beam/EB21/","title":"EB21","text":"<p>2D Elastic Bernoulli Beam</p> <ul> <li>Number of Nodes: 2</li> <li>Number of DoFs: 3 (Translation, Translation, Rotation)</li> </ul>"},{"location":"Library/Element/Beam/EB21/#syntax","title":"Syntax","text":"Text Only<pre><code>element EB21 (1) (2) (3) (4) (5) (6) [7]\n# (1) int, unique element tag\n# (2) int, node i\n# (3) int, node j\n# (4) double, area\n# (5) double, moment inertia\n# (6) int, material tag\n# [7] bool string, nonlinear geometry switch, default: false\n</code></pre>"},{"location":"Library/Element/Beam/EB21/#remarks","title":"Remarks","text":"<ol> <li>No matter what material model is used, only the initial stiffness is used for computation since <code>EB21</code> is an elastic    beam element.</li> <li>Unlike 3D beam elements, there is no need to attach an <code>orientation</code> to 2D beam elements.</li> </ol>"},{"location":"Library/Element/Beam/F21/","title":"F21","text":"<p>2D Force Based Bernoulli Beam</p> <ul> <li>Number of Nodes: 2</li> <li>Number of DoFs: 3 (Translation, Translation, Rotation)</li> </ul>"},{"location":"Library/Element/Beam/F21/#syntax","title":"Syntax","text":"Text Only<pre><code>element F21 (1) (2) (3) (4) [5] [6]\n# (1) int, unique element tag\n# (2) int, node i\n# (3) int, node j\n# (4) int, section tag\n# [5] int, number of integration points, default: 6\n# [6] bool string, nonlinear geometry switch, default: false\n</code></pre>"},{"location":"Library/Element/Beam/F21/#remarks","title":"Remarks","text":"<ol> <li>The Lobatto integration is used by default. The number of integration points ranges from 3 to 20.</li> <li>To use the corotational formulation for nonlinearity, please turn on the switch.</li> <li>Unlike 3D beam elements, there is no need to attach an <code>orientation</code> to 2D beam elements.</li> </ol>"},{"location":"Library/Element/Beam/F21/#output-type","title":"Output Type","text":"<p>The <code>F21</code> element additional support recording element deformation and resistance via the <code>BEAME</code> and <code>BEAMS</code> tokens.</p> <p>For example,</p> Text Only<pre><code>hdf5recorder (1) Element BEAME (2...)\nhdf5recorder (1) Element BEAMS (2...)\n# (1) int, unique recorder tag\n# (2...) int, tags of elements to record\n</code></pre>"},{"location":"Library/Element/Beam/F21H/","title":"F21H","text":"<p>2D Force Based Bernoulli Beam With Lumped End Hinges</p> <ul> <li>Number of Nodes: 2</li> <li>Number of DoFs: 3 (Translation, Translation, Rotation)</li> </ul>"},{"location":"Library/Element/Beam/F21H/#syntax","title":"Syntax","text":"Text Only<pre><code>element F21H (1) (2) (3) (4) [5] [6]\n# (1) int, unique element tag\n# (2) int, node i\n# (3) int, node j\n# (4) int, section tag\n# [5] double, normalized length of each end hinge, default: 0.2\n# [6] bool string, nonlinear geometry switch, default: false\n</code></pre>"},{"location":"Library/Element/Beam/F21H/#remarks","title":"Remarks","text":"<ol> <li>The interior is assumed to be elastic so the response can be precomputed. For each end hinge, two integration points    are used.</li> <li>To use the corotational formulation for nonlinearity, please turn on the switch.</li> <li>Unlike 3D beam elements, there is no need to attach an <code>orientation</code> to 2D beam elements.</li> </ol>"},{"location":"Library/Element/Beam/F21H/#output-type","title":"Output Type","text":"<p>The <code>F21H</code> element additional support recording element deformation and resistance via the <code>BEAME</code> and <code>BEAMS</code> tokens.</p> <p>For example,</p> Text Only<pre><code>hdf5recorder (1) Element BEAME (2...)\nhdf5recorder (1) Element BEAMS (2...)\n# (1) int, unique recorder tag\n# (2...) int, tags of elements to record\n</code></pre>"},{"location":"Library/Element/Beam/F31/","title":"F31","text":"<p>3D Displacement Based Bernoulli Beam</p> <ul> <li>Number of Nodes: 2</li> <li>Number of DoFs: 6 (Translation, Translation, Translation, Rotation, Rotation, Rotation)</li> </ul>"},{"location":"Library/Element/Beam/F31/#reference","title":"Reference","text":"<ol> <li>10.1016/0045-7949(95)00103-N</li> </ol>"},{"location":"Library/Element/Beam/F31/#syntax","title":"Syntax","text":"Text Only<pre><code>element F31 (1) (2) (3) (4) (5) [6] [7]\n# (1) int, unique element tag\n# (2) int, node i\n# (3) int, node j\n# (4) int, section tag\n# (5) int, orientation tag\n# [6] int, number of integration points, default: 5\n# [7] int, nonlinear geometry switch, default: false\n</code></pre>"},{"location":"Library/Element/Beam/F31/#remarks","title":"Remarks","text":"<ol> <li>The Lobatto integration is used by default. The number of integration points ranges from 3 to 20.</li> <li>Please check <code>orientation</code> for its definition.</li> <li>To use the corotational formulation for nonlinearity, please attach a corotational formulation enabled <code>orientation</code>.</li> </ol>"},{"location":"Library/Element/Beam/F31/#output-type","title":"Output Type","text":"<p>The <code>F31</code> element additional support recording element deformation and resistance via the <code>BEAME</code> and <code>BEAMS</code> tokens.</p> <p>For example,</p> Text Only<pre><code>hdf5recorder (1) Element BEAME (2...)\nhdf5recorder (1) Element BEAMS (2...)\n# (1) int, unique recorder tag\n# (2...) int, tags of elements to record\n</code></pre>"},{"location":"Library/Element/Beam/MVLEM/","title":"MVLEM","text":"<p>Multiple Vertical Line Element Model</p> <ul> <li>Number of Nodes: 2</li> <li>Number of DoFs: 3 (Translation, Translation, Rotation)</li> </ul> <p>The <code>MVLEM</code> element is often used in modelling walls. It is in fact a simplified beam element with shear response.</p> <p>Personally I do not recommend the usage of this element in any cases.</p>"},{"location":"Library/Element/Beam/MVLEM/#syntax","title":"Syntax","text":"Text Only<pre><code>element MVLEM (1) (2) (3) (4) (5) ((6) (7) (8) (9) (10)...)\n# (1) int, unique element tag\n# (2) int, node i\n# (3) int, node j\n# (4) int, material tag of shear spring\n# (5) double, height of shear spring, ranges from 0 to 1\n# (6) double, fibre width\n# (7) double, fibre thickness\n# (8) double, reinforcement ratio of target fibre\n# (9) int, concrete material (host) tag\n# (10) int, steel material tag\n</code></pre>"},{"location":"Library/Element/Beam/MVLEM/#remarks","title":"Remarks","text":"<ol> <li>Parameters <code>(6)</code> to <code>(10)</code> form a group of parameters that define a single fibre, if there are multiple fibres, which    is often the case, repeat five parameter group for each fibre.</li> </ol>"},{"location":"Library/Element/Beam/NMB21/","title":"NMB21","text":"<p>2D Displacement Based Bernoulli Beam With \\(\\(N\\)\\)-\\(\\(M\\)\\) Interaction Sections</p> <ul> <li>Number of Nodes: 2</li> <li>Number of DoFs: 3 (Translation, Translation, Rotation)</li> </ul>"},{"location":"Library/Element/Beam/NMB21/#syntax","title":"Syntax","text":"Text Only<pre><code>element NMB21 (1) (2) (3) (4) [5]\n# (1) int, unique element tag\n# (2) int, node i\n# (3) int, node j\n# (4) int, section tag\n# [5] bool string, nonlinear geometry switch, default: false\n</code></pre>"},{"location":"Library/Element/Beam/NMB21/#remarks","title":"Remarks","text":"<p>Only <code>NM2D*</code> sections are supported. There is no validation of section attached, analysts shall make sure proper sections are used.</p>"},{"location":"Library/Element/Beam/NMB21/#output-type","title":"Output Type","text":"<p>The <code>NMB21</code> element additional support recording element deformation and resistance via the <code>BEAME</code> and <code>BEAMS</code> tokens.</p> <p>For example,</p> Text Only<pre><code>hdf5recorder (1) Element BEAME (2...)\nhdf5recorder (1) Element BEAMS (2...)\n# (1) int, unique recorder tag\n# (2...) int, tags of elements to record\n</code></pre>"},{"location":"Library/Element/Beam/NMB21E/","title":"NMB21E","text":"<p>2D Displacement Based Bernoulli Beam With \\(\\(N\\)\\)-\\(\\(M\\)\\) Interaction Sections And End Moment Release</p> <ul> <li>Number of Nodes: 2</li> <li>Number of DoFs: 3 (Translation, Translation, Rotation)</li> </ul>"},{"location":"Library/Element/Beam/NMB21E/#syntax","title":"Syntax","text":"Text Only<pre><code>element NMB21EL (1) (2) (3) (4) [5]\nelement NMB21EH (1) (2) (3) (4) [5]\n# (1) int, unique element tag\n# (2) int, node i\n# (3) int, node j\n# (4) int, section tag\n# [5] bool string, nonlinear geometry switch, default: false\n</code></pre>"},{"location":"Library/Element/Beam/NMB21E/#remarks","title":"Remarks","text":"<p>Only <code>NM2D*</code> sections are supported. There is no validation of section attached, analysts shall make sure proper sections are used.</p> <p>The <code>NMB21EL</code> element releases the moment at low node <code>i</code> and the <code>NMB21EH</code> element releases the moment at high node  <code>j</code>.</p> <p>A non-iterative algorithm is used.</p>"},{"location":"Library/Element/Beam/NMB21E/#output-type","title":"Output Type","text":"<p>The <code>NMB21E</code> element additional support recording element deformation and resistance via the <code>BEAME</code> and <code>BEAMS</code> tokens.</p> <p>For example,</p> Text Only<pre><code>hdf5recorder (1) Element BEAME (2...)\nhdf5recorder (1) Element BEAMS (2...)\n# (1) int, unique recorder tag\n# (2...) int, tags of elements to record\n</code></pre>"},{"location":"Library/Element/Beam/NMB31/","title":"NMB31","text":"<p>3D Displacement Based Bernoulli Beam With \\(\\(N\\)\\)-\\(\\(M\\)\\) Interaction Sections</p> <ul> <li>Number of Nodes: 2</li> <li>Number of DoFs: 6 (Translation, Translation, Translation, Rotation, Rotation, Rotation)</li> </ul>"},{"location":"Library/Element/Beam/NMB31/#syntax","title":"Syntax","text":"Text Only<pre><code>element NMB31 (1) (2) (3) (4) (5)\n# (1) int, unique element tag\n# (2) int, node i\n# (3) int, node j\n# (4) int, section tag\n# (5) int, orientation tag\n</code></pre>"},{"location":"Library/Element/Beam/NMB31/#remarks","title":"Remarks","text":"<ol> <li>Please check <code>orientation</code> for its definition.</li> <li>Only <code>NM3D*</code> sections are supported. There is no validation of section attached, analysts shall make sure proper    sections are used.</li> <li>There is no information about torsion in the formulation. Thus, the local deformation only consists of five (instead    of six) components. But for compatibility with general purpose beam transformation, at element, six components as    usual are computed and stored, the first five are sent to section for computation of response, the torsion response    is assumed to be elastic.</li> </ol>"},{"location":"Library/Element/Beam/NMB31/#output-type","title":"Output Type","text":"<p>The <code>NMB31</code> element additional support recording element deformation and resistance via the <code>BEAME</code> and <code>BEAMS</code> tokens.</p> <p>For example,</p> Text Only<pre><code>hdf5recorder (1) Element BEAME (2...)\nhdf5recorder (1) Element BEAMS (2...)\n# (1) int, unique recorder tag\n# (2...) int, tags of elements to record\n</code></pre>"},{"location":"Library/Element/Beam/Orientation/","title":"Orientation","text":"<p>An <code>orientation</code> is required for 3D beam elements to indicate how the section is oriented. The <code>orientation</code> object also handles transformation between global and local coordinate systems of beam/truss elements.</p> <p>For 2D beam elements, the local \\(\\(z\\)\\)-axis is defined to be the global \\(\\(z\\)\\)-axis.</p>"},{"location":"Library/Element/Beam/Orientation/#syntax","title":"Syntax","text":"Text Only<pre><code>orientation (1) (2) (3) (4) (5)\n# (1) int, unique orientation tag\n# (2) string, orientation type\n# (3) double, x component of local z axis\n# (4) double, y component of local z axis\n# (5) double, z component of local z axis\n</code></pre>"},{"location":"Library/Element/Beam/Orientation/#remarks","title":"Remarks","text":"<ol> <li>For type <code>(2)</code>, currently only <code>B3DL</code> (stands for linear 3D beam transformation) and <code>B3DC</code> (corotational    formulation) available.</li> <li>The <code>B3DC</code> formulation is based on Crisfield's work with modifications. See de Souza's    thesis.</li> </ol>"},{"location":"Library/Element/Cube/C3D20/","title":"C3D20","text":"<p>Second Order Cube/Brick</p> <ul> <li>Number of Nodes: 20</li> <li>Number of DoFs: 3 (All Translation)</li> <li>Supports Body Force</li> <li>Constant Consistent Mass Matrix With Same Order Integration</li> </ul>"},{"location":"Library/Element/Cube/C3D20/#syntax","title":"Syntax","text":"Text Only<pre><code>element C3D20 (1) (2...21) (22) [23] [24]\n# (1) int, unique element tag\n# (2...21) int, twenty corner nodes with conventional order\n# (22) int, material tag\n# [23] bool string, reduced integration scheme switch, default: true\n# [24] bool string, nonlinear geometry switch, default: false\n</code></pre>"},{"location":"Library/Element/Cube/C3D20/#remarks","title":"Remarks","text":"<ol> <li>The nonlinearity is implemented by using total Lagrangian (TL) formulation, turn on the switch to use it.</li> <li>The reduced integration uses 2nd order Gauss scheme.</li> <li>The full integration uses 3rd order Irons scheme.</li> </ol>"},{"location":"Library/Element/Cube/C3D20/#sample","title":"Sample","text":""},{"location":"Library/Element/Cube/C3D4/","title":"C3D4","text":"<p>Linear Tetrahedral</p> <ul> <li>Number of Nodes: 4</li> <li>Number of DoFs: 3 (All Translation)</li> <li>Supports Body Force</li> <li>Integration Scheme: Single Point At Centre</li> <li>Constant Consistent Mass Matrix With Same Order Integration</li> </ul>"},{"location":"Library/Element/Cube/C3D4/#syntax","title":"Syntax","text":"Text Only<pre><code>element C3D4 (1) (2...5) (6) [7]\n# (1) int, unique element tag\n# (2...5) int, four corner nodes with conventional order\n# (6) int, material tag\n# [7] bool string, nonlinear geometry switch, default: false\n</code></pre>"},{"location":"Library/Element/Cube/C3D4/#remarks","title":"Remarks","text":"<ol> <li>The nonlinearity is implemented by using total Lagrangian (TL) formulation, turn on the switch to use it.</li> </ol>"},{"location":"Library/Element/Cube/C3D4/#sample","title":"Sample","text":""},{"location":"Library/Element/Cube/C3D8/","title":"C3D8","text":"<p>Linear Cube/Brick</p> <ul> <li>Number of Nodes: 8</li> <li>Number of DoFs: 3 (All Translation)</li> <li>Supports Body Force</li> <li>Constant Consistent Mass Matrix With Same Order Integration</li> </ul>"},{"location":"Library/Element/Cube/C3D8/#syntax","title":"Syntax","text":"Text Only<pre><code>element C3D8 (1) (2...9) (10) [11] [12]\n# (1) int, unique element tag\n# (2...9) int, eight corner nodes with conventional order\n# (10) int, material tag\n# [11] string, integration scheme, default: \"I\"\n# [12] bool string, nonlinear geometry switch, default: false\n</code></pre>"},{"location":"Library/Element/Cube/C3D8/#remarks","title":"Remarks","text":"<ol> <li>Three integration schemes are available, they are:</li> <li>\"I\" uses Irons six-point scheme.</li> <li>\"R\" uses reduced integration with Gauss scheme, that is one point at the center of the element. Hourglassing       control is automatically enabled.</li> <li>\"G\" uses full integration (2nd order) with Gauss scheme.</li> <li>The nonlinearity is implemented by using total Lagrangian (TL) formulation, turn on the switch to use it.</li> </ol>"},{"location":"Library/Element/Cube/C3D8I/","title":"C3D8I","text":"<p>Linear Cube/Brick With Incompatible Modes</p> <ul> <li>Number of Nodes: 8</li> <li>Number of DoFs: 3 (All Translation)</li> <li>Supports Body Force</li> <li>Integration Scheme: Irons Six-Point</li> <li>Constant Consistent Mass Matrix With Same Order Integration</li> </ul>"},{"location":"Library/Element/Cube/C3D8I/#syntax","title":"Syntax","text":"Text Only<pre><code>element C3D8I (1) (2...9) (10)\n# (1) int, unique element tag\n# (2...9) int, eight corner nodes with conventional order\n# (10) int, material tag\n</code></pre>"},{"location":"Library/Element/Cube/C3D8I/#remarks","title":"Remarks","text":"<ol> <li><code>C3D8I</code> is <code>C3D8</code> with incompatible modes.</li> <li>Nonlinearity is not implemented in <code>C3D8I</code>.</li> </ol>"},{"location":"Library/Element/Cube/CIN3D8/","title":"CIN3D8","text":"<p>Linear Infinite Cube/Brick</p>"},{"location":"Library/Element/Cube/DC3D4/","title":"DC3D4","text":""},{"location":"Library/Element/Cube/DC3D8/","title":"DC3D8","text":""},{"location":"Library/Element/Membrane/CS/","title":"CST/CSM","text":"<p>Couple Stress Triangle/Membrane</p> <ul> <li>Number of Nodes: 3, 4, 5, 6, 7, 8</li> <li>Number of DoFs: 3 (Translation, Translation, Rotation)</li> </ul>"},{"location":"Library/Element/Membrane/CS/#reference","title":"Reference","text":"<ol> <li>arXiv:2207.02544</li> </ol>"},{"location":"Library/Element/Membrane/CS/#syntax","title":"Syntax","text":"Text Only<pre><code>element CST3 (1) (2...*) (3) [4] [5]\nelement CST6 (1) (2...*) (3) [4] [5]\nelement CSM4 (1) (2...*) (3) [4] [5]\nelement CSM5 (1) (2...*) (3) [4] [5]\nelement CSM6 (1) (2...*) (3) [4] [5]\nelement CSM7 (1) (2...*) (3) [4] [5]\nelement CSM8 (1) (2...*) (3) [4] [5]\n# (1) int, unique element tag\n# (2...*) int, corresponding number of node tags\n# (3) int, material tag\n# [4] double, thickness, default: 1.0\n# [5] double, characteristic length, default: -1.0\n</code></pre>"},{"location":"Library/Element/Membrane/CS/#remarks","title":"Remarks","text":"<ol> <li>The geometry definitions of CS elements resemble those of CP elements (e.g., CP3, CP4, CP5, CP6, CP7, CP8).</li> <li>The characteristic length <code>[5]</code> can be left as default value (negative) to automatically determine the value     based on geometry (square root of area), or set to a positive value to manually specify the fixed length.</li> <li>Currently, only supports <code>Elastic2D</code> and <code>Bilinear2D</code>     materials.</li> </ol>"},{"location":"Library/Element/Membrane/DCP3/","title":"DCP3","text":"<p>Constant Strain Triangle With Crack Phase</p> <ul> <li>Number of Nodes: 3</li> <li>Number of DoFs: 3 (Translation, Translation, Damage)</li> <li>Zero Mass Entries On Damage DoFs</li> </ul>"},{"location":"Library/Element/Membrane/DCP3/#reference","title":"Reference","text":"<p>There are a lot of papers on the phase-field model. A staggered scheme with maximum strain energy is adopted as an illustration of implementation.</p> <ul> <li>10.1016/j.commatsci.2016.04.009</li> </ul>"},{"location":"Library/Element/Membrane/DCP3/#syntax","title":"Syntax","text":"Text Only<pre><code>element DCP3 (1) (2...4) (5) (6) (7) [8]\n# (1) int, unique element tag\n# (2...4) int, node i, j, k\n# (5) int, material tag\n# (6) double, characteristic length\n# (7) double, energy release rate\n# [8] double, element thickness, default: 1.0\n</code></pre>"},{"location":"Library/Element/Membrane/DCP3/#remarks","title":"Remarks","text":"<ul> <li>The third DoF is the damage variable. Boundary conditions can be assigned.</li> <li>The characteristic length <code>(7)</code> can be set to zero to automatically determine the value based on geometry.</li> </ul>"},{"location":"Library/Element/Membrane/DCP4/","title":"DCP4","text":"<p>Bilinear Quadrilateral With Crack Phase</p> <ul> <li>Number of Nodes: 4</li> <li>Number of DoFs: 3 (Translation, Translation, Damage)</li> <li>Zero Mass Entries On Damage DoFs</li> </ul>"},{"location":"Library/Element/Membrane/DCP4/#syntax","title":"Syntax","text":"Text Only<pre><code>element DCP4 (1) (2...5) (6) (7) (8) [9]\n# (1) int, unique element tag\n# (2...5) int, node i, j, k, l\n# (6) int, material tag\n# (7) double, characteristic length\n# (8) double, energy release rate\n# [9] double, element thickness, default: 1.0\n</code></pre>"},{"location":"Library/Element/Membrane/DCP4/#remarks","title":"Remarks","text":"<ul> <li>The third DoF is the damage variable. Boundary conditions can be assigned.</li> <li>The characteristic length <code>(7)</code> can be set to zero to automatically determine the value based on geometry.</li> </ul>"},{"location":"Library/Element/Membrane/Membrane/","title":"Guide","text":"<p>Try the following flow chart to find the best membrane element to use.</p> <ol> <li>Is the geometry regular or irregular?</li> <li>regular --- use quadrilateral elements</li> <li>irregular --- use triangular elements</li> </ol>"},{"location":"Library/Element/Membrane/Membrane/#triangular-elements","title":"Triangular Elements","text":"<ol> <li>Is drilling DoF required?</li> <li>yes --- <code>Allman</code></li> <li>no --- go to Q2</li> <li>Prefer speed or accuracy?</li> <li>speed --- <code>CP3</code></li> <li>accuracy --- <code>CP6</code></li> </ol> <p>Noting that <code>CP3</code> element is very rigid and often requires a very dense mesh to get relatively accurate result, it is not recommended for most applications.</p>"},{"location":"Library/Element/Membrane/Membrane/#quadrilateral-elements","title":"Quadrilateral Elements","text":"<ol> <li>Is drilling DoF required?</li> <li>yes --- go to Q2</li> <li>no --- go to Q3</li> <li>Is consistent material stiffness available?</li> <li>yes --- go to Q6</li> <li>no --- <code>GQ12</code></li> <li>Used in elastoplastic applications?</li> <li>yes --- normally mixed formulation is better, go to Q4, alternatively displacement based formulation, go to Q5</li> <li>no --- go to Q5</li> <li>Prefer speed or accuracy?</li> <li>speed --- <code>PS</code></li> <li>accuracy --- <code>QE2</code></li> <li>Prefer speed or accuracy?</li> <li>speed --- <code>CP4I</code> or second option <code>CP4</code></li> <li>accuracy --- <code>CP8R</code> or second option <code>CP8</code></li> <li>Need faster analysis?</li> <li>yes --- <code>SGCMQ</code></li> <li>no --- <code>GCMQ</code></li> </ol>"},{"location":"Library/Element/Membrane/PCPE4DC/","title":"PCPE4DC","text":"<p>Bilinear Quadrilateral With Pore Pressure</p> <ul> <li>Number of Nodes: 4</li> <li>Number of DoFs: 4 (Solid Translation, Solid Translation, Fluid Translation, Fluid Translation)</li> <li>Supports Body Force</li> <li>Constant Consistent Mass Matrix With Same Order Integration</li> </ul>"},{"location":"Library/Element/Membrane/PCPE4DC/#syntax","title":"Syntax","text":"Text Only<pre><code>element PCPE4DC (1) (2...5) (6) (7) (8) (9) (10)\n# (1) int, unique element tag\n# (2...5) int, node i, j, k, l\n# (6) int, solid material tag\n# (7) int, fluid material tag\n# (8) double, alpha\n# (9) double, porosity n\n# (10) double, permeability k\n</code></pre>"},{"location":"Library/Element/Membrane/PCPE4DC/#remarks","title":"Remarks","text":"<p>Only plane strain is supported. Plane stress does not make sense in geotechnical engineering.</p> <p>For fluid phase, an isotropic fluid material can be provided, it mainly provides the bulk modulus of the fluid phase. For example,</p> Text Only<pre><code># material Fluid (tag) (bulk modulus) (density)\nmaterial Fluid 1 1000. 1E-2\n</code></pre> <p>The \\(\\(\\alpha\\)\\) parameter <code>(8)</code> is often close to unity for soils. The porosity \\(\\(n\\)\\) ranges from zero to unity. The isotropic permeability is assumed.</p> <p>Interactions with other elements (with different arrangements of DoFs) can only be fulfilled via constraints.</p>"},{"location":"Library/Element/Membrane/Axisymmetric/CAX3/","title":"CAX3","text":"<p>Axisymmetric Linear Triangle</p> <ul> <li>Number of Nodes: 3</li> <li>Number of DoFs: 2</li> </ul>"},{"location":"Library/Element/Membrane/Axisymmetric/CAX3/#syntax","title":"Syntax","text":"Text Only<pre><code>element CAX3 (1) (2...4) (5) [6]\n# (1) int, unique element tag\n# (2...4) int, node tags\n# (5) int, material tag\n# [6] bool string, nonlinear geometry switch, default: false\n</code></pre>"},{"location":"Library/Element/Membrane/Axisymmetric/CAX4/","title":"CAX4","text":"<p>Axisymmetric Linear Quadrilateral</p> <ul> <li>Number of Nodes: 4</li> <li>Number of DoFs: 2</li> </ul>"},{"location":"Library/Element/Membrane/Axisymmetric/CAX4/#syntax","title":"Syntax","text":"Text Only<pre><code>element CAX4 (1) (2...5) (6)\n# (1) int, unique element tag\n# (2...5) int, node i, j, k, l\n# (6) int, material tag\n</code></pre>"},{"location":"Library/Element/Membrane/Axisymmetric/CAX8/","title":"CAX8","text":"<p>Axisymmetric Quadratic Quadrilateral</p> <ul> <li>Number of Nodes: 8</li> <li>Number of DoFs: 2</li> </ul>"},{"location":"Library/Element/Membrane/Axisymmetric/CAX8/#syntax","title":"Syntax","text":"Text Only<pre><code>element CAX8 (1) (2...9) (10)\n# (1) int, unique element tag\n# (2...9) int, node tags\n# (10) int, material tag\n</code></pre>"},{"location":"Library/Element/Membrane/Drilling/Allman/","title":"Allman","text":"<p>Allman's Triangle With Drilling DoFs</p> <ul> <li>Number of Nodes: 3</li> <li>Number of DoFs: 3 (Translation, Translation, Rotation)</li> </ul>"},{"location":"Library/Element/Membrane/Drilling/Allman/#syntax","title":"Syntax","text":"Text Only<pre><code>element Allman (1) (2...4) (5) [6]\n# (1) int, unique element tag\n# (2...4) int, node i, j, k\n# (5) int, material tag\n# [6] double, element thickness, default: 1.0\n</code></pre>"},{"location":"Library/Element/Membrane/Drilling/Allman/#remarks","title":"Remarks","text":"<ul> <li>Three middle points on edges are used as integration points.</li> </ul>"},{"location":"Library/Element/Membrane/Drilling/GCMQ/","title":"(S)GCMQ","text":"<p>Generalised Conforming Mixed Quadrilateral With Drilling DoFs</p> <ul> <li>Number of Nodes: 4</li> <li>Number of DoFs: 3 (Translation, Translation, Rotation)</li> <li>Supports Body Force</li> <li>Constant Consistent Mass Matrix With Same Order Integration</li> </ul>"},{"location":"Library/Element/Membrane/Drilling/GCMQ/#references","title":"References","text":"<ol> <li>10.1002/nme.6066</li> <li>10.1016/j.engstruct.2019.109592</li> <li>10.1016/j.engstruct.2020.110760</li> </ol>"},{"location":"Library/Element/Membrane/Drilling/GCMQ/#syntax","title":"Syntax","text":"Text Only<pre><code>element GCMQ (1) (2...5) (6) [7] [8]\n# (1) int, unique element tag\n# (2...5) int, node i, j, k, l\n# (6) int, material tag\n# [7] double, element thickness, default: 1.0\n# [8] string, integration switch, default: \"I\"\n\nelement GCMQI (1) (2...5) (6) [7] [8]\nelement GCMQL (1) (2...5) (6) [7] [8]\nelement GCMQG (1) (2...5) (6) [7] [8]\n# (1) int, unique element tag\n# (2...5) int, node i, j, k, l\n# (6) int, material tag\n# [7] double, element thickness, default: 1.0\n\nelement SGCMQI (1) (2...5) (6) [7] [8]\nelement SGCMQL (1) (2...5) (6) [7] [8]\nelement SGCMQG (1) (2...5) (6) [7] [8]\n# (1) int, unique element tag\n# (2...5) int, node i, j, k, l\n# (6) int, material tag\n# [7] double, element thickness, default: 1.0\n</code></pre>"},{"location":"Library/Element/Membrane/Drilling/GCMQ/#remarks","title":"Remarks","text":"<ul> <li>Three integration schemes are available: \"I\", \"L\" and \"G\".</li> <li>\"I\": Five-Point Irons Scheme</li> <li>\"L\": 3rd Order Lobatto Scheme</li> <li>\"G\": 3rd Order Gauss Scheme</li> <li><code>GCMQ</code> is the full version described in [1] with enhanced strain, <code>SGCMQ</code> is a <code>PS</code> like element with no enhanced   strain, the direct result of which is less computation is required (less than <code>CP8R</code>).</li> </ul>"},{"location":"Library/Element/Membrane/Drilling/GQ12/","title":"GQ12","text":"<p>Quadrilateral With Drilling DoFs</p> <ul> <li>Number of Nodes: 4</li> <li>Number of DoFs: 3 (Translation, Translation, Rotation)</li> <li>Supports Body Force</li> <li>Integration Scheme: 2nd Order Gauss</li> <li>Constant Consistent Mass Matrix With Same Order Integration</li> </ul>"},{"location":"Library/Element/Membrane/Drilling/GQ12/#reference","title":"Reference","text":"<ol> <li>10.1016/0045-7949(94)90356-5</li> </ol>"},{"location":"Library/Element/Membrane/Drilling/GQ12/#syntax","title":"Syntax","text":"Text Only<pre><code>element GQ12 (1) (2...5) (6) [7]\n# (1) int, unique element tag\n# (2...5) int, node i, j, k, l\n# (6) int, material tag\n# [7] double, element thickness, default: 1.0\n</code></pre>"},{"location":"Library/Element/Membrane/Mixed/PS/","title":"PS","text":"<p>Pian-Sumihara Quadrilateral Element</p> <ul> <li>Number of Nodes: 4</li> <li>Number of DoFs: 2 (Translation, Translation)</li> <li>Supports Body Force</li> <li>Integration Scheme: 2nd Order Gauss</li> <li>Constant Consistent Mass Matrix With Same Order Integration</li> </ul>"},{"location":"Library/Element/Membrane/Mixed/PS/#reference","title":"Reference","text":"<ol> <li>https://doi.org/10.1002/nme.1620200911</li> <li>https://doi.org/10.1002/nme.6066</li> </ol>"},{"location":"Library/Element/Membrane/Mixed/PS/#syntax","title":"Syntax","text":"Text Only<pre><code>element PS (1) (2...5) (6) [7]\n# (1) int, unique element tag\n# (2...5) int, node i, j, k, l\n# (6) int, material tag\n# [7] double, element thickness, default: 1.0\n</code></pre>"},{"location":"Library/Element/Membrane/Mixed/PS/#remarks","title":"Remarks","text":"<ol> <li>The original five-parameter stress field is used for stress interpolation.</li> <li>The mixed framework is used to extend the original formulation to accommodate elastoplastic applications.</li> <li>As there is no enhanced strain, no local iteration is required. Hence <code>PS</code> is faster than elements such as <code>QE2</code>.</li> </ol>"},{"location":"Library/Element/Membrane/Mixed/QE2/","title":"QE2","text":"<p>Mixed Four-Node Quadrilateral Element</p> <ul> <li>Number of Nodes: 4</li> <li>Number of DoFs: 2</li> <li>Supports Body Force</li> <li>Integration Scheme: 2nd Order Gauss</li> <li>Constant Consistent Mass Matrix With Same Order Integration</li> </ul>"},{"location":"Library/Element/Membrane/Mixed/QE2/#reference","title":"Reference","text":"<ol> <li>https://doi.org/10.1002/nme.1620381102</li> </ol>"},{"location":"Library/Element/Membrane/Mixed/QE2/#syntax","title":"Syntax","text":"Text Only<pre><code>element QE2 (1) (2...5) (6) [7]\n# (1) int, unique element tag\n# (2...5) int, node i, j, k, l\n# (6) int, material tag\n# [7] double, element thickness, default: 1.0\n</code></pre>"},{"location":"Library/Element/Membrane/Plane/CINP4/","title":"CINP4","text":"<p>Bilinear Infinite Quadrilateral</p> <ul> <li>Number of Nodes: 4</li> <li>Number of DoFs: 2 (Translation, Translation)</li> </ul>"},{"location":"Library/Element/Membrane/Plane/CINP4/#reference","title":"Reference","text":"<ol> <li>https://doi.org/10.1016/0045-7949(84)90019-1</li> </ol>"},{"location":"Library/Element/Membrane/Plane/CINP4/#syntax","title":"Syntax","text":"Text Only<pre><code>element CINP4 (1) (2...5) (6) [7]\n# (1) int, unique element tag\n# (2...5) int, node i, j, k, l\n# (6) int, material tag\n# [7] double, element thickness, default: 1.0\n</code></pre>"},{"location":"Library/Element/Membrane/Plane/CINP4/#remarks","title":"Remarks","text":"<ol> <li>The first two nodes are finite nodes while the latter two are infinite nodes.</li> </ol>"},{"location":"Library/Element/Membrane/Plane/CP3/","title":"CP3","text":"<p>Constant Strain Triangle</p> <ul> <li>Number of Nodes: 3</li> <li>Number of DoFs: 2 (Translation, Translation)</li> <li>Supports Body Force</li> <li>Constant Consistent Mass Matrix With Same Order Integration</li> </ul>"},{"location":"Library/Element/Membrane/Plane/CP3/#syntax","title":"Syntax","text":"Text Only<pre><code>element CP3 (1) (2...4) (5) [6] [7]\n# (1) int, unique element tag\n# (2...4) int, node i, j, k\n# (5) int, material tag\n# [6] double, element thickness, default: 1.0\n# [7] bool string, nonlinear geometry switch, default: false\n</code></pre>"},{"location":"Library/Element/Membrane/Plane/CP3/#remarks","title":"Remarks","text":"<ul> <li>The <code>CP3</code> element resembles CPS3 and CPE3 elements in ABAQUS. It is a constant strain element.</li> <li>A single integration point at the center of the element is used for integration.</li> </ul>"},{"location":"Library/Element/Membrane/Plane/CP4/","title":"CP4","text":"<p>Bilinear Quadrilateral</p> <ul> <li>Number of Nodes: 4</li> <li>Number of DoFs: 2 (Translation, Translation)</li> <li>Supports Body Force</li> <li>Constant Consistent Mass Matrix With Same Order Integration</li> </ul>"},{"location":"Library/Element/Membrane/Plane/CP4/#syntax","title":"Syntax","text":"Text Only<pre><code>element CP4 (1) (2...5) (6) [7] [8] [9]\n# (1) int, unique element tag\n# (2...5) int, node i, j, k, l\n# (6) int, material tag\n# [7] double, element thickness, default: 1.0\n# [8] bool string, reduced integration switch, default: false\n# [9] bool string, nonlinear geometry switch, default: false\n</code></pre>"},{"location":"Library/Element/Membrane/Plane/CP4/#remarks","title":"Remarks","text":"<ul> <li>The <code>CP4</code> element resembles CPS4 and CPE4 elements in ABAQUS.</li> <li>The full integration scheme uses 2-by-2 Gauss scheme and the reduced integration uses a single integration point at   the center of the element.</li> <li>The reduced integration scheme also imports anti-hourglassing technique.</li> </ul>"},{"location":"Library/Element/Membrane/Plane/CP4I/","title":"CP4I","text":"<p>Bilinear Incompatible Quadrilateral</p> <ul> <li>Number of Nodes: 4</li> <li>Number of DoFs: 2 (Translation, Translation)</li> <li>Constant Consistent Mass Matrix With Same Order Integration</li> </ul>"},{"location":"Library/Element/Membrane/Plane/CP4I/#syntax","title":"Syntax","text":"Text Only<pre><code>element CP4I (1) (2...5) (6) [7]\n# (1) int, unique element tag\n# (2...5) int, node i, j, k, l\n# (6) int, material tag\n# [7] double, element thickness, default: 1.0\n</code></pre>"},{"location":"Library/Element/Membrane/Plane/CP5/","title":"CP5","text":"<p>Five-Point Quadrilateral</p> <ul> <li>Number of Nodes: 5</li> <li>Number of DoFs: 2 (Translation, Translation)</li> <li>Supports Body Force</li> <li>Constant Consistent Mass Matrix With Same Order Integration</li> </ul>"},{"location":"Library/Element/Membrane/Plane/CP5/#syntax","title":"Syntax","text":"Text Only<pre><code>element CP5 (1) (2...6) (7) [8] [9]\n# (1) int, unique element tag\n# (2...6) int, node tags that define the element\n# (7) int, material tag\n# [8] double, element thickness, default: 1.0\n# [9] bool string, nonlinear geometry switch, default: false\n</code></pre>"},{"location":"Library/Element/Membrane/Plane/CP6/","title":"CP6","text":"<p>Quadratic Triangle</p> <ul> <li>Number of Nodes: 6</li> <li>Number of DoFs: 2 (Translation, Translation)</li> <li>Supports Body Force</li> <li>Constant Consistent Mass Matrix With Same Order Integration</li> </ul>"},{"location":"Library/Element/Membrane/Plane/CP6/#syntax","title":"Syntax","text":"Text Only<pre><code>element CP6 (1) (2...7) (8) [9] [10]\n# (1) int, unique element tag\n# (2...7) int, node tags that define the element\n# (8) int, material tag\n# [9] double, element thickness, default: 1.0\n# [10] bool string, nonlinear geometry switch, default: false\n</code></pre>"},{"location":"Library/Element/Membrane/Plane/CP7/","title":"CP7","text":"<p>Seven-Point Quadrilateral</p> <ul> <li>Number of Nodes: 7</li> <li>Number of DoFs: 2 (Translation, Translation)</li> <li>Supports Body Force</li> <li>Constant Consistent Mass Matrix With Same Order Integration</li> </ul>"},{"location":"Library/Element/Membrane/Plane/CP7/#syntax","title":"Syntax","text":"Text Only<pre><code>element CP7 (1) (2...8) (9) [10] [11]\n# (1) int, unique element tag\n# (2...8) int, node tags that define the element\n# (9) int, material tag\n# [10] double, element thickness, default: 1.0\n# [11] bool string, nonlinear geometry switch, default: false\n</code></pre>"},{"location":"Library/Element/Membrane/Plane/CP8/","title":"CP8","text":"<p>Second Order Quadrilateral</p> <ul> <li>Number of Nodes: 8</li> <li>Number of DoFs: 2 (Translation, Translation)</li> <li>Supports Body Force</li> <li>Constant Consistent Mass Matrix With Same Order Integration</li> </ul>"},{"location":"Library/Element/Membrane/Plane/CP8/#syntax","title":"Syntax","text":"Text Only<pre><code>element CP8 (1) (2...9) (10) [11] [12] [13]\n# (1) int, unique element tag\n# (2...9) int, node 1 to node 8\n# (10) int, material tag\n# [11] double, element thickness, default: 1.0\n# [12] bool string, reduced integration switch, default: false\n# [13] bool string, nonlinear geometry switch, default: false\n</code></pre>"},{"location":"Library/Element/Membrane/Plane/CP8/#remarks","title":"Remarks","text":"<ul> <li>The <code>CP8</code> element resembles CPS8, CPE8, CPS8R and CPE8R elements in ABAQUS.</li> <li>The full integration scheme uses 3-by-3 Gauss scheme and the reduced integration uses a 2-by-2 scheme.</li> </ul>"},{"location":"Library/Element/Modifier/Modifier/","title":"Modifier","text":""},{"location":"Library/Element/Modifier/Modifier/#brief","title":"Brief","text":"<p>Sometimes it is necessary to modify the existing element data. A concrete example is the damping matrix used in dynamic analyses.</p> <p>In a standard element, stiffness matrix could be solely computed according to its formulation. However, mass matrix could be formulated in multiple ways such as consistent, lumped, to name a few. For lumped formulation, there are also several versions. If the Rayleigh type damping is used, damping matrix shall be related to both mass matrix and stiffness matrix. Furthermore, the weights shall be computed based on global structure properties, in other words, it is not possible to determine those weights within element. Besides, other types of damping formulation could also be used.</p> <p>Such variance existing in element formulation raises a demand of the <code>Modifier</code> class. A <code>Modifier</code> object can exist independently and can access and modify some data of the target elements. This provides great convenience in defining customizable behavior for different elements.</p>"},{"location":"Library/Element/Modifier/Modifier/#remarks","title":"Remarks","text":"<ol> <li>For all the following modifiers presented, if no element tag is provided, the modifier would be applied to all    active elements in the domain.</li> <li>All modifiers would be applied in the order of how they are defined. This is because the modified data would be used    in another modifier, for example, it is possible to apply a lumped mass modifier and then use the modified mass    matrix to form a Rayleigh damping matrix.</li> </ol>"},{"location":"Library/Element/Modifier/Modifier/#simple-lumped-mass","title":"Simple Lumped Mass","text":"Text Only<pre><code>modifier LumpedSimple (1) (2...)\n# (1) int, unique modifier tag\n# (2...) int, element tags\n</code></pre>"},{"location":"Library/Element/Modifier/Modifier/#scale-lumped-mass","title":"Scale Lumped Mass","text":"Text Only<pre><code>modifier LumpedScale (1) (2...)\n# (1) int, unique modifier tag\n# (2...) int, element tags\n</code></pre>"},{"location":"Library/Element/Modifier/Modifier/#rayleigh-damping","title":"Rayleigh Damping","text":"<p>The damping matrix would be defined as</p> \\[ C=aM+bK_C+cK_I+dK_T, \\] <p>where \\(\\(M\\)\\) is the mass matrix, \\(\\(K_C\\)\\) is the current tangent stiffness matrix (converged from the last step), \\(\\(K_I\\)\\) is the initial stiffness and \\(\\(K_T\\)\\) is the trial stiffness of current iteration. To retain quadratic convergence rate, one shall only use \\(K_I\\) and \\(K_C\\). But \\(K_I\\) also leads to unwanted response.</p> Text Only<pre><code>modifier Rayleigh (1) (2) (3) (4) (5) (6...)\n# (1) int, unique modifier tag\n# (2) double, a\n# (3) double, b\n# (4) double, c\n# (5) double, d\n# (6...) int, element tags\n</code></pre>"},{"location":"Library/Element/Modifier/Modifier/#elemental-modal-damping","title":"Elemental Modal Damping","text":"<p>The rigid body modes are assumed to be undampened. The modes whose frequencies are higher than the cut-off frequency is ignored. The Wilson-Penzien approach is applied for each element. Currently, only consistent mass matrix is supported.</p> Text Only<pre><code>modifier ElementalModal (1) (2) (3) (4...)\n# (1) int, unique modifier tag\n# (2) double, cut-off frequency\n# (3) double, damping ratio\n# (4...) int, element tags\n</code></pre>"},{"location":"Library/Element/Patch/Patch/","title":"Patch","text":"<p>Isogeometric Patches</p> <p>In isogeometric analysis, the geometry of elements is defined by NURBS based surfaces or volumes. Several elements are grouped into patches and patches behave similar to traditional finite elements.</p> <p>To define IGA patches, the knot vectors along each dimension and the control node polygon need to be assigned.</p>"},{"location":"Library/Element/Patch/PatchCube/","title":"PatchCube","text":"<p>Patch of Hexahedron Elements</p> <ul> <li>Number of DoFs: 3</li> <li>Number of Nodes: varies</li> <li>Support Mass</li> <li>Support Body Force</li> </ul>"},{"location":"Library/Element/Patch/PatchCube/#syntax","title":"Syntax","text":"<p>A key-value style is used.</p> Text Only<pre><code>element PatchCube (1) -node (2...) -knotx (3...) -knoty (4...) -knotz (5...) -material (6) [-thickness (7)]\n# (1) int, unique element (patch) tag\n# (2...) int, node tags of control node polygon\n# (3...) double, knot vector along x axis\n# (4...) double, knot vector along y axis\n# (5...) double, knot vector along z axis\n# (6) int, material tag\n# (7) double, thickness\n</code></pre>"},{"location":"Library/Element/Patch/PatchQuad/","title":"PatchQuad","text":"<p>Patch of Quadrilateral Elements</p> <ul> <li>Number of DoFs: 2</li> <li>Number of Nodes: varies</li> <li>Support Mass</li> <li>Support Body Force</li> </ul>"},{"location":"Library/Element/Patch/PatchQuad/#syntax","title":"Syntax","text":"<p>A key-value style is used.</p> Text Only<pre><code>element PatchQuad (1) -node (2...) -knotx (3...) -knoty (4...) -material (5) [-thickness (6)]\n# (1) int, unique element (patch) tag\n# (2...) int, node tags of control node polygon\n# (3...) double, knot vector along x axis\n# (4...) double, knot vector along y axis\n# (5) int, material tag\n# (6) double, thickness\n</code></pre>"},{"location":"Library/Element/Plate/DKT3/","title":"DKT3","text":"<p>DKT Triangle Plate</p> <ul> <li>Number of Nodes: 3</li> <li>Number of DoFs: 3 (Translation, Translation, Rotation)</li> </ul>"},{"location":"Library/Element/Plate/DKT3/#syntax","title":"Syntax","text":"Text Only<pre><code>element DKT3 (1) (2...4) (5) (6) [7]\n# (1) int, unique element tag\n# (2...4) int, node i, j, k\n# (5) int, material tag\n# (6) double, thickness\n# [7] int, number of integration points, default: 3\n</code></pre>"},{"location":"Library/Element/Plate/DKT4/","title":"DKT4","text":"<p>DKT Quadrilateral Plate</p> <ul> <li>Number of Nodes: 4</li> <li>Number of DoFs: 3 (Translation, Translation, Rotation)</li> <li>Integration Scheme: 2nd Order Gauss</li> </ul>"},{"location":"Library/Element/Plate/DKT4/#syntax","title":"Syntax","text":"Text Only<pre><code>element DKT4 (1) (2...5) (6) (7) [8]\n# (1) int, unique element tag\n# (2...5) int, node i, j, k, l\n# (6) int, material tag\n# (7) double, thickness\n# [8] int, number of integration points along thickness, default: 3\n</code></pre>"},{"location":"Library/Element/Plate/Mindlin/","title":"Mindlin","text":"<p>Mindlin Plate Element</p> <ul> <li>Number of Nodes: 4</li> <li>Number of DoFs: 3 (Translation, Translation, Rotation)</li> </ul>"},{"location":"Library/Element/Plate/Mindlin/#syntax","title":"Syntax","text":"Text Only<pre><code>element Mindlin (1) (2...5) (6) (7) [8]\n# (1) int, unique element tag\n# (2...5) int, node i, j, k, l\n# (6) int, material tag\n# (7) double, thickness\n# [8] int, number of integration points, default: 5\n</code></pre>"},{"location":"Library/Element/Shell/DKTS3/","title":"DKTS3","text":"<p>DKT Triangle Shell</p> <ul> <li>Number of Nodes: 3</li> <li>Number of DoFs: 6 (Translation, Translation, Translation, Rotation, Rotation, Rotation)</li> </ul>"},{"location":"Library/Element/Shell/DKTS3/#syntax","title":"Syntax","text":"Text Only<pre><code>element DKTS3 (1) (2...4) (5) (6) [7]\n# (1) int, unique element tag\n# (2...4) int, node i, j, k\n# (5) int, material tag\n# (6) double, thickness\n# [7] int, number of integration points, default: 3\n</code></pre>"},{"location":"Library/Element/Shell/DKTS3/#sample","title":"Sample","text":"<p>The model can be downloaded. DKTS3.zip</p> <p></p>"},{"location":"Library/Element/Shell/DKTS4/","title":"DKTS4","text":"<p>DKT Quadrilateral Shell</p> <ul> <li>Number of Nodes: 4</li> <li>Number of DoFs: 6 (Translation, Translation, Translation, Rotation, Rotation, Rotation)</li> </ul>"},{"location":"Library/Element/Shell/DKTS4/#syntax","title":"Syntax","text":"Text Only<pre><code>element DKTS4 (1) (2...5) (6) (7) [8]\n# (1) int, unique element tag\n# (2...5) int, node i, j, k, l\n# (6) int, material tag\n# (7) double, thickness\n# [8] int, number of integration points, default: 3\n</code></pre>"},{"location":"Library/Element/Shell/S4/","title":"S4","text":"<p>Four Node Shell Element</p> <p>The <code>S4</code> shell element uses <code>Mindlin</code> plate element combined with <code>GQ12</code> element.</p> <ul> <li>Number of Nodes: 4</li> <li>Number of DoFs: 6 (Translation, Translation, Translation, Rotation, Rotation, Rotation)</li> </ul>"},{"location":"Library/Element/Shell/S4/#syntax","title":"Syntax","text":"Text Only<pre><code>element S4 (1) (2...5) (6) (7)\n# (1) int, unique element tag\n# (2...5) int, node i, j, k, l\n# (6) int, material tag\n# (7) double, thickness\n</code></pre>"},{"location":"Library/Element/Shell/SGCMS/","title":"SGCMS","text":"<p>Simplified Generalized Conforming Mixed Shell Element</p> <p>A planar shell element uses SGCMQ for membrane action and DKT4 element for plate action.</p> <ul> <li>Number of Nodes: 4</li> <li>Number of DoFs: 6 (Translation, Translation, Translation, Rotation, Rotation, Rotation)</li> <li>Integration Membrane: Five-Point Irons Scheme</li> <li>Integration Plate: 3rd Gauss Scheme</li> </ul>"},{"location":"Library/Element/Shell/SGCMS/#syntax","title":"Syntax","text":"Text Only<pre><code>element SGCMS (1) (2...5) (6) (7)\n# (1) int, unique element tag\n# (2...5) int, node i, j, k, l\n# (6) int, material tag\n# (7) double, thickness\n</code></pre>"},{"location":"Library/Element/Shell/ShellBase/","title":"ShellBase","text":"<p>The <code>ShellBase</code> class is a base class for all shell elements. It provides basic methods to convert displacement from global to local, or convert resistance and stiffness from local to global.</p>"},{"location":"Library/Element/Special/Contact2D/","title":"Contact2D","text":"<p>2D Node(Slave)-Line(Master) Contact Element</p>"},{"location":"Library/Element/Special/Contact2D/#syntax","title":"Syntax","text":"Text Only<pre><code>element Contact2D (1) (2) (3) [4]\n# (1) int, unique element tag\n# (2) int, master group tag\n# (3) int, slave group tag\n# [4] double, penalty factor\n</code></pre>"},{"location":"Library/Element/Special/Contact2D/#remarks","title":"Remarks","text":"<ol> <li>The contact algorithm is implemented via penalty function method as an element. The parameter <code>[4]</code> controls the    magnitude of penalty.</li> <li>No matter whether the <code>nlgeom</code> switch is on or off for connected elements, the contact detection itself is always    conducted in a nonlinear manner, similar to the total Lagrangian formulation.</li> <li>The node-line contact detection is performed for all nodes defined in slave group and lines defined by nodes in    master group. There are \\(n-1\\) line segments for \\(n\\) nodes in master group.</li> <li>Master nodes can penetrate lines formed in slave group. To prevent this, define a new <code>Contact2D</code> element by swapping    the order of slave and master groups.</li> <li>Example usage can be seen in the example.</li> </ol>"},{"location":"Library/Element/Special/Contact3D/","title":"Contact3D","text":"<p>3D Node(Slave)-Triangular Facet(Master) Contact Element</p>"},{"location":"Library/Element/Special/Contact3D/#syntax","title":"Syntax","text":"Text Only<pre><code>element Contact3D (1) (2) (3) [4]\n# (1) int, unique element tag\n# (2) int, master group tag\n# (3) int, slave group tag\n# [4] double, penalty factor\n</code></pre>"},{"location":"Library/Element/Special/Contact3D/#remarks","title":"Remarks","text":"<ol> <li>The contact algorithm is implemented via penalty function method as an element. The parameter <code>[4]</code> controls the    magnitude of penalty.</li> <li>No matter whether the <code>nlgeom</code> switch is on or off for connected elements, the contact detection itself is always    conducted in a nonlinear manner, similar to the total Lagrangian formulation for the precise computation of contact.</li> <li>The node-facet contact detection is performed for all nodes defined in slave group and facets defined by nodes in    master group. There are \\(\\(n/3\\)\\) facets for \\(\\(n\\)\\) nodes in master group. So the number of nodes in master group must    be multiples of \\(\\(3\\)\\).</li> </ol>"},{"location":"Library/Element/Special/Damper01/","title":"Damper01/Damper03","text":"<p>Viscous Damper</p> <p>This damper uses displacement and velocity as inputs, not strain and strain rate, which means, element length is not used to compute strain or strain rate.</p>"},{"location":"Library/Element/Special/Damper01/#damper01","title":"Damper01","text":"<p>This <code>Damper01</code> is a simple 2D viscous damper.</p> <p>See this example.</p> <ul> <li>Number of Nodes: 2</li> <li>Number of DoFs: 2 (Translation: UX, Translation: UY)</li> </ul>"},{"location":"Library/Element/Special/Damper01/#damper03","title":"Damper03","text":"<p>This <code>Damper03</code> is a simple 3D viscous damper.</p> <ul> <li>Number of Nodes: 2</li> <li>Number of DoFs: 3 (Translation: UX, Translation: UY, Translation: UZ)</li> </ul>"},{"location":"Library/Element/Special/Damper01/#syntax","title":"Syntax","text":"Text Only<pre><code>element Damper01 (1) (2) (3) (4)\nelement Damper03 (1) (2) (3) (4)\n# (1) int, unique tag\n# (2) int, node i\n# (3) int, node j\n# (4) int, material tag of associated viscosity material\n</code></pre>"},{"location":"Library/Element/Special/Damper02/","title":"Damper02/Damper04","text":"<p>Maxwell Model</p> <p>The <code>Damper02</code> and <code>Damper04</code> are Maxwell models that use displacement and velocity as inputs, that is,  element length is not used to compute strain or strain rate.</p>"},{"location":"Library/Element/Special/Damper02/#reference","title":"Reference","text":"<p>The Maxwell model allows combinations of nonlinear springs and dampers. The algorithm implemented is documented in the following paper.</p> <ol> <li>10.1016/j.ymssp.2021.108795</li> </ol>"},{"location":"Library/Element/Special/Damper02/#damper02","title":"Damper02","text":"<p>The <code>Damper02</code> is the 2D version.</p> <ul> <li>Number of Nodes: 2</li> <li>Number of DoFs: 2 (Translation: UX, Translation: UY)</li> </ul>"},{"location":"Library/Element/Special/Damper02/#damper04","title":"Damper04","text":"<p>The <code>Damper04</code> is the 3D version.</p> <ul> <li>Number of Nodes: 2</li> <li>Number of DoFs: 3 (Translation: UX, Translation: UY, Translation: UZ)</li> </ul>"},{"location":"Library/Element/Special/Damper02/#syntax","title":"Syntax","text":"Text Only<pre><code>element Damper02 (1) (2) (3) (4) (5) [6] [7] [8]\nelement Damper04 (1) (2) (3) (4) (5) [6] [7] [8]\n# (1) int, unique tag\n# (2) int, node i\n# (3) int, node j\n# (4) int, damper tag\n# (5) int, spring tag\n# [6] bool string, if to use matrix in iteration, default: true\n# [7] int, the maximum delay number, default: 0\n# [8] double, beta, default: 0.5\n</code></pre>"},{"location":"Library/Element/Special/Damper02/#remarks","title":"Remarks","text":"<ol> <li>Parameter <code>[7]</code> indicates if to stack diverged increments into next iteration. If \\(\\(0\\)\\) is assigned, the material    returns a failure flag as long as local iteration fails to converge. If \\(\\(n&gt;0\\)\\), a maximum \\(\\(n\\)\\) increments are    allowed to be stacked before exit due to divergence.</li> <li>The <code>[8]</code> parameter controls the local time integration, \\(\\(\\beta\\in[0,1]\\)\\) shall be defined. The default value    \\(\\(0.5\\)\\) implies a constant acceleration rule for the spring component in the Maxwell model.</li> </ol>"},{"location":"Library/Element/Special/Embedded2D/","title":"Embedded2D","text":"<p>2D Embedded Element</p>"},{"location":"Library/Element/Special/Embedded2D/#syntax","title":"Syntax","text":"Text Only<pre><code>element Embedded2D (1) (2) (3) [4]\n# (1) int, unique element tag\n# (2) int, host element tag\n# (3) int, slave node tag\n# [4] double, penalty factor, default: 1E4\n</code></pre>"},{"location":"Library/Element/Special/Embedded2D/#remarks","title":"Remarks","text":"<ol> <li>Currently, the following element types are supported: <code>CP4</code>    , <code>CP5</code>, <code>CP7</code> and <code>CP8</code>.</li> </ol>"},{"location":"Library/Element/Special/Embedded3D/","title":"Embedded3D","text":"<p>3D Embedded Element</p>"},{"location":"Library/Element/Special/Embedded3D/#syntax","title":"Syntax","text":"Text Only<pre><code>element Embedded3D (1) (2) (3) [4]\n# (1) int, unique element tag\n# (2) int, host element tag\n# (3) int, slave node tag\n# [4] double, penalty factor, default: 1E4\n</code></pre>"},{"location":"Library/Element/Special/Embedded3D/#remarks","title":"Remarks","text":"<ol> <li>Currently, the following element types are supported: <code>C3D8</code> and <code>C3D20</code>.</li> </ol>"},{"location":"Library/Element/Special/Joint/","title":"Joint","text":"<p>Joint Element</p> <p>The <code>Joint</code> is a joint element that uses displacement as inputs.</p> <ul> <li>Number of Nodes: 2</li> <li>Number of DoFs: varies</li> </ul>"},{"location":"Library/Element/Special/Joint/#syntax","title":"Syntax","text":"Text Only<pre><code>element Joint (1) (2) (3) (4...)\n# (1) int, unique element tag\n# (2) int, node i\n# (3) int, node j\n# (4...) int, material tags\n</code></pre>"},{"location":"Library/Element/Special/Joint/#remarks","title":"Remarks","text":"<p>The <code>Joint</code> element defines a joint connecting two nodes that can coincide with each other regarding their coordinates. The relative displacement is used as strain input. Thus, the corresponding material model shall be defined to use displacement and force. Note in the current implementation the global horizontal and vertical displacements are passed to the material models to compute the response.</p> <p>The number of connected degrees of freedom can vary based on the number of tags of material models assigned to the element. The material models are used for each DoF sequentially according to the definition. If one wants to define a joint tagged <code>5</code> between node <code>1</code> and node <code>2</code> using material <code>3</code> for the first four DoFs, the following command can be used.</p> Text Only<pre><code>element Joint 5 1 2 3 3 3 3\n</code></pre>"},{"location":"Library/Element/Special/Mass/","title":"Mass","text":"<p>Point Mass</p> <ul> <li>Number of Nodes: 1</li> <li>Number of DoFs: varies</li> </ul>"},{"location":"Library/Element/Special/Mass/#syntax","title":"Syntax","text":"Text Only<pre><code>Mass (1) (2) (3) (4...)\nelement Mass (1) (2) (3) (4...)\n# (1) int, unique element tag\n# (2) int, node tag\n# (3) double, magnitude\n# (4...) int, dof tag\n</code></pre> <p>Point mass is implemented via element interface that connects only one node. No stiffness is defined within that element. Thus, a <code>Mass</code> object shares the same tag pool with the other elements.</p>"},{"location":"Library/Element/Special/MassPoint/","title":"MassPoint","text":"<p>The <code>MassPoint</code> element is used to represent a mass point with translational mass and optional rotational inertia.</p>"},{"location":"Library/Element/Special/MassPoint/#syntax","title":"Syntax","text":"Text Only<pre><code>element MassPoint2D (1) (2) (3) [4]\nelement MassPoint3D (1) (2) (3) [4]\n# (1) int, unique element tag\n# (2) int, node tag\n# (3) double, translational mass magnitude\n# [4] double, optional, rotational inertia magnitude\n</code></pre>"},{"location":"Library/Element/Special/MassPoint/#remarks","title":"Remarks","text":"<ol> <li>For 2D elements, <code>DOF::UX</code> and <code>DOF::UY</code> are assigned with the translational mass (equal magnitude), <code>DOF::URZ</code>     is assigned with the rotational inertia (optional).</li> <li>For 3D elements, <code>DOF::UX</code>, <code>DOF::UY</code>, and <code>DOF::UZ</code> are assigned with the translational mass (equal magnitude),     <code>DOF::URX</code>, <code>DOF::URY</code>, and <code>DOF::URZ</code> are assigned with the rotational inertia (optional).</li> <li><code>MassPoint</code> elements are an alternative to <code>Mass</code> elements, which are more abstract and allow more general     assignment of mass.</li> </ol>"},{"location":"Library/Element/Special/SingleSection/","title":"SingleSection","text":"<p>Single Section Analysis</p> <p>It is often demanded to do a section analysis to see the capacity of the target section, etc. The <code>SingleSection</code> element is exactly for this purpose.</p> <p>To use the element, a proper section shall be defined.</p>"},{"location":"Library/Element/Special/SingleSection/#syntax","title":"Syntax","text":"Text Only<pre><code>element SingleSection2D (1) (2) (3)\nelement SingleSection3D (1) (2) (3)\n# (1) int, unique tag\n# (2) int, node tag\n# (3) int, section tag\n</code></pre>"},{"location":"Library/Element/Special/Spring01/","title":"Spring01","text":"<p>The <code>Spring01</code> and <code>Spring02</code> are two spring like elements. Note only infinitesimal strain/deformation formulation is supported. If finite deformation, such a rigid body dynamics, is involved, analysts shall use <code>T2D2</code> and <code>T2D2S</code> elements.</p>"},{"location":"Library/Element/Special/Spring01/#syntax","title":"Syntax","text":"Text Only<pre><code>element Spring01 (1) (2) (3) (4)\n# (1) int, unique tag\n# (2) int, node i\n# (3) int, node j\n# (4) int, material tag\n</code></pre>"},{"location":"Library/Element/Special/Spring02/","title":"Spring02","text":"<p>The <code>Spring01</code> and <code>Spring02</code> are two spring like elements. Note only infinitesimal strain/deformation formulation is supported. If finite deformation, such a rigid body dynamics, is involved, analysts shall use <code>T2D2</code> and <code>T2D2S</code> elements.</p>"},{"location":"Library/Element/Special/Spring02/#syntax","title":"Syntax","text":"Text Only<pre><code>element Spring02 (1) (2) (3) (4)\n# (1) int, unique tag\n# (2) int, node i\n# (3) int, node j\n# (4) int, material tag\n</code></pre>"},{"location":"Library/Element/Special/Tie/","title":"Tie","text":"<p>Multipoint Constraint Implemented As Element</p> <ul> <li>Number of Nodes: varies</li> <li>Number of DoFs: varies</li> </ul>"},{"location":"Library/Element/Special/Tie/#syntax","title":"Syntax","text":"Text Only<pre><code>element Tie (1) (2) (3) [(4) (5) (6)...]\n# (1) int, unique element tag\n# (2) double, right hand side of the constraint equation, the constraint is homogeneous if this parameter is zero\n# (3) double, penalty number, a relatively large number\n# (4) int, node tag\n# (5) int, dof tag\n# (6) double, weight\n</code></pre>"},{"location":"Library/Element/Special/Tie/#example","title":"Example","text":"<p>Each <code>Tie</code> element can have multiple DoFs included. For example, to define the following constraint,</p> \\[ 5u_2+6v_4=9, \\] <p>where \\(\\(u_2\\)\\) and \\(\\(v_4\\)\\) are horizontal displacement of node <code>2</code> and vertical displacement of node <code>4</code> in a 2D model, then</p> Text Only<pre><code>element Tie 1 9. 1E8 2 1 5. 4 2 6.\n</code></pre> <p>In the above command, a large number <code>1E8</code> is used as penalty.</p>"},{"location":"Library/Element/Truss/T2D2/","title":"T2D2","text":"<p>2D Linear Truss</p> <ul> <li>Number of Nodes: 2</li> <li>Number of DoFs: 2 (Translation, Translation)</li> </ul>"},{"location":"Library/Element/Truss/T2D2/#syntax","title":"Syntax","text":"Text Only<pre><code>element T2D2 (1) (2) (3) (4) (5) [6] [7] [8] [9]\n# (1) int, unique element tag\n# (2) int, node i\n# (3) int, node j\n# (4) int, material tag\n# (5) double, cross sectional area\n# [6] bool string, nonlinear geometry switch, default: false\n# [7] bool string, if to update sectional area, default: false\n# [8] bool string, if to use log strain, default: false\n# [9] double, flexural rigidity, positive to activate Euler buckling limit, default: -1.0\n</code></pre>"},{"location":"Library/Element/Truss/T2D2/#remarks","title":"Remarks","text":"<ol> <li>The corotational formulation is implemented, turn on the nonlinear geometry switch to use it.</li> <li>According to different implementations of details, either a constant area or a constant volume assumption is adopted.    If the volume is constant, the cross-sectional area would be updated based on \\(\\(A=\\dfrac{A_0L_0}{L}\\)\\).</li> <li>The computation of strain can be altered from engineering strain (by default) to log strain.</li> <li>By turning on all three switches, full nonlinearity can be achieved.</li> </ol>"},{"location":"Library/Element/Truss/T2D2/#euler-buckling-limit","title":"Euler Buckling Limit","text":"<p>[added in version 2.8]</p> <p>The parameter <code>[9]</code> allows one to define a positive flexural rigidity \\(\\(EI\\)\\) that will be used to compute the Euler buckling load. When <code>[9]</code> is negative, the check is disabled.</p> <p>The truss element matches a pinned-pinned condition, for which the Euler buckling load is given by</p> \\[ P_{cr}=\\dfrac{\\pi^2EI}{L^2} \\] <p>where \\(\\(L\\)\\) is the length of the truss element.</p> <p>For a given positive \\(\\(EI\\)\\), \\(\\(P_{cr}\\)\\) can be computed using only the \\(\\(L\\)\\), regardless of the used material model. The computed axial resistance will be compared to \\(\\(P_{cr}\\)\\) and an error will be issued if the axial resistance (in compression) exceeds \\(\\(P_{cr}\\)\\).</p> <p>This is a theoretical upper bound, the design value requires an additional reduction.</p>"},{"location":"Library/Element/Truss/T2D2S/","title":"T2D2S","text":"<p>2D Linear Truss Using Section</p> <ul> <li>Number of Nodes: 2</li> <li>Number of DoFs: 2 (Translation, Translation)</li> </ul>"},{"location":"Library/Element/Truss/T2D2S/#syntax","title":"Syntax","text":"Text Only<pre><code>element T2D2S (1) (2) (3) (4) [6] [7] [8]\n# (1) int, unique element tag\n# (2) int, node i\n# (3) int, node j\n# (4) int, section tag\n# [5] bool string, nonlinear geometry switch, default: false\n# [6] bool string, if to use log strain, default: false\n</code></pre>"},{"location":"Library/Element/Truss/T2D2S/#remarks","title":"Remarks","text":"<ol> <li>Compared to <code>T2D2</code> , <code>T2D2S</code> use section instead of material. Hence, sectional area is handled by the corresponding    section model.</li> <li>The nonlinearity cannot propagate into the section level. So it is not possible to update area in <code>T2D2S</code>.</li> </ol>"},{"location":"Library/Element/Truss/T3D2/","title":"T3D2","text":"<p>3D Linear Truss</p> <ul> <li>Number of Nodes: 2</li> <li>Number of DoFs: 3 (Translation, Translation, Translation)</li> </ul>"},{"location":"Library/Element/Truss/T3D2/#syntax","title":"Syntax","text":"Text Only<pre><code>element T3D2 (1) (2) (3) (4) (5) [6] [7] [8]\n# (1) int, unique element tag\n# (2) int, node i\n# (3) int, node j\n# (4) int, material tag\n# (5) double, cross sectional area\n# [6] bool string, nonlinear geometry switch, default: false\n# [7] bool string, if to update sectional area, default: false\n# [8] bool string, if to use log strain, default: false\n</code></pre>"},{"location":"Library/Element/Truss/T3D2/#remarks","title":"Remarks","text":"<ol> <li>The corotational formulation is implemented, turn on the nonlinear geometry switch to use it.</li> <li>According to different implementations of details, either a constant area or a constant volume assumption is adopted.    If the volume is constant, the cross-sectional area would be updated based on \\(\\(A=\\dfrac{A_0L_0}{L}\\)\\).</li> <li>The computation of strain can be altered from engineering strain (by default) to log strain.</li> <li>By turning on all three switches, full nonlinearity can be achieved.</li> </ol>"},{"location":"Library/Element/Truss/T3D2S/","title":"T3D2S","text":"<p>3D Linear Truss Using Section</p> <ul> <li>Number of Nodes: 2</li> <li>Number of DoFs: 3 (Translation, Translation, Translation)</li> </ul>"},{"location":"Library/Element/Truss/T3D2S/#syntax","title":"Syntax","text":"Text Only<pre><code>element T3D2S (1) (2) (3) (4) [6] [7] [8]\n# (1) int, unique element tag\n# (2) int, node i\n# (3) int, node j\n# (4) int, section tag\n# [5] bool string, nonlinear geometry switch, default: false\n# [6] bool string, if to use log strain, default: false\n</code></pre>"},{"location":"Library/Element/Truss/T3D2S/#remarks","title":"Remarks","text":"<ol> <li>Compared to <code>T3D2</code> , <code>T3D2S</code> use section instead of material. Hence, sectional area is handled by the corresponding    section model.</li> <li>The nonlinearity cannot propagate into the section level. So it is not possible to update area in <code>T3D2S</code>.</li> </ol>"},{"location":"Library/Integrator/BatheExplicit/","title":"BatheExplicit","text":"<p>Second order explicit time integration method using Noh-Bathe two-step scheme.</p> <p>The Noh-Bathe scheme has a better energy dispersion behaviour.</p> <p>References:</p> <ol> <li>10.1016/j.compstruc.2013.06.007</li> </ol>"},{"location":"Library/Integrator/BatheExplicit/#syntax","title":"Syntax","text":"Text Only<pre><code>integrator BatheExplicit (1) [2]\n# (1) int, unique integrator tag\n# [2] double, spectral radius, \\rho_\\infty, default: 0.5\n</code></pre>"},{"location":"Library/Integrator/BatheExplicit/#remarks","title":"Remarks","text":"<p>If the model is linear elastic, it is possible to indicate using</p> Text Only<pre><code>set linear_system true\n</code></pre> <p>to speed up the computation.</p>"},{"location":"Library/Integrator/BatheTwoStep/","title":"BatheTwoStep","text":"<p>Starting from version 2.7, customisation of spectral radius (\\(\\(\\rho_\\infty\\)\\)) and sub-step size (\\(\\(\\gamma\\)\\)) is supported.</p> <p>The algorithm is known to be able to conserve energy and momentum.</p> <p>References:</p> <ol> <li>10.1016/j.compstruc.2006.09.004</li> <li>10.1016/j.compstruc.2018.11.001</li> </ol> <p>The implementation follows the original algorithm. The only difference is the step size defined in <code>suanPan</code> is the mean step size of two sub-step sizes, that is \\(\\(\\Delta{}t/2\\)\\) in the references.</p>"},{"location":"Library/Integrator/BatheTwoStep/#syntax","title":"Syntax","text":"Text Only<pre><code>integrator BatheTwoStep (1) [2] [3]\n# (1) int, unique integrator tag\n# [2] double, spectral radius, \\rho_\\infty, default: 0\n# [2] double, sub-step size, gamma, default: 0.5\n</code></pre> <p>Using <code>integrator BatheTwoStep (1)</code> with two optional parameters omitted gives the same results as in versions prior  to version 2.7.</p> <p>The spectral radius \\(\\(\\rho_\\infty\\)\\) ranges from 0 to 1, both ends inclusive.</p> <p>The sub-step size \\(\\(\\gamma\\)\\) ranges from 0 to 1, both ends exclusive.</p>"},{"location":"Library/Integrator/BatheTwoStep/#theory","title":"Theory","text":""},{"location":"Library/Integrator/BatheTwoStep/#the-first-sub-step","title":"The First Sub-step","text":"<p>For trapezoidal rule,</p> \\[ v_{n+1}=v_n+\\dfrac{\\gamma\\Delta{}t}{2}\\left(a_n+a_{n+1}\\right), \\] \\[ u_{n+1}=u_n+\\dfrac{\\gamma\\Delta{}t}{2}\\left(v_n+v_{n+1}\\right). \\] <p>Then,</p> \\[ u_{n+1}=u_n+\\dfrac{\\gamma\\Delta{}t}{2}\\left(v_n+v_n+\\dfrac{\\gamma\\Delta{}t}{2}\\left(a_n+a_{n+1}\\right)\\right), \\] \\[ \\Delta{}u=\\gamma\\Delta{}tv_n+\\dfrac{\\gamma^2\\Delta{}t^2}{4}a_n+\\dfrac{\\gamma^2\\Delta{}t^2}{4}a_{n+1}. \\] <p>One could obtain</p> \\[ a_{n+1}=\\dfrac{4}{\\gamma^2\\Delta{}t^2}\\Delta{}u-\\dfrac{4}{\\gamma\\Delta{}t}v_n-a_n,\\qquad \\Delta{}a=\\dfrac{4}{\\gamma^2\\Delta{}t^2}\\Delta{}u-\\dfrac{4}{\\gamma\\Delta{}t}v_n-2a_n, \\] \\[ v_{n+1}=\\dfrac{2}{\\gamma\\Delta{}t}\\Delta{}u-v_n,\\qquad \\Delta{}v=\\dfrac{2}{\\gamma\\Delta{}t}\\Delta{}u-2v_n. \\] <p>The effective stiffness is then</p> \\[ \\bar{K}=K+\\dfrac{2}{\\gamma\\Delta{}t}C+\\dfrac{4}{\\gamma^2\\Delta{}t^2}M. \\]"},{"location":"Library/Integrator/BatheTwoStep/#the-second-sub-step","title":"The Second Sub-step","text":"<p>The second step is computed by</p> \\[ v_{n+2}=v_n+\\Delta{}t\\left(q_0a_n+q_1a_{n+1}+q_2a_{n+2}\\right), \\] \\[ u_{n+2}=u_n+\\Delta{}t\\left(q_0v_n+q_1v_{n+1}+q_2v_{n+2}\\right). \\] <p>The parameters satisfy \\(\\(q_0+q_1+q_2=1\\)\\), and</p> \\[ q_1=\\dfrac{\\rho_\\infty+1}{2\\gamma\\left(\\rho_\\infty-1\\right)+4},\\qquad q_2=0.5-\\gamma{}q_1. \\] <p>Hence,</p> \\[ a_{n+2}=\\dfrac{v_{n+2}-v_n}{q_2\\Delta{}t}-\\dfrac{q_0}{q_2}a_n-\\dfrac{q_1}{q_2}a_{n+1}, \\] \\[ v_{n+2}=\\dfrac{u_{n+2}-u_n}{q_2\\Delta{}t}-\\dfrac{q_0}{q_2}v_n-\\dfrac{q_1}{q_2}v_{n+1}. \\] <p>The effective stiffness is then</p> \\[ \\bar{K}=K+\\dfrac{1}{q_2\\Delta{}t}C+\\dfrac{1}{q_2^2\\Delta{}t^2}M. \\]"},{"location":"Library/Integrator/GSSSS/","title":"GSSSS","text":"<p>The Generalized Single Step Single Solve Unified Framework</p> <p>The GSSSS approach unifies various time integration methods in a single framework.</p>"},{"location":"Library/Integrator/GSSSS/#references","title":"References","text":"<ol> <li>Advances in Computational Dynamics of Particles, Materials and Structures</li> <li>10.1002/nme.89</li> <li>10.1002/nme.873</li> </ol> <p>There are quite a few papers on this topic by the same group of authors. Similar contents can be found in a number of papers. The implementation is based on a unified predictor multi-corrector representation. It is sufficiently general so that both elastic and elastoplastic systems can be analyzed. The implementation is documented in details in Section 14.3.4 (Eqs. 14.280 --- 14.296) of the first reference.</p> <p>It is strongly recommended to give the references a careful read as GSSSS is very elegant if you wish to learn more about the advances in computational dynamics.</p>"},{"location":"Library/Integrator/GSSSS/#syntax","title":"Syntax","text":"<p>Both U0 and V0 families are available.</p> Text Only<pre><code>integrator GSSSSU0 (1) (2) (3) (4)\nintegrator GSSSSV0 (1) (2) (3) (4)\n# (1) int, unique integrator tag\n# (2) double, spectral radius (order does not matter)\n# (3) double, spectral radius (order does not matter)\n# (4) double, spectral radius (order does not matter)\n</code></pre> <p>The optimal scheme (see table below) only requires one spectral radius, one can use the following command to use the  optimal scheme.</p> Text Only<pre><code>integrator GSSSSOptimal (1) [2]\n# (1) int, unique integrator tag\n# [2] double, spectral radius, default: 0.5\n</code></pre>"},{"location":"Library/Integrator/GSSSS/#remarks","title":"Remarks","text":"<p>The framework has three parameters to be defined, namely \\(\\(\\rho_{1,\\infty}\\)\\), \\(\\(\\rho_{2,\\infty}\\)\\) and \\(\\(\\rho_ {3,\\infty}\\)\\). They satisfy the following condition,</p> \\[ 0\\leqslant\\rho_{3,\\infty}\\leqslant\\rho_{1,\\infty}\\leqslant\\rho_{2,\\infty}\\leqslant1. \\] <p>The syntax takes three spectral radii in arbitrary order, they are clamped between zero and unity, sorted and assigned to \\(\\(\\rho_{3,\\infty}\\)\\), \\(\\(\\rho_{1,\\infty}\\)\\) and \\(\\(\\rho_{2,\\infty}\\)\\) to compute internal parameters. Users can thus assign three valid radii without worrying about the order.</p> <p>A number of commonly known methods can be accommodated in the framework. For example:</p> Method Family Value \\(\\(\\rho_{1,\\infty}\\)\\) Value \\(\\(\\rho_{2,\\infty}\\)\\) Value \\(\\(\\rho_{3,\\infty}\\)\\) Newmark U0 \\(\\(1\\)\\) \\(\\(1\\)\\) \\(\\(0\\)\\) Classic Midpoint U0/V0 \\(\\(1\\)\\) \\(\\(1\\)\\) \\(\\(1\\)\\) Generalised Alpha U0 \\(\\(\\rho\\)\\) \\(\\(\\rho\\)\\) \\(\\(\\rho\\)\\) WBZ U0 \\(\\(\\rho\\)\\) \\(\\(\\rho\\)\\) \\(\\(0\\)\\) HHT U0 \\(\\(\\rho\\)\\) \\(\\(\\rho\\)\\) \\(\\(\\dfrac{1-\\rho}{2\\rho}\\)\\) U0-V0 Optimal U0/V0 \\(\\(\\rho\\)\\) \\(\\(1\\)\\) \\(\\(\\rho\\)\\) New Midpoint V0 \\(\\(1\\)\\) \\(\\(1\\)\\) \\(\\(0\\)\\)"},{"location":"Library/Integrator/GeneralizedAlpha/","title":"GeneralizedAlpha","text":"<p>The generalized-\\(\\(\\alpha\\)\\) method provides second order accuracy with controllable algorithmic damping on high frequency response.</p>"},{"location":"Library/Integrator/GeneralizedAlpha/#syntax","title":"Syntax","text":"<p>Two forms are available.</p> Text Only<pre><code>integrator GeneralisedAlpha (1) [2]\nintegrator GeneralizedAlpha (1) [2]\n# (1) int, unique tag\n# [2] double, spectral radius at infinite frequency, default: 0.5\n\nintegrator GeneralisedAlpha (1) (2) (3)\nintegrator GeneralizedAlpha (1) (2) (3)\n# (1) int, unique tag\n# (2) double, \\alpha_f\n# (3) double, \\alpha_m\n</code></pre>"},{"location":"Library/Integrator/GeneralizedAlpha/#governing-equation","title":"Governing Equation","text":"<p>The generalized alpha method assumes that the displacement \\(\\(d\\)\\) and the velocity \\(\\(v\\)\\) are integrated as such,</p> \\[ d_{n+1}=d_n+\\Delta{}tv_n+\\Delta{}t^2\\left(\\left(\\dfrac{1}{2}-\\beta\\right)a_n+\\beta{}a_{n+1}\\right) , \\] \\[ v_{n+1}=v_n+\\Delta{}t\\left(1-\\gamma\\right)a_n+\\Delta{}t\\gamma{}a_{n+1}. \\] <p>The equation of motion is expressed at somewhere between \\(\\(t_n\\)\\) and \\(\\(t_{n+1}\\)\\).</p> \\[ Ma_{n+1-\\alpha_m}+Cv_{n+1-\\alpha_f}+Kd_{n+1-\\alpha_f}=F_{n+1-\\alpha_f}, \\] <p>which can also be explicitly shown as</p> \\[ M\\left(\\left(1-\\alpha_m\\right)a_{n+1}+\\alpha_ma_n\\right)+C\\left(\\left(1-\\alpha_f\\right)v_{n+1}+\\alpha_fv_n\\right) +K\\left(\\left(1-\\alpha_f\\right)d_{n+1}+\\alpha_fd_n\\right)=\\left(1-\\alpha_f\\right)F_{n+1}+\\alpha_fF_n, \\] <p>where \\(\\(\\alpha_m\\)\\) and \\(\\(\\alpha_f\\)\\) are two additional parameters.</p>"},{"location":"Library/Integrator/GeneralizedAlpha/#default-parameters","title":"Default Parameters","text":"<p>To obtain an unconditionally stable algorithm, the following conditions shall be satisfied.</p> \\[ \\alpha_m\\le\\alpha_f\\le\\dfrac{1}{2},\\quad\\beta\\ge\\dfrac{1}{4}+\\dfrac{1}{2}\\left(\\alpha_f-\\alpha_m\\right). \\] <p>Only one parameter is required, the spectral radius \\(\\(\\rho_\\infty\\)\\) that ranges from zero to one.</p> <p>The following expressions are used to determine the values of all constants used.</p> \\[ \\alpha_f=\\dfrac{\\rho_\\infty}{\\rho_\\infty+1},\\quad \\alpha_m=\\dfrac{2\\rho_\\infty-1}{\\rho_\\infty+1},\\quad \\gamma=\\dfrac{1}{2}-\\dfrac{\\rho_\\infty-1}{\\rho_\\infty+1},\\quad \\beta=\\dfrac{1}{\\left(\\rho_\\infty+1\\right)^2}. \\] <p>So that the resulting algorithm is unconditionally stable and has a second order accuracy. The target numerical damping for high frequencies is achieved while that of low frequencies is minimized.</p> <p>The recommended values of the spectral radius \\(\\(\\rho_\\infty\\)\\) range from \\(\\(0.5\\)\\) to \\(\\(0.8\\)\\).</p> <p>Some special parameters can be chosen.</p> \\(\\(\\alpha_f\\)\\) \\(\\(\\alpha_M\\)\\) method \\(\\(0.0\\)\\) \\(\\(0.0\\)\\) Newmark - \\(\\(0.0\\)\\) HHT-\\(\\(\\alpha\\)\\) \\(\\(0.0\\)\\) - WBZ-\\(\\(\\alpha\\)\\)"},{"location":"Library/Integrator/GeneralizedAlphaExplicit/","title":"GeneralizedAlphaExplicit","text":"<p>Explicit version of the GeneralizedAlpha integrator.</p> <p>References:</p> <ol> <li>10.1002/nme.6574</li> </ol>"},{"location":"Library/Integrator/GeneralizedAlphaExplicit/#syntax","title":"Syntax","text":"Text Only<pre><code>integrator GeneralizedAlpha (1) [2]\nintegrator GeneralisedAlpha (1) [2]\n# (1) int, unique integrator tag\n# [2] double, spectral radius, \\rho_\\infty, default: 0.5\n</code></pre>"},{"location":"Library/Integrator/GeneralizedAlphaExplicit/#remarks","title":"Remarks","text":"<p>If the model is linear elastic, it is possible to indicate using</p> Text Only<pre><code>set linear_system true\n</code></pre> <p>to speed up the computation.</p>"},{"location":"Library/Integrator/Linear/","title":"Linear","text":"<p>A <code>Linear</code> integrator basically does nothing and is used as the default integrator in static analysis.</p> <p>If no integrator is defined in a step, a linear one will automatically be created and used.</p>"},{"location":"Library/Integrator/OALTS/","title":"OALTS","text":"<p>Optimal A-stable Linear Two-Step Method</p> <p>References:</p> <ol> <li>10.1002/nme.6188</li> <li>10.1002/nme.6623</li> </ol>"},{"location":"Library/Integrator/OALTS/#syntax","title":"Syntax","text":"Text Only<pre><code>integrator OALTS (1) [2]\n# (1) int, unique integrator tag\n# [2] double, spectral radius, default: 0.5\n</code></pre>"},{"location":"Library/Integrator/OALTS/#remarks","title":"Remarks","text":"<p>This method is closely related to the Generalised-Alpha method (on first order ODEs). See the second reference for more details, also see 10.1016/j.compstruc.2017.08.013.</p> <p>This method requires a fixed time step. The initial time step is used for time marching. For example,</p> Text Only<pre><code>set ini_step_size 1E-2\n</code></pre> <p>The <code>fixed_step_size</code> command such as</p> Text Only<pre><code>set fixed_step_size true\n</code></pre> <p>is not required and this flag is always <code>true</code>.</p>"},{"location":"Library/Integrator/Overview/","title":"Integrator Overview","text":"<p>The <code>Integrator</code> is some middleware between <code>Solver</code> (in charge of solving the system) and <code>Domain</code> (in charge of managing the state of the system). It is mainly responsible for time integration in which the proper equation of motion can be formulated. To fulfill this task, the <code>Integrator</code> provides an additional layer and handles the communication between the <code>Solver</code> and the <code>Domain</code>, thus, it can also be deemed as a broker between the two. Due to this fact, a number of different (special) operations, for example, formulating the global damping model, can also be implemented via an <code>Integrator</code>. A number of integrators are implemented.</p>"},{"location":"Library/Integrator/Overview/#newmark","title":"Newmark","text":"<p>But how can one determine which <code>Integrator</code> to use? The most widely used integrator is (probably) the <code>Newmark</code> integrator. Indeed, it is almost the standard practice to use it in earthquake engineering, and there is no need to justify the choice. But the <code>Newmark</code> method is not always the best choice.</p>"},{"location":"Library/Integrator/Overview/#bathe-two-step","title":"Bathe Two--Step","text":"<p>If energy and momentum conservations matter, the <code>BatheTwoStep</code> integrator provides a very cost-efficient solution. The performance should be comparable to the <code>Newmark</code> integrator.</p>"},{"location":"Library/Integrator/Overview/#generalized-alpha","title":"Generalized-\\(\\(\\alpha\\)\\)","text":"<p>If one wants to customise algorithmic damping, the <code>GeneralizedAlpha</code> integrator can be used. By adjusting two parameters, several other methods can be recovered. Since the equation of motion is satisfied somewhere within the time step (rather than the beginning/ending), it requires roughly a factor of two more vector operations than the <code>Newmark</code> integrator. However, vector operations are not costly and are mostly implemented in a parallel fashion, it is not considered a severe performance issue.</p>"},{"location":"Library/Integrator/Overview/#gssss","title":"GSSSS","text":"<p>The most general integrator is the <code>GSSSS</code> integrator. The optimal performance (in terms of overshoot, energy dissipation/dispersion) can be achieved by using the U0-V0 Optimal scheme.</p> <p>The <code>GSSSS</code> integrator requires an additional iteration to synchronise the state of the system. Thus, the performance is sightly higher than that of the <code>GeneralizedAlpha</code> integrator.</p>"},{"location":"Library/Integrator/Overview/#central-difference-not-available","title":"Central Difference (Not Available)","text":"<p>The explicit central difference method is frequently introduced in textbooks on dynamics due to its simplicity. The major benefit(s) is that the stiffness matrix does not enter the left-hand side of the equation of motion, which means, under certain conditions, factorisation of global effective matrix would only be done once. This leads to \"very efficient\" solutions.</p> <p>However, it is in general difficult to meet those conditions. It is not implemented, and users are discouraged from using central difference in seismic engineering.</p>"},{"location":"Library/Integrator/Overview/#constant-mass-and-damping-matrices","title":"Constant Mass and Damping Matrices","text":"<p>The mass matrix may be constant, but there is no guarantee that the damping matrix is constant. Thus, in the nonlinear context, it can only be assumed that the left-hand side of the equation of motion would change in each sub-step.</p>"},{"location":"Library/Integrator/Overview/#convergence","title":"Convergence","text":"<p>To ensure convergence, the time step should be very small, and should reduce further if the mesh is refined. The maximum allowable time step is associated with the minimum period of all elements. If the mass matrix is not fully integrated ( semi-positive definite), the time step would be unnecessarily small.</p>"},{"location":"Library/Integrator/Tchamwa/","title":"Tchamwa","text":"<p>First order explicit time integration method using the Tchamwa scheme.</p> <p>References:</p> <ol> <li>10.1002/nme.6574</li> </ol>"},{"location":"Library/Integrator/Tchamwa/#syntax","title":"Syntax","text":"Text Only<pre><code>integrator Tchamwa (1) [2]\n# (1) int, unique integrator tag\n# [2] double, spectral radius, \\rho_\\infty, default: 0.5\n</code></pre>"},{"location":"Library/Integrator/Tchamwa/#theory","title":"Theory","text":"<p>The integration relationship is given by the following.</p> \\[ u_{n+1}=u_n+\\Delta{}tv_n+\\phi\\Delta{}t^2a_n, \\] \\[ v_{n+1}=v_n+\\Delta{}ta_n, \\] <p>where</p> \\[ \\phi=\\dfrac{2}{1+\\rho_\\infty}. \\] <p>The Tchamwa scheme has a first order accuracy and controllable numerical dissipation.</p>"},{"location":"Library/Integrator/Tchamwa/#remarks","title":"Remarks","text":"<p>If the model is linear elastic, it is possible to indicate using</p> Text Only<pre><code>set linear_system true\n</code></pre> <p>to speed up the computation.</p>"},{"location":"Library/Integrator/Newmark/LeeNewmark/","title":"LeeNewmark","text":"<p>Newmark Algorithm With Lee Damping Model (Type 0 Only)</p> <p>See this example.</p> <p>Please check the references for theory.</p> <ol> <li>10.1016/j.jsv.2020.115312</li> <li>10.1016/j.engstruct.2020.110178</li> </ol> <p>For the moment, MPC cannot be considered in all global damping models.</p>"},{"location":"Library/Integrator/Newmark/LeeNewmark/#syntax","title":"Syntax","text":"Text Only<pre><code>integrator LeeNewmark (1) (2) (3) ((4) (5)...)\n# (1) int, unique integrator tag\n# (2) double, alpha\n# (3) double, beta\n# (4) double, damping ratio \\zeta_p at the peak of each mode\n# (5) double, circular frequency \\omega_p at the peak of each mode\n</code></pre> <p>The converged stiffness from the last substep is used for assembling. If other stiffness matrices are preferred, please use <code>LeeNewmarkFull</code>.</p>"},{"location":"Library/Integrator/Newmark/LeeNewmark/#remarks","title":"Remarks","text":"<ol> <li> <p>User shall make sure all active DoFs in the system are displacement DoFs.</p> </li> <li> <p>The <code>LeeNewmark</code> integrator uses a standard Newmark algorithm and the damping model proposed by Lee (2020).</p> </li> <li> <p>The static condensation procedure is reversed so that the damping matrix \\(\\(\\mathbf{C}\\)\\) is a sparse matrix of a    different size.</p> </li> <li> <p>Currently, the modified equation of motion (of larger size) is stored as a sparse matrix and the <code>SuperLU</code> solver is    used to solve sparse systems by default. To switch to other solver, one can use the following command.</p> Text Only<pre><code>set system_solver MUMPS\n</code></pre> </li> </ol> <p>If <code>MKL</code> is enabled, it is possible to use <code>PARDISO</code> solver by setting the following command.</p> Text Only<pre><code>```\nset system_solver PARDISO\n```\n</code></pre> <p>If <code>CUDA</code> is enabled, it is possible to use <code>CUDA</code> solver by setting the following command.</p> Text Only<pre><code>```\nset system_solver CUDA\n```\n</code></pre> <p>The matrix storage flags (<code>sparse_mat</code>, <code>band_mat</code>, <code>symm_mat</code>) still have effect on how original matrices are stored    but do not affect solving stage. Depending on different storage schemes (dense/sparse), the assembly of final    effective stiffness may have different efficiency. For large systems, it may potentially be faster if original    matrices adopt sparse scheme as well. To do so, one can use the following command.</p> Text Only<pre><code>```\nset sparse_mat true\n```\n</code></pre> <ol> <li>Experience indicates that different sparse solvers may exhibit different performance. You are suggested to test    different solvers on your platform.</li> </ol>"},{"location":"Library/Integrator/Newmark/LeeNewmark/#example","title":"Example","text":"<p>The following command adopts three basic functions with peaks located at \\(\\(\\omega_1=1\\)\\), \\(\\(\\omega_2=10\\)\\) and \\(\\(\\omega_3=100\\)\\). Each basic function has a peak of \\(\\(3\\%\\)\\) damping.</p> Text Only<pre><code>integrator LeeNewmark 1 .25 .5 .03 1 .03 10 .03 100\n</code></pre> <p>With the above command, we use \\(\\(\\alpha=0.25\\)\\) and \\(\\(\\beta=0.5\\)\\) in Newmark method. Note the final overall response will be something greater than \\(\\(3\\%\\)\\) at those three frequencies since the contributions of three functions will be summed. Users need to manually compute \\(\\(\\zeta_p\\)\\) and \\(\\(\\omega_p\\)\\) to obtain desired curve.</p> <p>One can also use Damping Dolphin to generate parameter sets.</p>"},{"location":"Library/Integrator/Newmark/LeeNewmarkFull/","title":"LeeNewmarkFull","text":"<p>Newmark Algorithm With Lee Damping Model (Full Modes)</p> <p>Please check the references for theory.</p> <ol> <li>10.1016/j.jsv.2020.115312</li> <li>10.1016/j.engstruct.2020.110178</li> <li>10.1016/j.compstruc.2020.106423</li> <li>10.1016/j.compstruc.2021.106663</li> </ol> <p>For the moment, MPC cannot be considered in all global damping models.</p>"},{"location":"Library/Integrator/Newmark/LeeNewmarkFull/#syntax","title":"Syntax","text":"Text Only<pre><code>integrator LeeNewmarkFull (1) (2) (3) ((4) (5) (6) [7...]...)\n# (1) int, unique integrator tag\n# (2) double, alpha in Newmark method\n# (3) double, beta in Newmark method\n# (4) string, type identifier\n# (5) double, \\zeta_p\n# (6) double, \\omega_p\n# (7...) double/int, parameters associated with the mode\n</code></pre> <p>By default, the converged stiffness from the last substep is used in assembling damping matrix, this leads to quadratic convergence rate. For special purposes, one can also use the following commands to explicitly use the certain stiffness matrix.</p> Text Only<pre><code>integrator LeeNewmarkFullInitial (1) (2) (3) ((4) (5) (6) [7...]...)\nintegrator LeeNewmarkFullCurrent (1) (2) (3) ((4) (5) (6) [7...]...)\nintegrator LeeNewmarkFullTrial (1) (2) (3) ((4) (5) (6) [7...]...)\n</code></pre>"},{"location":"Library/Integrator/Newmark/LeeNewmarkFull/#remarks","title":"Remarks","text":"<ol> <li> <p>User shall ensure all active DoFs in the system are displacement DoFs.</p> </li> <li> <p>The <code>LeeNewmarkFull</code> integrator uses a standard Newmark algorithm and the damping model proposed by Lee (2020).    Several types of basic functions are defined to control the bandwidth.</p> </li> <li> <p>The static condensation procedure is reversed so that the damping matrix \\(\\(\\mathbf{C}\\)\\) is a sparse matrix of a    different size.</p> </li> <li> <p>Currently, the modified equation of motion (of larger size) is stored as a sparse matrix and the <code>SuperLU</code> solver is    used to solve sparse systems. To switch to other solver, one can use the following command.</p> Text Only<pre><code>set system_solver MUMPS\n</code></pre> </li> </ol> <p>If <code>MKL</code> is enabled, it is possible to use <code>PARDISO</code> solver by setting the following command.</p> Text Only<pre><code>```\nset system_solver PARDISO\n```\n</code></pre> <p>If <code>CUDA</code> is enabled, it is possible to use <code>CUDA</code> solver by setting the following command.</p> Text Only<pre><code>```\nset system_solver CUDA\n```\n</code></pre> <ol> <li>The final global matrix is expected to be considerable huge compared to the original matrix. Thus, the sparse storage    scheme is also used for assembling original stiffness and mass matrices by default. Please always add the    following command in the corresponding step.</li> </ol> Text Only<pre><code>set sparse_mat true\n</code></pre> <ol> <li> <p>The following type identifiers are available:</p> </li> <li> <p><code>-type0</code> --- zeroth order model, need no additional parameter, viz., <code>[7]</code> can be empty</p> </li> <li><code>-type1</code> --- type 1 model, need one integer parameter, viz., <code>[7]</code> (\\(\\(n_p\\)\\)) is a non-negative integer</li> <li><code>-type2</code> --- type 2 model, need two integer parameters, viz., <code>[7]</code> (\\(\\(n_{pr}\\)\\)) and <code>[8]</code> (\\(\\(n_{pl}\\)\\)) are       non-negative integers (zero allowed)</li> <li><code>-type3</code> --- type 3 model, need a double parameter, viz., <code>[7]</code> (\\(\\(\\gamma\\)\\)) is a double number that is greater        than \\(\\(\\gamma&gt;-1\\)\\)</li> <li> <p><code>-type4</code> --- type 4 model, need five parameters, <code>[7...10]</code> are four non-negative integers (\\(\\(n_{pr}\\)\\),       \\(\\(n_{pl}\\)\\), \\(\\(n_{pk}\\)\\), \\(\\(n_{pm}\\)\\)), <code>[11]</code> is a double parameter greater than \\(\\(\\gamma&gt;-1\\)\\)</p> </li> <li> <p>Multiple types can be mixed in any preferred orders. See examples below.</p> </li> </ol>"},{"location":"Library/Integrator/Newmark/LeeNewmarkFull/#examples","title":"Examples","text":"<p>Each of the following commands defines \\(\\(5\\%\\)\\) peak damping on \\(\\(\\omega=1\\)\\) via different types with different parameters.</p> Text Only<pre><code>integrator LeeNewmarkFull 1 .25 .5 -type0 .05 1\nintegrator LeeNewmarkFull 1 .25 .5 -type1 .05 1 2\nintegrator LeeNewmarkFull 1 .25 .5 -type2 .05 1 2 1\nintegrator LeeNewmarkFull 1 .25 .5 -type2 .05 1 3 1\nintegrator LeeNewmarkFull 1 .25 .5 -type2 .05 1 2 3\nintegrator LeeNewmarkFull 1 .25 .5 -type3 .05 1 -.25\nintegrator LeeNewmarkFull 1 .25 .5 -type3 .05 1 .5\nintegrator LeeNewmarkFull 1 .25 .5 -type3 .05 1 1 1 1 1 .5\nintegrator LeeNewmarkFull 1 .25 .5 -type3 .01 1 .5 -type2 .01 1 2 3 -type2 .01 1 2 1 -type0 .01 1 -type1 .01 1 2\n</code></pre> <p>With the above commands, we use \\(\\(\\alpha=0.25\\)\\) and \\(\\(\\beta=0.5\\)\\) in Newmark method. Users need to manually compute \\(\\(\\zeta_p\\)\\), \\(\\(\\omega_p\\)\\) and other parameters to obtain desired curve.</p> <p>There is no validation of input parameters. It is users' responsibility to ensure parameters are valid, and the resulting curve is desired. Please refer to the references for customization of damping curves.</p> <p>One can also use Damping Dolphin to generate parameter sets.</p>"},{"location":"Library/Integrator/Newmark/Newmark/","title":"Newmark","text":"<p>Newmark Time Integration</p>"},{"location":"Library/Integrator/Newmark/Newmark/#syntax","title":"Syntax","text":"Text Only<pre><code>integrator Newmark (1) [2] [3]\n# (1) int, unique tag\n# [2] double, alpha, default: 0.25\n# [3] double, beta, default: 0.5\n</code></pre>"},{"location":"Library/Integrator/Newmark/Newmark/#governing-equation","title":"Governing Equation","text":"<p>The displacement and velocity are integrated as</p> \\[ d_{n+1}=d_n+\\Delta{}tv_n+\\Delta{}t^2\\left(\\left(\\dfrac{1}{2}-\\alpha\\right)a_n+\\alpha{}a_{n+1}\\right), \\] \\[ v_{n+1}=v_n+\\Delta{}t\\left(1-\\beta\\right)a_n+\\Delta{}t\\beta{}a_{n+1}. \\] <p>The equation of motion is expressed at \\(\\(t_{n+1}\\)\\).</p> \\[ Ma_{n+1}+Cv_{n+1}+Kd_{n+1}=F_{n+1}. \\]"},{"location":"Library/Integrator/Newmark/RayleighNewmark/","title":"RayleighNewmark","text":"<p>Newmark Algorithm With Rayleigh Damping Model</p> <p>The <code>RayleighNewmark</code> integrator is simply a wrapper of the <code>Newmark</code> integrator with Rayleigh model implemented on global level.</p> <p>For the moment, MPC cannot be considered in all global damping models.</p> Text Only<pre><code># valid starting from version 2.x\nintegrator RayleighNewmark (1) (2) (3) (4) (5) (6) (7)\n# (1) int, unique tag\n# (2) double, alpha (beta in some references) in Newmark method, normally 0.25\n# (3) double, beta (gamma in some references) in Newmark method, normally 0.5\n# (4) double, alpha\n# (5) double, beta\n# (6) double, theta\n# (7) double, eta\n</code></pre>"},{"location":"Library/Integrator/Newmark/RayleighNewmark/#theory","title":"Theory","text":"<p>By default, the Rayleigh type damping model is used. No matter what other damping modifiers are defined, this integrator always set the element damping matrix to be</p> \\[ C=\\alpha{}M+\\beta{}K_C+\\theta{}K_I+\\eta{}K_T \\] <p>by the <code>Rayleigh</code> modifier in addition to the existing damping matrix defined in the element. In the above formulation, \\(\\(K_C\\)\\) is the current converged stiffness, \\(\\(K_I\\)\\) is the initial stiffness of the element, \\(\\(K_T\\)\\) is the trial stiffness of current iteration. Please note if \\(\\(K_T\\)\\) is involved, the damping force is then a function of trial displacement. The quadratic convergence rate is lost then.</p>"},{"location":"Library/Integrator/Newmark/WilsonPenzienNewmark/","title":"WilsonPenzienNewmark","text":"<p>The <code>WilsonPenzienNewmark</code> incorporates the Wilson-Penzien damping model.</p> <p>For the moment, MPC cannot be considered in all global damping models.</p>"},{"location":"Library/Integrator/Newmark/WilsonPenzienNewmark/#syntax","title":"Syntax","text":"Text Only<pre><code>integrator WilsonPenzienNewmark (1) (2) (3) [4...]\n# (1) int, unique integrator tag\n# (2) double, alpha (beta in some references) in Newmark method, normally 0.25\n# (3) double, beta (gamma in some references) in Newmark method, normally 0.5\n# [4...] double, damping ratios on the first n modes\n</code></pre>"},{"location":"Library/Integrator/Newmark/WilsonPenzienNewmark/#theory","title":"Theory","text":"<p>The Wilson-Penzien damping model is defined by using global mode shapes. For the generalized eigenvalue problem, the natural frequencies \\(\\(\\omega\\)\\) and mode shapes \\(\\(\\mathbf{\\phi}\\)\\) are defined to be</p> \\[ \\mathbf{K\\phi}=\\omega^2\\mathbf{M\\phi}. \\] <p>The damping matrix is defined to be</p> \\[ \\mathbf{C}=\\mathbf{\\theta{}D}\\mathbf{\\theta}^\\mathrm{T}, \\] <p>where \\(\\(\\mathbf{D}\\)\\) is the diagonal matrix with diagonal entries to be \\(\\(\\dfrac{2\\xi_n\\omega_n}{M_n}\\)\\), and \\(\\(\\mathbf{\\theta}=\\mathbf{M\\phi}\\)\\).</p> <p>However, the damping matrix is not explicitly formed, since \\(\\(\\mathbf{C}\\)\\) is fully populated while \\(\\(\\mathbf{K}\\)\\) and \\(\\(\\mathbf{M}\\)\\) may be stored in a banded or even sparse scheme.</p>"},{"location":"Library/Integrator/Newmark/WilsonPenzienNewmark/#implementation","title":"Implementation","text":"<p>In order to implement the algorithm, the Woodbury identity is utilized. The global solving equation is</p> \\[ \\mathbf{K}_e\\mathbf{\\Delta{}U}=\\mathbf{R}, \\] <p>with \\(\\(\\mathbf{K}_e=\\mathbf{K}+c_0\\mathbf{M}+c_1\\mathbf{C}\\)\\) to be the effective stiffness matrix. By denoting \\(\\(\\mathbf{K}+c_0\\mathbf{M}+c_1\\mathbf{C}_v\\)\\) to be \\(\\(\\mathbf{\\bar{K}}\\)\\), then</p> \\[ \\mathbf{K}_e\\mathbf{\\Delta{}U}=(\\mathbf{\\bar{K}}+c_1\\mathbf{C})\\mathbf{\\Delta{}U}=\\mathbf{R}, \\] \\[ \\mathbf{\\Delta{}U}=(\\mathbf{\\bar{K}}+\\mathbf{\\theta{}}\\mathbf{\\bar{D}}\\mathbf{\\theta}^\\mathrm{T})^{-1}\\mathbf{R}, \\] <p>where \\(\\(\\mathbf{\\bar{D}}=c_1\\mathbf{D}\\)\\). Note \\(\\(c_0\\)\\) and \\(\\(c_1\\)\\) are the corresponding parameters used in Newmark algorithm. Note \\(\\(\\mathbf{C}_v\\)\\) is used to denote the additional viscous damping effect due to viscous devices such as dampers. This part does not contribute the formulation of global damping matrix.</p> <p>By using the Woodbury identity, one could obtain</p> \\[ \\mathbf{\\Delta{}U}=(\\mathbf{\\bar{K}}+\\mathbf{\\theta{}}\\mathbf{\\bar{D}}\\mathbf{\\theta}^\\mathrm{T}) ^{-1}\\mathbf{R}, \\] \\[ \\mathbf{\\Delta{}U}=(\\mathbf{\\bar{K}}^{-1}-\\mathbf{\\bar{K}}^{-1}\\mathbf{\\theta{}}( \\mathbf{\\bar{D}}^{-1}+\\mathbf{\\theta}^\\mathrm{T}\\mathbf{\\bar{K}}^{-1}\\mathbf{\\theta}) ^{-1}\\mathbf{\\theta}^\\mathrm{T}\\mathbf{\\bar{K}}^{-1})\\mathbf{R}. \\] <p>Note \\(\\(\\mathbf{\\bar{D}}^{-1}\\)\\) can be conveniently formulated as it is simply a diagonal matrix.</p> <p>The above formula requires two additional function calls to matrix solver. If the factorization can be stored, this reduces to two backward substitutions.</p>"},{"location":"Library/Material/Guide/Customisation/","title":"Customisation","text":"<p>A number of universal wrappers are provided for uniaxial material models. Analysts can flexibly combine arbitrary number of simple material models to behave under a certain rheology structure.</p> <p>The <code>Parallel</code> and <code>Sequential</code> wrappers can be used to create models that are rate independent.</p>"},{"location":"Library/Material/Guide/Metal/","title":"Metal","text":"<p>To model metals, von Mises yielding criterion based models are often used.</p>"},{"location":"Library/Material/Guide/Metal/#1d","title":"1D","text":"<p>The simplest von Mises bilinear hardening model with/without linear kinematic hardening rule (Prager's rule) can be used for simple analysis tasks.</p> <p>The <code>Bilinear1D</code> model supports both linear isotropic and kinematic hardening rules. The <code>BilinearMises1D</code> model is an example of derived classes of the <code>Mises1D</code> model and only implements the isotropic hardening.</p> <p>The <code>ExpMises1D</code> model implements the exponential type isotropic hardening rule with a saturated stress, again there is no kinematic hardening defined.</p> <p>For nonlinear kinematic hardening rule, often an Armstrong-Frederick type definition is used for modelling Bauschinger effect. Two models are available, they are the <code>ArmstrongFredick1D</code> model which is rate dependent and the <code>VAFCRP1D</code> model which is rate dependent, the corresponding viscosity is defined in a Peric style. If experiment data is available, those two models will give better simulation results for a wide range of metals.</p> <p>Another model that can be used is the asymmetric <code>SteelBRB</code> model which is developed to simulate BRBs. It has a rheology model which reveals some insights of response.</p> <p>For general phenomenological hysteresis models, the <code>MPF</code> model ( Menegotto-Pinto-Filippou model) and the <code>RambergOsgood</code> model are widely used. In terms of the determination of the model parameters, readers are referred to the related literature.</p> <p>The Bouc-Wen family (<code>BoucWen</code> and <code>BWBN</code>) can be used.</p>"},{"location":"Library/Material/Guide/Metal/#3d","title":"3D","text":"<p>Apart from the <code>MPF</code> model and the <code>RambergOsgood</code> model, other models have the corresponding 3D versions.</p>"},{"location":"Library/Material/Material1D/Material1D/","title":"Material1D","text":"<p>All uniaxial material models support the following basic output types.</p> variable label physical meaning S, S11 uniaxial stress E, E11 uniaxial strain EE elastic strain PE plastic strain HIST history vector <p>Depending on the specific material model, additional output types may be available.</p> <p>The history vector is a vector of variadic length that stores the necessary history variables for the material model. Different material models may have different history variable storage layout.</p>"},{"location":"Library/Material/Material1D/Concrete/ConcreteCM/","title":"ConcreteCM","text":"<p>Chang-Mander Concrete Model</p>"},{"location":"Library/Material/Material1D/Concrete/ConcreteCM/#syntax","title":"Syntax","text":"Text Only<pre><code>material ConcreteCM (1) (2) (3) (4) (5) (6) [7] [8] [9] [10]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, compression strength, should be negative but sign insensitive\n# (4) double, tension strength, should be positive but sign insensitive\n# (5) double, NC\n# (6) double, NT\n# [7] double, strain at compression strength, default: -2E-3\n# [8] double, strain at tension strength, default: 1E-4\n# [9] bool string, linear transition switch, default: false\n# [10] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material1D/Concrete/ConcreteCM/#remarks","title":"Remarks","text":"<ol> <li>The Chang-Mander concrete model uses Tsai's equation as backbone curves for both tension and compression.</li> <li>Parameters <code>NC</code> and <code>NT</code> control the shapes of backbone curves. A detailed explanation is presented later.</li> <li>In the original model, the transition between compression and tension could sometimes have larger stiffness than    initial stiffness. This is unlikely to be true in reality.</li> <li>A linear behaviour of part of hysteresis behaviour can be applied by turning on the linear transition switch. It    shall be noted that a linear hysteresis rule is much more stable than the original version.</li> <li>The original CM model has some undefined behaviour which may cause stability issues. This is a simplified model.</li> </ol>"},{"location":"Library/Material/Material1D/Concrete/ConcreteCM/#history-variable-layout","title":"History Variable Layout","text":"location value <code>initial_history(0)</code> unload_c_strain <code>initial_history(1)</code> unload_c_stress <code>initial_history(2)</code> reverse_c_strain <code>initial_history(3)</code> reverse_c_stress <code>initial_history(4)</code> residual_c_strain <code>initial_history(5)</code> residual_c_stiffness <code>initial_history(6)</code> unload_t_strain <code>initial_history(7)</code> unload_t_stress <code>initial_history(8)</code> reverse_t_strain <code>initial_history(9)</code> reverse_t_stress <code>initial_history(10)</code> residual_t_strain <code>initial_history(11)</code> residual_t_stiffness <code>initial_history(12)</code> connect_c_stress <code>initial_history(13)</code> connect_c_stiffness <code>initial_history(14)</code> connect_t_stress <code>initial_history(15)</code> connect_t_stiffness <code>initial_history(16)</code> inter_strain <code>initial_history(17)</code> inter_stress <code>initial_history(18)</code> reload_c_stiffness <code>initial_history(19)</code> reload_t_stiffness"},{"location":"Library/Material/Material1D/Concrete/ConcreteCM/#general-description-of-the-model","title":"General Description of the Model","text":""},{"location":"Library/Material/Material1D/Concrete/ConcreteCM/#unload-from-backbone","title":"Unload from backbone","text":""},{"location":"Library/Material/Material1D/Concrete/ConcreteCM/#reload-from-unload-branch","title":"Reload from unload branch","text":""},{"location":"Library/Material/Material1D/Concrete/ConcreteCM/#reload-before-residual","title":"Reload before residual","text":""},{"location":"Library/Material/Material1D/Concrete/ConcreteCM/#reload-between-two-residuals","title":"Reload between two residuals","text":""},{"location":"Library/Material/Material1D/Concrete/ConcreteCM/#reload-after-the-opposite-residual","title":"Reload after the opposite residual","text":""},{"location":"Library/Material/Material1D/Concrete/ConcreteCM/#small-cycle","title":"Small Cycle","text":""},{"location":"Library/Material/Material1D/Concrete/ConcreteCM/#determination-of-parameters","title":"Determination of Parameters","text":"<p>The Tsai's equation (Tsai, 1988) can be expressed as</p> \\[ y=\\dfrac{mx}{1+(m-\\dfrac{n}{n-1})x+\\dfrac{x^n}{n-1}}. \\] <p>where \\(\\(x=\\varepsilon/\\varepsilon_c\\)\\) or \\(\\(x=\\varepsilon/\\varepsilon_t\\)\\) is normalized strain and \\(\\(y=f/f_c\\)\\) and \\(\\(y=f/f_t\\)\\) are normalized stress. The stress decreases to zero if \\(\\(m(n-1)&gt;n\\)\\) and \\(\\(n&gt;1\\)\\). The initial stiffness is related to \\(\\(m_t\\)\\) and \\(\\(m_c\\)\\) by</p> \\[ E_0=mE_s=m_t\\dfrac{f_t}{\\varepsilon_t}=m_c\\dfrac{f_c}{\\varepsilon_c}. \\] <p>Once \\(\\(E_0\\)\\) is given, \\(\\(m_c\\)\\) and \\(\\(m_t\\)\\) are determined automatically.</p> <p>The parameter \\(\\(n\\)\\) controls the slope of descending branch, normally \\(\\(n_t&gt;n_c\\)\\). Some empirical expressions are available to determine both \\(\\(m\\)\\) and \\(\\(n\\)\\). But most are unit dependent. Users shall do manual conversion. For example,</p> \\[ m_c=1+\\dfrac{17.9}{f_c}\\quad{}f_c\\text{ in MPa}, \\] \\[ m_c=1+\\dfrac{2600}{f_c}\\quad{}f_c\\text{ in psi}, \\] \\[ n_c=\\dfrac{f_c}{6.68}-1.85&gt;1\\quad{}f_c\\text{ in MPa}, \\] \\[ n_c=\\dfrac{f_c}{970}-1.85&gt;1\\quad{}f_c\\text{ in psi}. \\]"},{"location":"Library/Material/Material1D/Concrete/ConcreteExp/","title":"ConcreteExp","text":"<p>Objective Concrete Model</p> <p>The <code>ConcreteExp</code> model uses the exponential functions from the Barcelona model (Lubliner, 1989) as the backbones. The main advantage is now the area under the backbone has an upper bound and can be explicitly integrated. By associating this value with objective quantities, it is possible to obtain a uni-axial concrete model that supports objective response.</p>"},{"location":"Library/Material/Material1D/Concrete/ConcreteExp/#syntax","title":"Syntax","text":"Text Only<pre><code>material ConcreteExp (1) (2) (3) (4) (5) (6) (7) (8) [9] [10]\n# (1) int, unique tag\n# (2) double, elastic modulus\n# (3) double, f_t\n# (4) double, a_t\n# (5) double, g_t\n# (6) double, f_{c,m}\n# (7) double, a_c\n# (8) double, g_c\n# [9] double, middle point, default: 0.2\n# [10] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material1D/Concrete/ConcreteExp/#history-variable-layout","title":"History Variable Layout","text":"<p>Since it is derived from the <code>SimpleHysteresis</code> model, they share the same history variable layout.</p>"},{"location":"Library/Material/Material1D/Concrete/ConcreteExp/#theory","title":"Theory","text":"<p>For both tension and compression, the following equation is used for the backbone.</p> \\[ \\dfrac{\\sigma}{f}=\\left(1+a\\right)\\exp\\left(-b\\varepsilon_p\\right)-a\\exp\\left(-2b\\varepsilon_p\\right) \\] <p>where \\(\\(a\\)\\) and \\(\\(b\\)\\) are two material properties that control the shape of the backbone. For tension, \\(\\(a&lt;1\\)\\). For compression \\(\\(a&gt;1\\)\\).</p> <p>The area under the backbone is</p> \\[ g=\\dfrac{a+2}{2b}f. \\] <p>So for a fixed \\(\\(g\\)\\), \\(\\(b\\)\\) can be computed as</p> \\[ b=\\dfrac{a+2}{2g}f. \\] <p>The model accepts \\(\\(g_t\\)\\) and \\(\\(g_c\\)\\) in order to obtain objective results.</p> <p>The parameters \\(\\(f_t\\)\\) and \\(\\(f_c\\)\\) are elastic limits of tension and compression respectively. However, the maximum strength (\\(f_{c,m}\\)\\) are taken as inputs since for compression there is a hardening response.</p> <p>It could be derived that</p> \\[ \\dfrac{f_c}{f_{c,m}}=\\dfrac{4a_c}{\\left(1+a_c\\right)^2}. \\] <p>If, as normally assumed, the elastic limit of \\(\\(80~\\%\\)\\) of the maximum strength, then</p> \\[ \\dfrac{f_c}{f_{c,m}}=\\dfrac{4a_c}{\\left(1+a_c\\right)^2}=0.8,\\qquad a_c\\approx3.73. \\] <p>For other ratios, \\(\\(a_c\\)\\) can be determined accordingly.</p>"},{"location":"Library/Material/Material1D/Concrete/ConcreteExp/#determination-of-parameters","title":"Determination of Parameters","text":"<p>The parameter \\(\\(g_t\\)\\) could be associated with the mode one specific fracture energy of the material. For concrete, it typically ranges from \\(\\(40~\\mathrm{N/m}\\)\\) to \\(\\(120~\\mathrm{N/m}\\)\\) (according to ABAQUS). Values of similar scale can be used.</p> <p>The counterpart \\(\\(g_c\\)\\) can be chosen as several hundred times larger than \\(\\(g_t\\)\\).</p> <p>The \\(\\(a_t\\)\\) can be set to \\(\\((0,~1)\\)\\), typically, a value of \\(\\(0.7\\)\\) is good for general use. The \\(\\(a_c\\)\\) is greater than \\(\\(1\\)\\). A larger \\(\\(a_c\\)\\) has a narrower hardening region and thus degrades more rapidly. For high strength concrete, \\(\\(a_c\\)\\) can be large. For low strength concrete, \\(\\(a_c\\)\\) could be around \\(\\(2\\)\\).</p> Text Only<pre><code>material ConcreteExp 1 3E4 3. .6 4E-3 30. 4. 1E-1 .2\n</code></pre> <p>The above command has the following tension response (strain and stress).</p> <p></p> <p>And the following compression response.</p> <p></p>"},{"location":"Library/Material/Material1D/Concrete/ConcreteExp/#example","title":"Example","text":"<p>First we shall how to obtain objective results.</p> <p>Consider the uniaxial tension/compression of a prismatic bar of unit length, it can be modelled by the truss element ( T2D2). With one element defined, the material model can be defined as follows.</p> Text Only<pre><code>material ConcreteExp 1 3E4 3. .6 4E-3 30. 4. 1E-1 .2\n</code></pre> <p>Then define two elements to model the bar. Since the characteristic length is halved, \\(\\(g_t\\)\\) and \\(\\(g_c\\)\\) shall be doubled.</p> Text Only<pre><code>material ConcreteExp 2 3E4 3. .6 2E-3 30. 4. 5E-2 .2\n</code></pre> <p>Easy to see that the response is fully objective.</p> <p></p> <p>The full script of the model is listed.</p> Text Only<pre><code>node 1 0 0\nnode 2 1 0\nnode 3 2 0\n\nmaterial ConcreteExp 1 3E4 3. .6 4E-3 30. 4. 1E-1 .2\nmaterial ConcreteExp 2 3E4 3. .6 2E-3 30. 4. 5E-2 .2\n\n# two elements\n# element T2D2 1 1 2 1 100\n# element T2D2 2 2 3 1 100\n\n# one element\n# element T2D2 1 1 3 2 100\n\nfix 1 1 1\nfix 2 2 1 2 3\n\nhdf5recorder 1 Node RF1 3\nhdf5recorder 2 Node U1 3\n\nstep static 1\nset ini_step_size 1E-2\nset fixed_step_size 1\n\ndisplacement 1 0 2E-3 1 3\n\nconverger AbsIncreDisp 1 1E-8 10 1\n\nanalyze\n\nsave recorder 1 2\n\nexit\n</code></pre>"},{"location":"Library/Material/Material1D/Concrete/ConcreteTsai/","title":"ConcreteTsai","text":"<p>Uniaxial Concrete Model Using Tsai's Equation</p> <p>The <code>ConcreteTsai</code> model is a simple concrete model using Tsai's equation.</p>"},{"location":"Library/Material/Material1D/Concrete/ConcreteTsai/#syntax","title":"Syntax","text":"Text Only<pre><code>material ConcreteTsai (1) (2) (3) (4) (5) (6) (7) [8] [9] [10] [11]\n# (1) int, unique material tag\n# (2) double, compression strength, should be negative but sign insensitive\n# (3) double, tension strength, should be positive but sign insensitive\n# (4) double, MC\n# (5) double, NC\n# (6) double, MT\n# (7) double, NT\n# [8] double, strain at compression strength, default: -2E-3\n# [9] double, strain at tension strength, default: 1E-4\n# [10] double, middle point, default: 0.2\n# [11] double, density, default: 0.0\n</code></pre> Text Only<pre><code>material ConcreteTsai (1) (2) (3) (4) (5) [6] [7] [8] [9]\n# (1) int, unique material tag\n# (2) double, compression strength, should be negative but sign insensitive\n# (3) double, tension strength, should be positive but sign insensitive\n# (4) double, M\n# (5) double, N\n# [6] double, strain at compression strength sign insensitive, default: -2E-3\n# [7] double, strain at tension strength sign insensitive, default: 1E-4\n# [8] double, middle point, default: 0.2\n# [9] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material1D/Concrete/ConcreteTsai/#history-variable-layout","title":"History Variable Layout","text":"<p>Since it is derived from the <code>SimpleHysteresis</code> model, they share the same history variable layout.</p>"},{"location":"Library/Material/Material1D/Concrete/ConcreteTsai/#remarks","title":"Remarks","text":"<ol> <li>The middle point parameter represents the size of hysteresis loop, valid values range from 0 to 1 (ends not    recommended).</li> <li>There is no additional consideration for small loops, which is available in <code>ConcreteCM</code>.</li> </ol>"},{"location":"Library/Material/Material1D/Concrete/ConcreteTsai/#usage","title":"Usage","text":"Text Only<pre><code>material ConcreteTsai 1 30 20 2 2 2 2 .8 2E-3 2E-3\nmaterialTest1D 1 1E-4 50 100 120 140 160 180\nexit\n</code></pre> Text Only<pre><code>material ConcreteTsai 1 30 20 2 2 2 2 .1 2E-3 2E-3\nmaterialTest1D 1 1E-4 50 100 120 140 160 180\nexit\n</code></pre>"},{"location":"Library/Material/Material1D/Degradation/Degradation/","title":"Degradation","text":"<p>The uniaxial degradation model can be implemented separately from the intact material model if the degradation model only depends on the input strain history or the output stress and stiffness.</p>"},{"location":"Library/Material/Material1D/Degradation/Degradation/#stress","title":"Stress","text":"<p>The general expression of a degradation model can be expressed as</p> \\[ \\sigma=D\\bar{\\sigma}=(1-d)\\bar{\\sigma} \\] <p>where \\(\\(D\\)\\) and \\(\\(d\\)\\) are degradation factors, \\(\\(\\bar\\sigma\\)\\) is the stress of the intact material model. Whether to use \\(\\(D\\)\\) or \\(\\((1-d)\\)\\) relies on the specific definition of degradation. Here we focus on the first expression.</p>"},{"location":"Library/Material/Material1D/Degradation/Degradation/#stiffness","title":"Stiffness","text":"<p>The stiffness can be expressed by applying the chain rule.</p> \\[ K=\\dfrac{\\mathrm{d}\\sigma}{\\mathrm{d}\\varepsilon}=\\dfrac{\\partial{}D}{\\partial\\varepsilon}\\bar\\sigma+D\\dfrac{\\partial\\bar\\sigma}{\\partial\\varepsilon}=\\dfrac{\\partial{}D}{\\partial\\varepsilon}\\bar\\sigma+D\\bar{K} \\] <p>where \\(\\(\\bar{K}\\)\\) is the stiffness from the intact material model.</p>"},{"location":"Library/Material/Material1D/Degradation/Degradation/#computation-procedure","title":"Computation Procedure","text":"<p>In general, the computation procedure of a degradation model can be listed as follows.</p> <ol> <li>input trial strain and trial strain rate if required</li> <li>call the associated intact material model to compute the intact stress and stiffness</li> <li>calculate \\(\\(D\\)\\) and \\(\\(\\dfrac{\\partial{}D}{\\partial{}\\varepsilon}\\)\\) accordingly and update history variables if any</li> <li>update trial stress and trial stiffness</li> </ol>"},{"location":"Library/Material/Material1D/Degradation/Degradation/#caveats","title":"Caveats","text":"<p>Such a formulation is only valid for the damage models that do not depend on plasticity history.</p>"},{"location":"Library/Material/Material1D/Elastic/BilinearElastic1D/","title":"BilinearElastic1D","text":"<p>Uniaxial Bilinear Elastic Material</p>"},{"location":"Library/Material/Material1D/Elastic/BilinearElastic1D/#syntax","title":"Syntax","text":"Text Only<pre><code>material BilinearElastic1D (1) (2) (3) (4) [5]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, yield stress\n# (4) double, hardening modulus\n# [5] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material1D/Elastic/BilinearElastic1D/#usage","title":"Usage","text":"Text Only<pre><code>material BilinearElastic1D 1 100 50 0.1\n</code></pre>"},{"location":"Library/Material/Material1D/Elastic/CustomElastic1D/","title":"CustomElastic1D","text":"<p>General Uniaxial Elastic Material Model Using Custom Expression</p>"},{"location":"Library/Material/Material1D/Elastic/CustomElastic1D/#syntax","title":"Syntax","text":"Text Only<pre><code>material CustomElastic1D (1) (2) [3]\n# (1) int, unique material tag\n# (2) int, associated expression tag\n# [3] double, density, default: 0\n</code></pre>"},{"location":"Library/Material/Material1D/Elastic/CustomElastic1D/#example","title":"Example","text":"<p>See expression.</p>"},{"location":"Library/Material/Material1D/Elastic/Elastic1D/","title":"Elastic1D","text":"<p>Uniaxial Elastic Material</p>"},{"location":"Library/Material/Material1D/Elastic/Elastic1D/#syntax","title":"Syntax","text":"Text Only<pre><code>material Elastic1D (1) (2) [3]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# [3] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material1D/Elastic/Elastic1D/#usage","title":"Usage","text":"Text Only<pre><code>material Elastic1D 1 100 0.\nmaterialTest1D 1 1E-2 100 200\nexit\n</code></pre>"},{"location":"Library/Material/Material1D/Elastic/MultilinearElastic1D/","title":"MultilinearElastic1D","text":"<p>Uniaxial Multilinear Elastic Material</p>"},{"location":"Library/Material/Material1D/Elastic/MultilinearElastic1D/#theory","title":"Theory","text":"<p>A simple uniaxial multilinear elastic material model. The <code>BilinearElastic1D</code> model is a special case of this model.</p>"},{"location":"Library/Material/Material1D/Elastic/MultilinearElastic1D/#syntax","title":"Syntax","text":"Text Only<pre><code>material MultilinearElastic1D (1) (2 3...) [4]\n# (1) int, unique material tag\n# (2) double, strain of the data point\n# (3) double, stress of the data point\n# [4] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material1D/Elastic/MultilinearElastic1D/#usage","title":"Usage","text":"<p>The first point does not need to be origin. Starting from the first non-zero point is fine. Multiple data points can be defined. A constant response is assumed after the last point.</p> Text Only<pre><code>material MultilinearElastic1D 1 1E-3 35 2E-3 40 3E-3 45 4E-3 30\n</code></pre> <p></p>"},{"location":"Library/Material/Material1D/Elastic/NLE1D01/","title":"NLE1D01","text":"<p>Nonlinear Elastic 1D Type 01</p> <p>The <code>NLE1D01</code> material is a smoothed uniaxial bilinear elastic material model which uses the MP formula to approximate the bilinear backbone.</p>"},{"location":"Library/Material/Material1D/Elastic/NLE1D01/#syntax","title":"Syntax","text":"Text Only<pre><code>material NLE1D01 (1) (2) (3) (4) [5] [6]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, turning stress\n# (4) double, hardening ratio\n# [5] double, radius of transition, default: 20\n# [6] double, density, default: 0\n</code></pre>"},{"location":"Library/Material/Material1D/Elastic/PolyElastic1D/","title":"PolyElastic1D","text":"<p>Polynomial Based Uniaxial Nonlinear Elastic</p>"},{"location":"Library/Material/Material1D/Elastic/PolyElastic1D/#syntax","title":"Syntax","text":"Text Only<pre><code>material PolyElastic1D (1) [(2)...]\n# (1) int, unique material tag\n# (2) double, polynomial parameters, a_n\n</code></pre>"},{"location":"Library/Material/Material1D/Elastic/PolyElastic1D/#theory","title":"Theory","text":"<p>The stress response is defined as a polynomial function of strain on the positive strain (\\(\\(\\varepsilon&gt;0\\)\\)).</p> \\[ \\sigma=a_1\\varepsilon+a_2\\varepsilon^2+a_3\\varepsilon^3\\cdots \\] <p>The response is always an odd function so that</p> \\[ \\sigma\\left(\\varepsilon\\right)=-\\sigma\\left(-\\varepsilon\\right) \\] <p>For example, if one wants to define</p> \\[ \\sigma=4\\varepsilon+6\\varepsilon^2+2\\varepsilon^3, \\] <p>the following command shall be used.</p> Text Only<pre><code>material PolyElastic1D 1 4. 6. 2.\n</code></pre> <p>Please note density is not supported in this model.</p>"},{"location":"Library/Material/Material1D/Elastic/Sinh1D/","title":"Sinh1D","text":"<p>Uniaxial Elastic Material Using \\(\\(\\sinh\\)\\)</p>"},{"location":"Library/Material/Material1D/Elastic/Sinh1D/#syntax","title":"Syntax","text":"Text Only<pre><code>material Elastic1D (1) (2) [3]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# [3] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material1D/Elastic/Sinh1D/#theory","title":"Theory","text":"<p>The constitutive equation is defined as</p> \\[ \\sigma=E\\sinh(\\epsilon), \\] <p>where \\(\\(E\\)\\) is the elastic modulus and \\(\\(\\epsilon\\)\\) is the strain.</p>"},{"location":"Library/Material/Material1D/Elastic/Tanh1D/","title":"Tanh1D","text":"<p>Uniaxial Elastic Material Using \\(\\(\\tanh\\)\\)</p>"},{"location":"Library/Material/Material1D/Elastic/Tanh1D/#syntax","title":"Syntax","text":"Text Only<pre><code>material Elastic1D (1) (2) [3]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# [3] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material1D/Elastic/Tanh1D/#theory","title":"Theory","text":"<p>The constitutive equation is defined as</p> \\[ \\sigma=E\\tanh(\\epsilon), \\] <p>where \\(\\(E\\)\\) is the elastic modulus and \\(\\(\\epsilon\\)\\) is the strain.</p>"},{"location":"Library/Material/Material1D/Hysteresis/AFC/","title":"AFC","text":"<p>Asymmetrical Friction Connection</p>"},{"location":"Library/Material/Material1D/Hysteresis/AFC/#theory","title":"Theory","text":"<p>The <code>AFC</code> model is a bilinear hardening model with an unloading stiffness differs from the initial stiffness. The term AFC comes from \"asymmetric friction connection\" which is a type of energy dissipaters. But this model can be used in other applications.</p>"},{"location":"Library/Material/Material1D/Hysteresis/AFC/#syntax","title":"Syntax","text":"Text Only<pre><code>material AFCS (1) (2) (3) (4) (5)\nmaterial AFC02 (1) (2) (3) (4) (5)\n# (1) int, unique tag\n# (2) double, elastic modulus\n# (3) double, yield stress\n# (4) double, hardening modulus\n# (5) double, unloading modulus\n\nmaterial AFC (1) (2) (3) (4) (5) (6) (7) (8)\nmaterial AFC01 (1) (2) (3) (4) (5) (6) (7) (8)\n# (1) int, unique tag\n# (2) double, elastic modulus\n# (3) double, tension yield stress\n# (4) double, tension hardening modulus\n# (5) double, tension unloading modulus\n# (6) double, compression yield stress\n# (7) double, compression hardening modulus\n# (8) double, compression unloading modulus\n</code></pre>"},{"location":"Library/Material/Material1D/Hysteresis/AFC/#history-variable-layout","title":"History Variable Layout","text":"location value <code>initial_history(0)</code> load_sign <code>initial_history(1)</code> max_strain <code>initial_history(2)</code> reverse_strain <code>initial_history(3)</code> start_strain <code>initial_history(4)</code> start_stress <code>initial_history(5)</code> end_strain <code>initial_history(6)</code> end_stress"},{"location":"Library/Material/Material1D/Hysteresis/AFC/#remarks","title":"Remarks","text":"<ol> <li><code>AFC02</code> is a wrapper of <code>AFC01</code>. It provides a symmetric behavior while <code>AFC01</code> provides an asymmetric behavior.</li> </ol>"},{"location":"Library/Material/Material1D/Hysteresis/AFC/#examples","title":"Examples","text":"Text Only<pre><code>material AFC02 1 100 10 5 200\nmaterialTest1D 1 1E-3 150 25 125 100 100 200 100 300 125 150\nexit\n</code></pre> Text Only<pre><code>material AFC01 1 100 10 5 200 20 2 300\nmaterialTest1D 1 1E-3 150 25 125 100 100 200 100 300 125 150\nexit\n</code></pre> Text Only<pre><code>material AFC02 1 100 10 .1 500\nmaterialTest1D 1 1E-2 20 40 60 80 100 120 140 160 80\nexit\n</code></pre>"},{"location":"Library/Material/Material1D/Hysteresis/AFCN/","title":"AFCN","text":"<p>Nonlinear Version of AFC</p>"},{"location":"Library/Material/Material1D/Hysteresis/AFCN/#theory","title":"Theory","text":"<p>The difference between the <code>AFC</code> model and this AFCN model is the initial loading part. This AFCN model accounts for additional slip-lock effect.</p>"},{"location":"Library/Material/Material1D/Hysteresis/AFCN/#syntax","title":"Syntax","text":"Text Only<pre><code>material AFCN (1) (2) (3) (4) (5) (6) (7) (8) [9] [10]\n# (1) int, unique tag\n# (2) double, elastic modulus\n# (3) double, tension yield stress\n# (4) double, tension hardening modulus\n# (5) double, tension unloading modulus\n# (6) double, compression yield stress\n# (7) double, compression hardening modulus\n# (8) double, compression unloading modulus\n# [9] double, non-negative degradation paramater, default: 0.0\n# [10] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material1D/Hysteresis/AFCN/#history-variable-layout","title":"History Variable Layout","text":"location value <code>initial_history(0)</code> load_sign <code>initial_history(1)</code> max_strain <code>initial_history(2)</code> reverse_strain <code>initial_history(3)</code> start_strain <code>initial_history(4)</code> start_stress <code>initial_history(5)</code> end_strain <code>initial_history(6)</code> end_stress"},{"location":"Library/Material/Material1D/Hysteresis/AFCN/#usage","title":"Usage","text":"Text Only<pre><code>material AFCN 1 100 10 1 200 10 1 200\nmaterialTest1D 1 1E-2 20 40 60 80 100 120 140 160 80\nexit\n</code></pre>"},{"location":"Library/Material/Material1D/Hysteresis/BWBN/","title":"BWBN","text":"<p>Bouc-Wen-Baber-Noori Model</p> <p>The <code>BWBN</code> model is an extension of the <code>BoucWen</code> model with stiffness degradation, strength degradation and pinching effect.</p>"},{"location":"Library/Material/Material1D/Hysteresis/BWBN/#syntax","title":"Syntax","text":"Text Only<pre><code>material BWBN (1) [2...18]\n# (1) int, unique material tag\n# [2] double, elastic modulus, default: 2E5\n# [3] double, yield stress, default: 4E2\n# [4] double, hardening ratio, default: 1E-2\n# [5] double, \\beta (&gt;0), default: 0.5\n# [6] double, exponent n (&gt;0, normally &gt;=1), default: 1.0\n# [7] double, initial \\nu (&gt;0), default: 1.0\n# [8] double, slope of \\nu (&gt;0), default: 0.0\n# [9] double, initial \\eta (&gt;0), default: 1.0\n# [10] double, slope of \\eta (&gt;0), default: 0.0\n# [11] double, initial \\phi (&gt;0), default: 1.0\n# [12] double, slope of \\phi (&gt;0), default: 0.0\n# [13] double, \\zeta (1&gt;\\zeta&gt;0), default: 0.0\n# [14] double, slope of A (&gt;0), default: 0.0\n# [15] double, p (&gt;0), default: 0.0\n# [16] double, q (&gt;0), default: 0.0\n# [17] double, \\lambda (&gt;0), default: 1.0\n# [18] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material1D/Hysteresis/BWBN/#history-variable-layout","title":"History Variable Layout","text":"location value <code>initial_history(0)</code> <code>z</code>"},{"location":"Library/Material/Material1D/Hysteresis/BWBN/#theory","title":"Theory","text":"<p>The Wikipedia page contains sufficient information about the formulation of <code>BWBN</code> model. Some normalizations are carried out compared to the original model.</p> <p>The evolution of internal displacement \\(\\(z(t)\\)\\) is governed by the differential equation,</p> \\[ \\eta\\Delta{}z=h\\dfrac{\\Delta{}u}{u_y}\\left(A-\\nu\\left(\\gamma+\\text{sign}\\left(z\\cdot\\Delta{}u\\right)\\beta\\right) \\Big|z\\Big|^n\\right). \\] <p>Then,</p> \\[ F=aF_y\\dfrac{u}{u_y}+\\left(1-a\\right)F_yz. \\] <p>For state determination, \\(\\(z\\)\\) is solved iteratively by using the Newton method. The evolutions of internal functions rely on the dissipated energy \\(\\(e\\)\\), which is defined to be a normalized quantity.</p> \\[ e=\\left(1-a\\right)\\int{}z~\\mathrm{d}u. \\] <p>The trapezoidal rule is used so that</p> \\[ \\Delta{}e=\\left(1-a\\right)\\dfrac{2z+\\Delta{}z}{2}\\Delta{}u. \\] <p>The evolutions are</p> \\[ \\begin{align*} \\nu&amp;=\\nu_0+\\delta_\\nu{}e,\\\\[3mm] \\eta&amp;=\\eta_0+\\delta_\\eta{}e,\\\\[3mm] A&amp;=1-\\delta_Ae,\\\\[3mm] h&amp;=1-\\zeta_1\\exp\\left(-\\left(\\dfrac{z\\cdot\\text{sign}\\left(\\Delta{}u\\right)-qz_u}{\\zeta_2}\\right)^2\\right),\\\\[3mm] \\zeta_1&amp;=\\zeta\\left(1-\\exp\\left(-pe\\right)\\right),\\\\[3mm] \\zeta_2&amp;=\\left(\\phi_0+\\delta_\\phi{}e\\right)\\left(\\lambda+\\zeta_1\\right),\\\\[3mm] z_u&amp;=\\sqrt[n]{\\dfrac{1}{\\nu}}=\\nu^{-1/n}. \\end{align*} \\]"},{"location":"Library/Material/Material1D/Hysteresis/BWBN/#parameters","title":"Parameters","text":"<p>Strength degradation is controlled by \\(\\(\\nu\\)\\). To disable it, set \\(\\(\\delta_\\nu=0\\)\\).</p> <p>Stiffness degradation is controlled by \\(\\(\\eta\\)\\). To disable it, set \\(\\(\\delta_\\eta=0\\)\\).</p> <p>Pinching is controlled by \\(\\(h\\)\\). To disable it, set \\(\\(\\zeta=0\\)\\) or \\(\\(p=0\\)\\).</p>"},{"location":"Library/Material/Material1D/Hysteresis/BWBN/#examples","title":"Examples","text":""},{"location":"Library/Material/Material1D/Hysteresis/BWBN/#vanilla-model","title":"Vanilla Model","text":"<p>The default behavior is similar to a bilinear hardening material.</p> Text Only<pre><code>material BWBN 1\nmaterialtest1d 1 4E-4 10 20 30 40 50 60 70 80 90 100 110 120 130 140 150 160 80\n</code></pre> <p></p>"},{"location":"Library/Material/Material1D/Hysteresis/BWBN/#strength-degradation","title":"Strength degradation","text":"<p>A positive \\(\\(\\delta_\\nu\\)\\) enables strength degradation.</p> Text Only<pre><code>material BWBN 1 2E5 4E2 0 .5 1. 1. 1E0 1. 0. 1. 0. 0. 0. 0. 0. 1. 0.\nmaterialtest1d 1 4E-4 10 20 30 40 50 60 70 80 90 100 110 120 130 140 150 160 80\n</code></pre> <p></p> <p>A positive \\(\\(\\delta_A\\)\\) has the similar effect.</p> Text Only<pre><code>material BWBN 1 2E5 4E2 0 .5 1. 1. 0. 1. 0. 1. 0. 0. 1E0 0. 0. 1. 0.\nmaterialtest1d 1 4E-4 10 20 30 40 50 60 70 80 90 100 110 120 130 140 150 160 80\n</code></pre> <p></p>"},{"location":"Library/Material/Material1D/Hysteresis/BWBN/#stiffness-degradation","title":"Stiffness degradation","text":"<p>A positive \\(\\(\\delta_\\eta\\)\\) enables stiffness degradation.</p> Text Only<pre><code>material BWBN 1 2E5 4E2 0 .5 1 1 0 1 1E1 1 0 1 0 1 1 0 0\nmaterialtest1d 1 4E-4 10 20 30 40 50 60 70 80 90 100 110 120 130 140 150 160 80\n</code></pre> <p></p>"},{"location":"Library/Material/Material1D/Hysteresis/BWBN/#pinching-effect","title":"Pinching Effect","text":"<p>The pinching effect is governed by \\(\\(\\phi_0\\)\\), \\(\\(\\delta_\\phi\\)\\), \\(\\(\\zeta\\)\\), \\(\\(p\\)\\), \\(\\(q\\)\\) and \\(\\(\\lambda\\)\\).</p> Text Only<pre><code>material BWBN 1 2E5 4E2 0 .5 1. 1. 0. 1. 0. 1. 1E1 1. 0. 1E1 1E0 1. 0.\nmaterialtest1d 1 1E-3 10 20 30 40 50 60 70 80 90 100 110 120 130 140 150 160 80\n</code></pre> <p></p>"},{"location":"Library/Material/Material1D/Hysteresis/BilinearOO/","title":"BilinearOO","text":"<p>Bilinear Origin Oriented Model</p>"},{"location":"Library/Material/Material1D/Hysteresis/BilinearOO/#syntax","title":"Syntax","text":"<p>For symmetric response between compression and tension,</p> Text Only<pre><code>material BilinearOO (1) (2) (3) (4) [5]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, yield strain\n# (4) double, hardening ratio\n# [5] double, density, default: 0.0\n</code></pre> <p>For asymmetric response,</p> Text Only<pre><code>material BilinearOO (1) (2) (3) (4) (5) (6) [7]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, tension yield strain\n# (4) double, tension hardening ratio\n# (5) double, compression yield strain\n# (6) double, compression hardening ratio\n# [7] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material1D/Hysteresis/BilinearOO/#history-variable-layout","title":"History Variable Layout","text":"<p>Since it is derived from the <code>SimpleHysteresis</code> model, they share the same history variable layout.</p>"},{"location":"Library/Material/Material1D/Hysteresis/BilinearOO/#example","title":"Example","text":""},{"location":"Library/Material/Material1D/Hysteresis/BilinearOO/#symmetric-response","title":"Symmetric Response","text":"Text Only<pre><code>material BilinearOO 1 2E4 1E-3 .02\nmaterialTest1D 1 1E-4 50 100 150 200 250 300 150\n</code></pre>"},{"location":"Library/Material/Material1D/Hysteresis/BilinearOO/#asymmetric-response","title":"Asymmetric Response","text":"Text Only<pre><code>material BilinearOO 1 2E4 1E-3 .02 2E-3 -.05\nmaterialTest1D 1 1E-4 50 100 150 200 250 300 150\n</code></pre>"},{"location":"Library/Material/Material1D/Hysteresis/BilinearPO/","title":"BilinearPO","text":"<p>Bilinear Peak Oriented Model</p>"},{"location":"Library/Material/Material1D/Hysteresis/BilinearPO/#syntax","title":"Syntax","text":"<p>For symmetric response between compression and tension,</p> Text Only<pre><code>material BilinearPO (1) (2) (3) (4) [5]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, yield strain\n# (4) double, hardening ratio\n# [5] double, density, default: 0.0\n</code></pre> <p>For asymmetric response,</p> Text Only<pre><code>material BilinearPO (1) (2) (3) (4) (5) (6) [7]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, tension yield strain\n# (4) double, tension hardening ratio\n# (5) double, compression yield strain\n# (6) double, compression hardening ratio\n# [7] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material1D/Hysteresis/BilinearPO/#history-variable-layout","title":"History Variable Layout","text":"<p>Since it is derived from the <code>SimpleHysteresis</code> model, they share the same history variable layout.</p>"},{"location":"Library/Material/Material1D/Hysteresis/BilinearPO/#example","title":"Example","text":""},{"location":"Library/Material/Material1D/Hysteresis/BilinearPO/#symmetric-response","title":"Symmetric Response","text":"Text Only<pre><code>material BilinearPO 1 2E4 1E-3 .02\nmaterialTest1D 1 1E-4 50 100 150 200 250 300 150\n</code></pre>"},{"location":"Library/Material/Material1D/Hysteresis/BilinearPO/#asymmetric-response","title":"Asymmetric Response","text":"Text Only<pre><code>material BilinearPO 1 2E4 1E-3 .02 2E-3 -.05\nmaterialTest1D 1 1E-4 50 100 150 200 250 300 150\n</code></pre>"},{"location":"Library/Material/Material1D/Hysteresis/BoucWen/","title":"BouncWen","text":"<p>Bouc-Wen Model</p> <p>The <code>BoucWen</code> model is a phenomenological model. Compared to the original formulation, the following modifications are applied.</p> <ol> <li>\\(\\(A=1\\)\\).</li> <li>\\(\\(\\gamma+\\beta=1\\)\\).</li> </ol>"},{"location":"Library/Material/Material1D/Hysteresis/BoucWen/#theory","title":"Theory","text":"<p>The evolution of internal displacement \\(\\(z(t)\\)\\) is governed by the differential equation,</p> \\[ \\Delta{}z=\\dfrac{\\Delta{}u}{u_y}\\left(1-\\left(\\gamma+\\text{sign}\\left(z\\cdot\\Delta{}u\\right)\\beta\\right) \\Big|z\\Big|^n\\right). \\] <p>Then,</p> \\[ F=aF_y\\dfrac{u}{u_y}+\\left(1-a\\right)F_yz. \\] <p>For state determination, \\(\\(z\\)\\) is solved by using the Newton method.</p>"},{"location":"Library/Material/Material1D/Hysteresis/BoucWen/#syntax","title":"Syntax","text":"Text Only<pre><code>material BoucWen (1) (2) (3) (4) (5) (6)\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, yield stress\n# (4) double, hardening ratio\n# (5) double, beta, a positive parameter\n# (6) double, n, a positive exponent\n</code></pre>"},{"location":"Library/Material/Material1D/Hysteresis/BoucWen/#caveat","title":"Caveat","text":"<p>Since it is a phenomenological model, the non-observable internal \"displacement\" \\(\\(z\\)\\) has no physical meaning. For small loops, it violates plasticity postulates.</p> <p>It is recommended to use a value greater than unity for \\(\\(n\\)\\).</p>"},{"location":"Library/Material/Material1D/Hysteresis/BoucWen/#example","title":"Example","text":"Text Only<pre><code>material BoucWen 1 2E5 400 .01 1E-1 2\nmaterialTest1D 1 1E-3 10 20 30 40 50 60 30\n</code></pre> Text Only<pre><code>material BoucWen 1 2E5 400 .01 2. .6\nmaterialTest1D 1 1E-3 10 20 30 40 50 60 30\n</code></pre>"},{"location":"Library/Material/Material1D/Hysteresis/Flag/","title":"Flag","text":"<p>Symmetric/Asymmetric Flag</p> <p>Some self-centering and rocking systems show flag shaped hysteresis behavior. The <code>Flag01</code> model defines a symmetric flag shaped hysteresis rule. The <code>Flag02</code> model is an extension of the <code>Flag01</code> model and defines an asymmetric flag shaped hysteresis rule.</p> <p>More flexible flag shaped hysteresis behavior can be achieved by combining multilinear elastic model with for example bilinear hardening model.</p>"},{"location":"Library/Material/Material1D/Hysteresis/Flag/#syntax","title":"Syntax","text":"Text Only<pre><code>material Flag01 (1) (2) (3) (4) (5)\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, yield stress, positive\n# (4) double, residual stress, can be either positive or negative\n# (5) double, hardening ratio\n\nmaterial Flag02 (1) (2) (3) (4) (5) (6) (7) (8)\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, tension yield stress, positive\n# (4) double, tension residual stress, can be either positive or negative\n# (5) double, tension hardening ratio\n# (6) double, compression yield stress, negative\n# (7) double, compression residual stress, can be either positive or negative\n# (8) double, compression hardening ratio\n</code></pre>"},{"location":"Library/Material/Material1D/Hysteresis/Flag/#history-variable-layout","title":"History Variable Layout","text":"location value <code>initial_history(0)</code> tension_reverse_strain <code>initial_history(1)</code> tension_reverse_low_strain <code>initial_history(2)</code> compression_reverse_strain <code>initial_history(3)</code> compression_reverse_low_strain"},{"location":"Library/Material/Material1D/Hysteresis/Flag/#remarks","title":"Remarks","text":"<ol> <li><code>Flag01</code> is a wrapper of <code>Flag02</code>.</li> <li>If <code>Flag01</code> is used, the compression yield stress and residual stress would be <code>-(3)</code> and <code>-(4)</code> so that the response    would be symmetric.</li> </ol>"},{"location":"Library/Material/Material1D/Hysteresis/Flag/#usage","title":"Usage","text":"Text Only<pre><code>material Flag01 1 1000 10 3 .1\nmaterialTest1D 1 1E-3 20 2 7 5 10 20 10 50 10 5 20 10 12 25 40\nexit\n</code></pre> Text Only<pre><code>material Flag02 1 1000 10 3 .1 -20 -5 -.1\nmaterialTest1D 1 1E-3 20 2 7 5 10 20 10 50 10 5 20 10 12 25 40\nexit\n</code></pre>"},{"location":"Library/Material/Material1D/Hysteresis/MPF/","title":"MPF","text":"<p>Menegotto-Pinto-Filippou Steel Model</p>"},{"location":"Library/Material/Material1D/Hysteresis/MPF/#syntax","title":"Syntax","text":"Text Only<pre><code>material MPF (1) (2) (3) [4] [5] [6] [7] [8] [9] [10] [11] [12]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, initial yield stress\n# [4] double, hardening ratio, default: 0.05\n# [5] double, R0, default: 20.0\n# [6] double, A1, default: 18.5\n# [7] double, A2, default: 0.15\n# [8] double, A3, default: 0.01\n# [9] double, A4, default: 7.0\n# [10] bool string, isotropic hardening switch, default: false\n# [11] bool string, constant radius switch, default: false\n# [12] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material1D/Hysteresis/MPF/#history-variable-layout","title":"History Variable Layout","text":"location value <code>initialize_history(0)</code> reverse_stress <code>initialize_history(1)</code> reverse_strain <code>initialize_history(2)</code> intermediate_stress <code>initialize_history(3)</code> intermediate_strain <code>initialize_history(4)</code> previous_intermediate_strain <code>initialize_history(5)</code> max_strain <code>initialize_history(6)</code> load_sign"},{"location":"Library/Material/Material1D/Hysteresis/MPF/#remarks","title":"Remarks","text":"<ol> <li>The isotropic hardening switch can be turned on to use Filippou's modification.</li> <li>If constant radius switch is on, \\(\\(R=R_0=20.0\\)\\) is unchanged.</li> </ol>"},{"location":"Library/Material/Material1D/Hysteresis/MPF/#example","title":"Example","text":"Text Only<pre><code>material MPF 1 1000 10\nmaterialTest1D 1 0.001 40 40 60 60\n</code></pre>"},{"location":"Library/Material/Material1D/Hysteresis/MultilinearOO/","title":"MultilinearOO","text":"<p>Multilinear Origin Oriented Hysteresis Model</p>"},{"location":"Library/Material/Material1D/Hysteresis/MultilinearOO/#syntax","title":"Syntax","text":"Text Only<pre><code>material MultilinearOO (1) (2) (3) [4]\n# (1) int, unique material tag\n# (2) string, file name of tension backbone\n# (3) string, file name of compression backbone\n# [4] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material1D/Hysteresis/MultilinearOO/#history-variable-layout","title":"History Variable Layout","text":"<p>Since it is derived from the <code>SimpleHysteresis</code> model, they share the same history variable layout.</p>"},{"location":"Library/Material/Material1D/Hysteresis/MultilinearOO/#remarks","title":"Remarks","text":"<ol> <li>The backbone file must have exact two columns, stores turning points of the backbone.</li> <li>The origin does not need to be included.</li> <li>Tension backbone shall be positive.</li> <li>Compression backbone shall be negative, positive table will be converted to negative.</li> <li>If strain exceeds the last point, the last stress will be returned.</li> </ol>"},{"location":"Library/Material/Material1D/Hysteresis/MultilinearOO/#examples","title":"Examples","text":"<p>Backbone is stored in file <code>Backbone</code>.</p> Text Only<pre><code>.002 30\n.004 50\n.006 60\n.01 50\n.02 40\n</code></pre> Text Only<pre><code>material MultilinearOO 1 Backbone Backbone\nmaterialTest1D 1 1E-4 200 400\n</code></pre> <p></p>"},{"location":"Library/Material/Material1D/Hysteresis/MultilinearPO/","title":"MultilinearPO","text":"<p>Multilinear Peak Oriented Hysteresis Model</p>"},{"location":"Library/Material/Material1D/Hysteresis/MultilinearPO/#syntax","title":"Syntax","text":"Text Only<pre><code>material MultilinearPO (1) (2) (3) [4]\n# (1) int, unique material tag\n# (2) string, file name of tension backbone\n# (3) string, file name of compression backbone\n# [4] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material1D/Hysteresis/MultilinearPO/#history-variable-layout","title":"History Variable Layout","text":"<p>Since it is derived from the <code>SimpleHysteresis</code> model, they share the same history variable layout.</p>"},{"location":"Library/Material/Material1D/Hysteresis/MultilinearPO/#remarks","title":"Remarks","text":"<ol> <li>The backbone file must have exact two columns, stores turning points of the backbone.</li> <li>The origin does not need to be included.</li> <li>Tension backbone shall be positive.</li> <li>Compression backbone shall be negative, positive table will be converted to negative.</li> <li>If strain exceeds the last point, the last stress will be returned.</li> </ol>"},{"location":"Library/Material/Material1D/Hysteresis/MultilinearPO/#examples","title":"Examples","text":"<p>Backbone is stored in file <code>Backbone</code>.</p> Text Only<pre><code>.002 30\n.004 50\n.006 60\n.01 50\n.02 40\n</code></pre> Text Only<pre><code>material MultilinearPO 1 Backbone Backbone\nmaterialTest1D 1 1E-4 200 400\n</code></pre> <p></p>"},{"location":"Library/Material/Material1D/Hysteresis/RambergOsgood/","title":"RambergOsgood","text":"<p>Ramberg-Osgood Steel Model</p>"},{"location":"Library/Material/Material1D/Hysteresis/RambergOsgood/#syntax","title":"Syntax","text":"Text Only<pre><code>material RambergOsgood (1) (2) (3) [4] [5] [6]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, initial yield stress\n# [4] double, offset alpha, default: 1.0\n# [5] double, n, default: 4.0\n# [6] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material1D/Hysteresis/RambergOsgood/#history-variable-layout","title":"History Variable Layout","text":"location value <code>initialize_history(0)</code> load_sign <code>initialize_history(1)</code> reverse_strain <code>initialize_history(2)</code> reverse_stress <code>initialize_history(3)</code> previous_reverse_strain <code>initialize_history(4)</code> previous_reverse_stress"},{"location":"Library/Material/Material1D/Hysteresis/RambergOsgood/#remarks","title":"Remarks","text":"<ol> <li>Local iterations are required to obtain the stress value.</li> </ol>"},{"location":"Library/Material/Material1D/Hysteresis/RambergOsgood/#theory","title":"Theory","text":"<p>The Ramberg-Osgood relationship is defined as</p> \\[ \\varepsilon=\\dfrac{\\sigma}{E}+\\alpha\\dfrac{\\sigma}{E}(\\dfrac{\\sigma}{\\sigma_0})^{n-1} \\] <p>where \\(\\(\\alpha\\)\\) is the offset and \\(\\(n\\)\\) is the material constant controls hardening. Noting that \\(\\(\\varepsilon=\\varepsilon_e+\\varepsilon_p=\\dfrac{\\sigma}{E}+\\varepsilon_p\\)\\), hence</p> \\[ \\dfrac{\\sigma}{E}+\\varepsilon_p=\\dfrac{\\sigma}{E}+\\alpha\\dfrac{\\sigma}{E}(\\dfrac{\\sigma}{\\sigma_0})^{n-1} \\] <p>so</p> \\[ \\varepsilon_p=\\alpha\\dfrac{\\sigma}{E}(\\dfrac{\\sigma}{\\sigma_0})^{n-1}. \\] <p>At the yield stress, viz., \\(\\(\\sigma=\\sigma_0\\)\\), then</p> \\[ \\varepsilon_p=\\alpha\\varepsilon_e. \\] <p>So the offset \\(\\(\\alpha\\)\\) indicates the magnitude of plastic strain at yield stress.</p> <p>The cyclic response uses the difference between current reverse stress and previous reverse stress as \"yield stress\".</p>"},{"location":"Library/Material/Material1D/Hysteresis/RambergOsgood/#examples","title":"Examples","text":"Text Only<pre><code>material RambergOsgood 1 100.0 8.0 1 10.0\nmaterialTest1D 1 1E-2 20 20 30 20 30 20 30 20 30 20 30 20\nexit\n</code></pre> Text Only<pre><code>material RambergOsgood 1 100.0 8.0 1 10.0\nmaterialTest1D 1 1E-2 20 40 40 40 40 40 40\nexit\n</code></pre> Text Only<pre><code>material RambergOsgood 1 100.0 8.0 1 10.0\nmaterialTest1D 1 1E-2 20 20 30 15 20 40 15 25 15 20 30\nexit\n</code></pre>"},{"location":"Library/Material/Material1D/Hysteresis/SimpleHysteresis/","title":"SimpleHysteresis","text":"<p>The <code>SimpleHysteresis</code> model is a simplified framework for defining arbitrary backbones with linear unloading/reloading behaviour. The residual strain can be customised according to the specific rules.</p>"},{"location":"Library/Material/Material1D/Hysteresis/SimpleHysteresis/#history-variable-layout","title":"History Variable Layout","text":"location value <code>initial_history(0)</code> maximum compression strain <code>initial_history(1)</code> maximum tension strain <code>initial_history(2)</code> last compression unloading strain <code>initial_history(3)</code> last compression unloading stress <code>initial_history(4)</code> last tension unloading strain <code>initial_history(5)</code> last tension unloading stress <code>initial_history(6)</code> residual compression strain <code>initial_history(7)</code> residual tension strain"},{"location":"Library/Material/Material1D/Hysteresis/SlipLock/","title":"SlipLock","text":"<p>Slip-Lock Material</p> <p>This model describes a slip-lock material model. It is a nonlinear elastic model, the initial stiffness is small, with the increasing strain/displacement, the stiffness becomes larger. The upper bound can be customized.</p>"},{"location":"Library/Material/Material1D/Hysteresis/SlipLock/#syntax","title":"Syntax","text":"Text Only<pre><code>material SlipLock (1) (2) (3) (4) [5] [6]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, initial yield strain\n# (4) double, hardening ratio\n# [5] double, radius, default: 20.0\n# [6] double, density, default: 0\n</code></pre>"},{"location":"Library/Material/Material1D/Hysteresis/SlipLock/#example","title":"Example","text":"Text Only<pre><code>material SlipLock 1 100 1E-2 10 10\nmaterialTest1D 1 1E-4 200\n</code></pre>"},{"location":"Library/Material/Material1D/Hysteresis/SteelBRB/","title":"SteelBRB","text":"<p>Steel Model For Modelling BRB</p> <p>The <code>SteelBRB</code> material defines a steel model. It can be used to model buckling restrained braces. It uses exponential type functions thus resembles the <code>RambergOsgood</code> material.</p> <p>References are available:</p> <ol> <li>https://doi.org/10.1016/j.jcsr.2011.07.017</li> <li>https://doi.org/10.1016/j.jcsr.2014.02.009</li> </ol>"},{"location":"Library/Material/Material1D/Hysteresis/SteelBRB/#syntax","title":"Syntax","text":"<p>If tension response is identical to compression response, users can use the following command to define the material.</p> Text Only<pre><code>material SteelBRB (1) (2) (3) (4) (5) (6) (7) [8]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, yield stress\n# (4) double, plastic modulus\n# (5) double, saturated stress, \\sigma_s\n# (6) double, \\delta_r\n# (7) double, \\alpha\n# [8] double, density, default: 0.0\n</code></pre> <p>If tension response is different from compression response, which is often the case in modelling BRB, users can use the following command.</p> Text Only<pre><code>material SteelBRB (1) (2) (3) (4) (5) (6) (7) (8) (9) (10) [11]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, yield stress\n# (4) double, plastic modulus\n# (5) double, tension saturated stress\n# (6) double, tension delta_r\n# (7) double, tension alpha\n# (8) double, compression saturated stress\n# (9) double, compression delta_r\n# (10) double, compression alpha\n# [11] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material1D/Hysteresis/SteelBRB/#remarks","title":"Remarks","text":"<ol> <li>In the original model, a linear response is defined before the initial yield stress, this feature is disabled. Thus,    the monotonic loading response is similar to that of the <code>RambergOsgood</code> material.</li> <li>In the original model, the elastic and plastic moduli could be different under tension and compression. The    implemented model uses identical values for these two parameters.</li> </ol>"},{"location":"Library/Material/Material1D/Hysteresis/SteelBRB/#history-variable-layout","title":"History Variable Layout","text":"location value <code>initial_history(0)</code> accumulated plastic strain <code>initial_history(1)</code> plastic strain"},{"location":"Library/Material/Material1D/Hysteresis/SteelBRB/#theory","title":"Theory","text":"<p>The model is described in incremental form. The total strain increment is decomposed into elastic and plastic part,</p> \\[ \\dot\\sigma=E(\\dot\\varepsilon-\\dot\\varepsilon_p). \\] <p>For loading, the increment of plastic strain is defined as an implicit function, that is</p> \\[ \\dot\\varepsilon_p=\\Big|\\dfrac{\\sigma-\\sigma_p}{\\sigma_y}\\Big|^\\alpha\\dot\\varepsilon, \\] <p>in which \\(\\(\\sigma_p\\)\\) is associated with \\(\\(\\varepsilon_p\\)\\) via plastic modulus \\(\\(H\\)\\),</p> \\[ \\sigma_p=H\\varepsilon_p, \\] <p>and</p> \\[ \\sigma_y=\\sigma_s-(\\sigma_s-\\sigma_y)\\exp(-\\dfrac{\\mu}{\\delta_r}) \\] <p>where \\(\\(\\sigma_r\\)\\) is the saturated stress, \\(\\(\\sigma_y\\)\\) is the yield stress, \\(\\(\\delta_r\\)\\) is a constant parameter that controls the speed of isotropic hardening, \\(\\(\\mu\\)\\) is the accumulated plastic strain which is defined to be</p> \\[ \\dot\\mu=|\\dot\\varepsilon_p|. \\] <p>In the above formulation, \\(\\(\\sigma_s\\)\\), \\(\\(\\alpha\\)\\) and \\(\\(\\delta_r\\)\\) could be different in tension and compression.</p> <p>The development of plastic strain \\(\\(\\varepsilon_p\\)\\) is activated when</p> \\[ \\dot\\varepsilon\\sigma&lt;0 \\]"},{"location":"Library/Material/Material1D/Hysteresis/SteelBRB/#example","title":"Example","text":"Text Only<pre><code>material SteelBRB 1 2E5 400. 2E3 660. .2 .6 450. .15 .4\nmaterialTest1D 1 1E-4 40 80 120 160 200 240 280 320 360 400 400\n</code></pre>"},{"location":"Library/Material/Material1D/Hysteresis/Trivial/","title":"Trivial","text":"<p>Zero Response Material</p> <p>The <code>Trivial</code> material defines 1D zero response. The stress and stiffness outputs will be zero for all strain inputs.</p>"},{"location":"Library/Material/Material1D/Hysteresis/Trivial/#syntax","title":"Syntax","text":"Text Only<pre><code>material Trivial (1)\n# (1) int, unique material tag\n</code></pre>"},{"location":"Library/Material/Material1D/Viscosity/BilinearViscosity/","title":"BilinearViscosity","text":"<p>Viscous Material Using Bilinear Model</p> <p>Reference:</p> <ol> <li>10.1016/j.soildyn.2018.06.021</li> </ol>"},{"location":"Library/Material/Material1D/Viscosity/BilinearViscosity/#syntax","title":"Syntax","text":"Text Only<pre><code>material BilinearViscosity (1) (2) (3) [4]\n# (1) int, unique material tag\n# (2) double, damping coefficient\n# (3) double, yield stress\n# [4] double, hardening ratio, default: 0\n</code></pre>"},{"location":"Library/Material/Material1D/Viscosity/CoulombFriction/","title":"CoulombFriction","text":"<p>The <code>CoulombFriction</code> is a 1D viscous material that shall be used with for example <code>Damper01</code> element.</p>"},{"location":"Library/Material/Material1D/Viscosity/CoulombFriction/#syntax","title":"Syntax","text":"Text Only<pre><code>material CoulombFriction (1) (2) (3)\n# (1) int, unique material tag\n# (2) double, C\n# (3) double, alpha\n</code></pre>"},{"location":"Library/Material/Material1D/Viscosity/CoulombFriction/#theory","title":"Theory","text":"<p>The stress is constant as long as the velocity is not zero.</p> \\[ \\sigma=C\\cdot\\text{sign}\\left(\\dot\\varepsilon\\right)\\qquad\\text{if~}\\dot\\varepsilon\\neq0. \\] <p>In order to avoid discontinuity, the sigmoid function is used.</p> \\[ \\sigma=\\dfrac{2C}{\\pi}\\cdot\\arctan\\left(\\alpha\\cdot\\dot\\varepsilon\\right). \\] <p>The factor \\(\\(\\alpha\\)\\) is used to control the steepness of the transition region.</p>"},{"location":"Library/Material/Material1D/Viscosity/CustomViscosity/","title":"CustomViscosity","text":"<p>Viscous Material Using Custom Model</p> <p>Reference:</p> <ol> <li>10.1016/j.ymssp.2021.108795</li> </ol>"},{"location":"Library/Material/Material1D/Viscosity/CustomViscosity/#syntax","title":"Syntax","text":"Text Only<pre><code>material CustomViscosity (1) (2)\n# (1) int, unique material tag\n# (2) int, expression tag\n</code></pre>"},{"location":"Library/Material/Material1D/Viscosity/CustomViscosity/#remarks","title":"Remarks","text":"<p>The expression needed takes strain and strain rate as the inputs and returns the damping coefficient and its derivatives as the outputs.</p> <p>The input size shall be 2 and the output size shall be 3.</p>"},{"location":"Library/Material/Material1D/Viscosity/CustomViscosity/#example","title":"Example","text":"<p>Imaging to model the linear viscous material such that</p> \\[ \\sigma=1234\\dot{\\epsilon}, \\] <p>One can define the expression as</p> Text Only<pre><code>expression SimpleVector 1 x|2 y|3 y[0]:=1234*x[1];y[1]:=0;y[2]:=1234;\n</code></pre> <p>The strain maps to <code>x[0]</code> and the strain rate maps to <code>x[1]</code>.</p> <p>The stress output maps to <code>y[0]</code> and its derivatives regarding strain and strain rate maps to <code>y[1]</code> and <code>y[2]</code> respectively.</p>"},{"location":"Library/Material/Material1D/Viscosity/Kelvin/","title":"Kelvin","text":"<p>Kelvin Model</p> <p>The <code>Kelvin</code> model represents a dashpot and a spring in parallel. This material model does respond to both displacement and velocity.</p>"},{"location":"Library/Material/Material1D/Viscosity/Kelvin/#syntax","title":"Syntax","text":"Text Only<pre><code>material Kelvin (1) (2) (3)\n# (1) int, unique material tag\n# (2) int, damper tag\n# (3) int, spring tag\n</code></pre>"},{"location":"Library/Material/Material1D/Viscosity/Kelvin/#remarks","title":"Remarks","text":"<ol> <li>Elements that pass both strain and strain rate to material models shall be used.</li> </ol>"},{"location":"Library/Material/Material1D/Viscosity/Maxwell/","title":"Maxwell","text":"<p>Maxwell Model Using An Iterative Solving Algorithm</p> <p>This material model does respond to both displacement and velocity.</p>"},{"location":"Library/Material/Material1D/Viscosity/Maxwell/#reference","title":"Reference","text":"<ol> <li>10.1016/j.ymssp.2021.108795</li> </ol>"},{"location":"Library/Material/Material1D/Viscosity/Maxwell/#syntax","title":"Syntax","text":"Text Only<pre><code>material Maxwell (1) (2) (3) [4] [5] [6]\n# (1) int, unique tag\n# (2) int, damper tag\n# (3) int, spring tag\n# [4] bool string, if to use matrix formulation, default: false\n# [5] int, the maximum unconverged substep allowed, default: 1\n# [6] double, local time integration parameter, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material1D/Viscosity/Maxwell/#remarks","title":"Remarks","text":"<ol> <li>When <code>[4]</code> is set to true, the matrix formulation is used, that is, a 3-by-3 matrix is used in local iterations.    However, the inverse of the Jacobian is not computed numerically, but analytically. When it is set to false, the    scalar iteration is performed. In general, a scalar algorithm requires fewer floating number operations but may be    less numerically stable.</li> <li>The parameter <code>[5]</code> can be set to a nonzero positive integer to allow some unconverged substeps to be accumulated to    avoid sharp transition regions that may cause numerical issues. As the result, the response may not be as smooth as    other regions.</li> <li>The parameter <code>[6]</code> is used to control how local strain is integrated. A value of \\(\\(0.0\\)\\) indicates it would be    automatically computed based on the input strain and strain rate increments. A value of \\(\\(0.5\\)\\) indicates a linear    distribution of spring strain over time.</li> </ol>"},{"location":"Library/Material/Material1D/Viscosity/NonlinearViscosity/","title":"NonlinearViscosity","text":"<p>Nonlinear Viscosity Model</p> <p>The <code>NonlinearViscosity</code> class is an abstract class that provides a general nonlinear framework for implementations of various viscous type material, such as a dashpot.</p> <p>The stress shall be computed by</p> \\[ \\sigma=\\text{sign}\\left(\\dot\\varepsilon\\right)\\cdot\\eta\\left(\\varepsilon,\\dot\\varepsilon\\right) \\cdot|\\dot\\varepsilon|^\\alpha. \\] <p>The so-called viscosity \\(\\(\\eta\\left(\\varepsilon,\\dot\\varepsilon\\right)\\)\\) can be a general function of strain and/or strain rate.</p> <p>If the target material is not characterized by the classic power-law, it is possible to pass \\(\\(\\alpha=0\\)\\) to the <code>NonlinearViscosity</code> class so that the response becomes</p> \\[ \\sigma=\\eta\\left(\\varepsilon,\\dot\\varepsilon\\right) \\] <p>that can be purely determined by the derived class.</p>"},{"location":"Library/Material/Material1D/Viscosity/NonlinearViscosity/#things-to-pass-to-ctor","title":"Things to Pass to Ctor","text":"<p>The default constructor is defined to be</p> C++<pre><code> NonlinearViscosity(unsigned, // tag\ndouble,   // alpha\ndouble    // cut-off\n);\n</code></pre> <p>The second parameter is the exponent \\(\\(\\alpha\\)\\). The third parameter is a non-negative parameter that defines a segment of cubic function that approximates the original exponential function to achieve a better numerical performance.</p>"},{"location":"Library/Material/Material1D/Viscosity/NonlinearViscosity/#things-to-override","title":"Things to Override","text":"<p>Three private methods need to be overridden.</p> C++<pre><code> [[nodiscard]] virtual double compute_du(double, double) const = 0; // compute derivative w.r.t. strain\n[[nodiscard]] virtual double compute_dv(double, double) const = 0; // compute derivative w.r.t. strain rate\n[[nodiscard]] virtual double compute_damping_coefficient(double, double) const = 0; // compute \\eta\n</code></pre> <p>All three methods take strain and strain rate to be two input arguments.</p>"},{"location":"Library/Material/Material1D/Viscosity/NonlinearViscosity/#derived-material-models","title":"Derived Material Models","text":"<ol> <li><code>Viscosity01</code></li> <li><code>Viscosity02</code></li> </ol>"},{"location":"Library/Material/Material1D/Viscosity/Viscosity01/","title":"Viscosity01","text":"<p>Viscous Damper</p> <p>The damping force is defined as a function of velocity (or strain rate, depends on what the input is). This material model does not respond to strain/displacement. To represent materials that respond to both displacement and velocity, see <code>Maxwell</code> and <code>Kelvin</code>.</p> <p>See this example.</p> <p>See also damper elements <code>Damper01</code> and <code>Damper02</code>.</p> \\[ \\sigma=\\text{sign}(\\dot\\varepsilon)~\\eta~|\\dot\\varepsilon|^\\alpha. \\] <p>The damping coefficient is constant.</p>"},{"location":"Library/Material/Material1D/Viscosity/Viscosity01/#syntax","title":"Syntax","text":"Text Only<pre><code>material Viscosity01 (1) (2) (3)\n# (1) int, unique tag\n# (2) double, alpha\n# (3) double, damping coefficient\n</code></pre>"},{"location":"Library/Material/Material1D/Viscosity/Viscosity02/","title":"Viscosity02","text":"<p>Viscous Damper</p> <p>This material model does not respond to strain/displacement. To represent materials that respond to both displacement and velocity, see <code>Maxwell</code> and <code>Kelvin</code>.</p> <p>See also damper elements <code>Damper01</code> and <code>Damper02</code>.</p>"},{"location":"Library/Material/Material1D/Viscosity/Viscosity02/#reference","title":"Reference","text":"<ol> <li>10.1016/j.ymssp.2021.108795</li> </ol>"},{"location":"Library/Material/Material1D/Viscosity/Viscosity02/#theory","title":"Theory","text":"<p>The quadrant damper is implemented.</p> <p>The damping force is defined as a function of displacement and velocity (or strain and strain rate, depends on what the input is).</p> \\[ \\sigma=\\text{sign}(\\dot\\varepsilon)~\\eta(\\varepsilon,\\dot\\varepsilon)~|\\dot\\varepsilon|^\\alpha. \\] <p>The damping coefficient is a function of strain and strain rate that can be expressed as follows, which shows different response in different quadrants.</p> \\[ \\begin{align*} \\eta\\left(\\varepsilon,\\dot\\varepsilon\\right) &amp;=\\dfrac{\\eta_1+\\eta_2+\\eta_3+\\eta_4}{4}+\\dfrac{\\eta_1-\\eta_2+\\eta_3-\\eta_4}{\\pi^2}\\arctan\\left(g_1\\varepsilon\\right) \\arctan\\left(g_2\\dot\\varepsilon\\right)\\\\[4mm]&amp;+\\dfrac{\\eta_1-\\eta_2-\\eta_3+\\eta_4}{2\\pi}\\arctan\\left( g_1\\varepsilon\\right)+\\dfrac{\\eta_1+\\eta_2-\\eta_3-\\eta_4}{2\\pi}\\arctan\\left(g_2\\dot\\varepsilon\\right). \\end{align*} \\]"},{"location":"Library/Material/Material1D/Viscosity/Viscosity02/#syntax","title":"Syntax","text":"Text Only<pre><code>material Viscosity02 (1) (2) (3) [4] [5] [6] [7] [8]\n# (1) int, unique tag\n# (2) double, alpha\n# (3) double, damping coefficient \\eta_1\n# [4] double, damping coefficient \\eta_2, default: (3)\n# [5] double, damping coefficient \\eta_3, default: (3)\n# [6] double, damping coefficient \\eta_4, default: (3)\n# [7] double, steepness factor g_1, default: 1E3\n# [8] double, steepness factor g_2, default: 1E3\n</code></pre>"},{"location":"Library/Material/Material1D/vonMises/ArmstrongFrederick1D/","title":"ArmstrongFrederick1D","text":"<p>1D Armstrong-Frederick Steel Model</p> <p>This model is a uni-axial version of the <code>ArmstrongFrederick</code> steel model. Readers can also refer to the corresponding section in Constitutive Modelling Cookbook for details on the theory.</p>"},{"location":"Library/Material/Material1D/vonMises/ArmstrongFrederick1D/#theory","title":"Theory","text":"<p>A von Mises type yield function is used. The associated plasticity is assumed. Both isotropic and kinematic hardening rules are employed.</p>"},{"location":"Library/Material/Material1D/vonMises/ArmstrongFrederick1D/#isotropic-hardening","title":"Isotropic Hardening","text":"<p>An exponential function is added to the linear hardening law.</p> \\[ k=\\sigma_y+k_s(1-e^{-mp})+k_lp, \\] <p>where \\(\\(\\sigma_y\\)\\) is the initial elastic limit (yielding stress), \\(\\(k_s\\)\\) is the saturated stress, \\(\\(k_l\\)\\) is the linear hardening modulus, \\(\\(m\\)\\) is a constant that controls the speed of hardening, \\(\\(\\mathrm{d}p=\\Big|\\mathrm{d}\\varepsilon^p\\Big|\\)\\) is the rate of accumulated plastic strain \\(\\(p\\)\\).</p>"},{"location":"Library/Material/Material1D/vonMises/ArmstrongFrederick1D/#kinematic-hardening","title":"Kinematic Hardening","text":"<p>The Armstrong-Frederick type rule is used. Multiple back stresses are defined,</p> \\[ \\beta=\\sum\\beta^i \\] <p>in which</p> \\[ \\mathrm{d}\\beta^i=a^i~\\mathrm{d}\\varepsilon^p-b^i\\beta~\\mathrm{d}p, \\] <p>where \\(\\(a^i\\)\\) and \\(\\(b^i\\)\\) are material constants.</p>"},{"location":"Library/Material/Material1D/vonMises/ArmstrongFrederick1D/#syntax","title":"Syntax","text":"Text Only<pre><code>material ArmstrongFrederick1D (1) (2) (3) (4) (5) (6) [(7) (8)...] [9]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, yield stress\n# (4) double, saturated stress\n# (5) double, linear hardening modulus\n# (6) double, m\n# (7) double, a\n# (8) double, b\n# [9] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material1D/vonMises/ArmstrongFrederick1D/#example","title":"Example","text":""},{"location":"Library/Material/Material1D/vonMises/ArmstrongFrederick1D/#kinematic-hardening-only-with-no-elastic-range","title":"Kinematic Hardening Only With No Elastic Range","text":"Text Only<pre><code>material ArmstrongFrederick1D 1 2E2 0. 0. 0. 0. 50 500.\n</code></pre> <p>The maximum stress can be computed as</p> \\[ \\sigma_{max}=\\sigma_y+\\sum\\dfrac{a^i}{b^i}=100~\\mathrm{MPa}. \\] <p></p>"},{"location":"Library/Material/Material1D/vonMises/Bilinear1D/","title":"Bilinear1D","text":"<p>Uniaxial Bilinear Material Using J2 Plasticity</p>"},{"location":"Library/Material/Material1D/vonMises/Bilinear1D/#syntax","title":"Syntax","text":"Text Only<pre><code>material Bilinear1D (1) (2) (3) [4] [5] [6]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, initial yield stress\n# [4] double, hardening ratio, default: 0.0\n# [5] double, beta, default: 1.0\n# [6] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material1D/vonMises/Bilinear1D/#history-variable-layout","title":"History Variable Layout","text":"location value <code>initialize_history(0)</code> back_stress <code>initialize_history(1)</code> equivalent_plastic_strain"},{"location":"Library/Material/Material1D/vonMises/Bilinear1D/#remarks","title":"Remarks","text":"<ol> <li>The parameter <code>beta</code> is employed for mixed hardening rule: zero \\(\\(0.0\\)\\) for kinematic hardening and unity \\(\\(1.0\\)\\) for    isotropic hardening, anything falls in the range indicates a mixed hardening response.</li> <li>Negative hardening ratio (softening) is supported. However, the yield surface will always be non-negative.</li> </ol>"},{"location":"Library/Material/Material1D/vonMises/Bilinear1D/#usage","title":"Usage","text":""},{"location":"Library/Material/Material1D/vonMises/Bilinear1D/#isotropic-hardening","title":"Isotropic Hardening","text":"Text Only<pre><code>material Bilinear1D 1 1000.0 10.0 0.2 1.0\nmaterialTest1D 1 0.001 20 40 60 80 100 100\nexit\n</code></pre>"},{"location":"Library/Material/Material1D/vonMises/Bilinear1D/#isotropic-softening","title":"Isotropic Softening","text":"Text Only<pre><code>material Bilinear1D 1 1000.0 10.0 -0.02 1.0\nmaterialTest1D 1 0.001 20 40 60 80 100 100\nexit\n</code></pre>"},{"location":"Library/Material/Material1D/vonMises/Bilinear1D/#kinematic-hardening","title":"Kinematic Hardening","text":"Text Only<pre><code>material Bilinear1D 1 1000.0 10.0 0.1 0.0\nmaterialTest1D 1 0.001 20 40 60 80 100 100\nexit\n</code></pre>"},{"location":"Library/Material/Material1D/vonMises/Bilinear1D/#combined-hardening","title":"Combined Hardening","text":"Text Only<pre><code>material Bilinear1D 1 1000.0 10.0 0.1 0.5\nmaterialTest1D 1 0.001 20 40 60 80 100 100\nexit\n</code></pre>"},{"location":"Library/Material/Material1D/vonMises/BilinearMises1D/","title":"BilinearMises1D","text":"<p>Bilinear J2 Plasticity Model</p>"},{"location":"Library/Material/Material1D/vonMises/BilinearMises1D/#theory","title":"Theory","text":"<p>This model is an implementation of the <code>Mises1D</code> abstract model.</p> <p>Only isotropic hardening is defined. The kinematic hardening is set to zero.</p>"},{"location":"Library/Material/Material1D/vonMises/BilinearMises1D/#syntax","title":"Syntax","text":"Text Only<pre><code>material BilinearMises1D (1) (2) (3) [4] [5]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, initial yield stress\n# [4] double, hardening ratio, default: 0.0\n# [5] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material1D/vonMises/BilinearMises1D/#usage","title":"Usage","text":"<p>Please refer to the <code>Bilinear1D</code> model.</p>"},{"location":"Library/Material/Material1D/vonMises/CustomGurson1D/","title":"CustomGurson1D","text":""},{"location":"Library/Material/Material1D/vonMises/CustomGurson1D/#syntax","title":"Syntax","text":"Text Only<pre><code>material CustomGurson1D (1) (2) (3) (4) [5] [6] [7] [8] [9] [10]\n# (1) int, unique material tag\n# (2) int, expression tag\n# (3) double, elastic modulus\n# (4) double, poissons ratio\n# [5] double, q1, default: 1.0\n# [6] double, q2, default: 1.0\n# [7] double, fn, default: 0.0\n# [8] double, sn, default: 1.0\n# [9] double, en, default: 0.0\n# [10] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material1D/vonMises/CustomMises1D/","title":"CustomMises1D","text":"<p>J2 Plasticity Model With Custom Hardening</p>"},{"location":"Library/Material/Material1D/vonMises/CustomMises1D/#theory","title":"Theory","text":"<p>This model is an implementation of the <code>Mises1D</code> abstract model.</p>"},{"location":"Library/Material/Material1D/vonMises/CustomMises1D/#syntax","title":"Syntax","text":"Text Only<pre><code>material CustomMises1D (1) (2) (3) (4) [5]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) int, isotropic hardening expression tag\n# (4) int, kinematic hardening expression tag\n# [5] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material1D/vonMises/CustomMises1D/#usage","title":"Usage","text":"<p>Both the isotropic and kinematic hardening functions are provided by Expression objects.</p> <p>Both hardening functions shall be defined in terms of the equivalent plastic strain.</p> <p>The isotropic hardening function evaluates to the yield stress for trivial equivalent plastic strain.</p> <p>The expressions shall be able to compute derivatives.</p>"},{"location":"Library/Material/Material1D/vonMises/CustomMises1D/#example","title":"Example","text":""},{"location":"Library/Material/Material1D/vonMises/CustomMises1D/#isotropic-hardening","title":"Isotropic Hardening","text":"<p>For example, one can define a purely isotropic hardening model as follows:</p> Text Only<pre><code>expression SimpleScalar 1 x 10+.5x\nexpression SimpleScalar 2 x 0\n\nmaterial CustomMises1D 1 10 1 2\n\nmaterialTest1D 1 1E-2 150 150 200 200 250\n</code></pre> <p>In the above example, the isotropic hardening function is defined as:</p> \\[ y=10+0.5x, \\] <p>in which \\(\\(x\\)\\) maps to the equivalent plastic strain and \\(\\(y\\)\\) maps to the shifted stress.</p> <p>The kinematic hardening function is defined as:</p> \\[ y=0. \\] <p>For elastic modulus of \\(\\(E=10\\)\\), the isotropic hardening ratio satisfies:</p> \\[ 0.5=E\\dfrac{H}{1-H}, \\] <p>solving which yields \\(\\(H=0.04762\\)\\).</p> <p>The last point is \\(\\(11.190476190476174\\)\\), then</p> \\[ \\dfrac{10.714285714285706-10}{2.5-1}=0.04762E. \\] <p></p>"},{"location":"Library/Material/Material1D/vonMises/CustomMises1D/#kinematic-hardening","title":"Kinematic Hardening","text":"Text Only<pre><code>expression SimpleScalar 1 x 10\nexpression SimpleScalar 2 x .1x\n\nmaterial CustomMises1D 1 10 1 2\nmaterialTest1D 1 1E-2 150 100 150 100 150\n</code></pre> <p>In the above example, purely kinematic hardening is defined.</p> <p>The hardening ratio is \\(\\(0.1/(E+0.1)=0.0099\\)\\).</p> <p>The last point is \\(\\(10.074626865671641\\)\\), then</p> \\[ \\dfrac{10.148514851485146-10}{2.5-1}=0.0099. \\] <p></p> <p>With custom functions, it is possible to define arbitrary hardening rules.</p>"},{"location":"Library/Material/Material1D/vonMises/ExpGurson1D/","title":"ExpGurson1D","text":""},{"location":"Library/Material/Material1D/vonMises/ExpGurson1D/#syntax","title":"Syntax","text":"Text Only<pre><code>material ExpGurson1D (1) (2) (3) (4) (5) [6] [7] [8] [9] [10] [11]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, poissons ratio\n# (4) double, yield stress\n# (5) double, n\n# [6] double, q1, default: 1.0\n# [7] double, q2, default: 1.0\n# [8] double, fn, default: 0.0\n# [9] double, sn, default: 1.0\n# [10] double, en, default: 0.0\n# [11] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material1D/vonMises/ExpMises1D/","title":"ExpMises1D","text":"<p>Exponential Isotropic Hardening Model</p> <p>The kinematic hardening is not defined in this model.</p>"},{"location":"Library/Material/Material1D/vonMises/ExpMises1D/#theory","title":"Theory","text":"<p>The isotropic hardening backbone function is defined as</p> \\[ \\sigma=\\sigma_y+a-ae^{-b\\varepsilon_p}+cE\\varepsilon_p, \\] <p>where \\(\\(a\\)\\), \\(\\(b\\)\\) and \\(\\(c\\)\\) are three constants that control the shape of the backbone. The stiffness at the beginning of yielding is \\(\\(\\sigma'|_ {\\varepsilon_p=0}=ab+cE\\)\\).</p>"},{"location":"Library/Material/Material1D/vonMises/ExpMises1D/#syntax","title":"Syntax","text":"Text Only<pre><code>material ExpMises1D (1) (2) (3) (4) (5) (6) [7]\n# (1) int, unique tag\n# (2) double, elastic modulus\n# (3) double, yield stress\n# (4) double, a\n# (5) double, b\n# (6) double, c\n# [7] double, density, default: 0\n</code></pre>"},{"location":"Library/Material/Material1D/vonMises/Mises1D/","title":"Mises1D","text":"<p>Uniaxial General Model Using von Mises Criterion</p> <p>This is an abstract class that shall be overridden.</p> <p>The <code>Mises1D</code> is a general model using von Mises yielding criterion and associated flow rule. The hardening rules can be customized.</p>"},{"location":"Library/Material/Material1D/vonMises/Mises1D/#theory","title":"Theory","text":""},{"location":"Library/Material/Material1D/vonMises/Mises1D/#yield-function","title":"Yield Function","text":"<p>A von Mises type yield function is used.</p> \\[ F=|\\sigma-\\beta|-k \\]"},{"location":"Library/Material/Material1D/vonMises/Mises1D/#flow-rule","title":"Flow Rule","text":"<p>The associated plasticity is assumed.</p> \\[ \\mathrm{d}\\varepsilon^p=\\gamma\\dfrac{\\partial{}F}{\\partial\\sigma}=\\text{sign}(\\sigma-\\beta)~\\gamma \\]"},{"location":"Library/Material/Material1D/vonMises/Mises1D/#hardening","title":"Hardening","text":"<p>Both isotropic and kinematic hardening rules are employed.</p>"},{"location":"Library/Material/Material1D/vonMises/Mises1D/#isotropic-hardening","title":"Isotropic Hardening","text":"<p>A general function of accumulated plastic strain \\(\\(p\\)\\) needs to be defined.</p> \\[ k=k(p), \\] <p>where \\(\\(p=\\displaystyle\\int|\\mathrm{d}\\varepsilon^p|~\\mathrm{d}t\\)\\) is the accumulated plastic strain.</p>"},{"location":"Library/Material/Material1D/vonMises/Mises1D/#kinematic-hardening","title":"Kinematic Hardening","text":"<p>A general function of accumulated plastic strain \\(\\(p\\)\\) needs to be defined.</p> \\[ \\beta=h(p). \\]"},{"location":"Library/Material/Material1D/vonMises/Mises1D/#implementation","title":"Implementation","text":"<p>The function \\(\\(k(p)\\)\\) and \\(\\(h(p)\\)\\) need to be defined in the derived classes.</p>"},{"location":"Library/Material/Material1D/vonMises/Multilinear1D/","title":"Multilinear1D","text":"<p>Uniaxial Multilinear Material Using J2 Plasticity</p>"},{"location":"Library/Material/Material1D/vonMises/Multilinear1D/#syntax","title":"Syntax","text":"Text Only<pre><code>material Multilinear1D (1) (2) (3) (4 5...)\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, density\n# (4 5...) double, pairs of stress and plastic strain\n</code></pre>"},{"location":"Library/Material/Material1D/vonMises/Multilinear1D/#remarks","title":"Remarks","text":"<ol> <li>No kinematic hardening is defined in this model.</li> <li>The stress will be constant after the last point defined. This means the yield surface does not change its size after    the last point. So the stiffness will be singular. This may cause instability issues in analysis.</li> <li>The first plastic strain must be zero.</li> </ol>"},{"location":"Library/Material/Material1D/vonMises/Multilinear1D/#usage","title":"Usage","text":"Text Only<pre><code>material Multilinear1D 1 50000 1. 0. 100 2E-3 120 4E-3 250 1E-2 200\nmaterialTest1D 1 1E-4 120 120\nexit\n</code></pre> <p>The above command defines the backbone using the following data.</p> plastic strain stress 0E0 100 2E-3 120 4E-3 250 1E-2 200 200"},{"location":"Library/Material/Material1D/vonMises/Multilinear1D/#examples","title":"Examples","text":""},{"location":"Library/Material/Material1D/vonMises/NonlinearGurson1D/","title":"NonlinearGurson1D","text":"<p>Uniaxial Nonlinear General Gurson Porous Model</p>"},{"location":"Library/Material/Material1D/vonMises/NonlinearGurson1D/#theory","title":"Theory","text":"<p>The yield function, hardening rule, flow rule are identical to that of the 3D version. Please check the ** NonlinearGurson** model for details.</p> <p>The uniaxial version assumes the stress tensor possesses the following voigt form.</p> \\[ \\sigma=\\begin{bmatrix}\\sigma_1&amp;0&amp;0&amp;0&amp;0&amp;0\\end{bmatrix}, \\] <p>meaning that the elastic strain \\(\\(\\varepsilon^e\\)\\) is always</p> \\[ \\varepsilon^e=\\varepsilon_1^e\\begin{bmatrix}1&amp;-\\nu&amp;-\\nu&amp;0&amp;0&amp;0\\end{bmatrix}, \\] <p>where \\(\\(\\nu\\)\\) is Poisson's ratio.</p>"},{"location":"Library/Material/Material1D/vonMises/VAFCRP1D/","title":"VAFCRP1D","text":"<p>Viscous J2 Steel Model</p> <p>The <code>VAFCRP1D</code> model is the uniaxial version of the <code>VAFCRP</code> model.</p>"},{"location":"Library/Material/Material1D/vonMises/VAFCRP1D/#reference","title":"Reference","text":"<ol> <li>10.1017/S0368393100118759</li> <li>10.1179/096034007X207589</li> <li>10.1016/0749-6419(89)90015-6</li> <li>10.1002/nme.1620360807</li> </ol>"},{"location":"Library/Material/Material1D/vonMises/VAFCRP1D/#theory","title":"Theory","text":"<p>The <code>VAFCRP</code> model is a von Mises J2 yield criterion based model and uses an associative plasticity flow. The yield function is defined as</p> \\[ F=\\Big|\\sigma-\\beta\\Big|-k. \\] <p>So the plastic flow is</p> \\[ \\dot{\\varepsilon}^p=\\gamma\\dfrac{\\partial{}F}{\\partial{}\\sigma}=\\gamma{}n, \\] <p>where \\(\\(n=\\dfrac{\\eta}{\\Big|\\eta\\Big|}=\\dfrac{\\sigma-\\beta}{\\Big|\\sigma-\\beta\\Big|}=\\mathrm{sign}~\\left( \\sigma-\\beta\\right)\\)\\).</p>"},{"location":"Library/Material/Material1D/vonMises/VAFCRP1D/#v","title":"V","text":"<p>The Voce (1955) type isotropic hardening equation is used.</p> \\[ k=\\sigma_y+k_s(1-e^{-mp})+k_lp, \\] <p>where \\(\\(\\sigma_y\\)\\) is the initial elastic limit (yielding stress), \\(\\(k_s\\)\\) is the saturated stress, \\(\\(k_l\\)\\) is the linear hardening modulus, \\(\\(m\\)\\) is a constant that controls the speed of hardening, \\(\\(\\mathrm{d}p=\\Big|\\mathrm{d}\\varepsilon^p\\Big|=\\gamma\\)\\) is the rate of accumulated plastic strain \\(\\(p\\)\\).</p>"},{"location":"Library/Material/Material1D/vonMises/VAFCRP1D/#af","title":"AF","text":"<p>The Armstrong-Frederick (1966) kinematic hardening rule is used. The rate form of back stress \\(\\(\\beta^i\\)\\) is</p> \\[ \\mathrm{d}\\beta^i=a^i~\\mathrm{d}\\varepsilon^p-b^i\\beta~\\mathrm{d}p, \\] <p>where \\(\\(a^i\\)\\) and \\(\\(b^i\\)\\) are material constants.</p>"},{"location":"Library/Material/Material1D/vonMises/VAFCRP1D/#cr","title":"CR","text":"<p>A multiplicative formulation (Chaboche and Rousselier, 1983) is used for the total back stress.</p> \\[ \\beta=\\sum\\beta^i. \\]"},{"location":"Library/Material/Material1D/vonMises/VAFCRP1D/#p","title":"P","text":"<p>The Peric (1993) type definition is used for viscosity.</p> \\[ \\dfrac{\\gamma}{\\Delta{}t}=\\dot{\\gamma}=\\dfrac{1}{\\mu}\\left(\\left(\\dfrac{\\Big|\\eta\\Big|}{k}\\right) ^{\\dfrac{1}{\\epsilon}}-1\\right), \\] <p>where \\(\\(\\mu\\)\\) and \\(\\(\\epsilon\\)\\) are two material constants that controls viscosity. Note either (\\(\\mu\\)\\) or (\\(\\epsilon\\)\\) can be set to zero to disable rate-dependent response, in that case this model is identical to the Armstrong-Frederick model.</p>"},{"location":"Library/Material/Material1D/vonMises/VAFCRP1D/#syntax","title":"Syntax","text":"Text Only<pre><code>material VAFCRP1D (1) (2) (3) (4) (5) (6) (7) (8) [(9) (10)...] [11]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, yield stress\n# (4) double, saturated stress\n# (5) double, linear hardening modulus\n# (6) double, m\n# (7) double, mu\n# (8) double, epsilon\n# (9) double, a\n# (10) double, b\n# [11] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material2D/AxisymmetricELastic/","title":"AxisymmetricElastic","text":"<p>Axisymmetric Elastic Model</p>"},{"location":"Library/Material/Material2D/AxisymmetricELastic/#syntax","title":"Syntax","text":"Text Only<pre><code>material AxisymmetricElastic (1) (2) (3) [4]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, poissons ratio\n# [4] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material2D/Bilinear2D/","title":"Bilinear2D","text":"<p>2D Bilinear Hardening von Mises Model</p>"},{"location":"Library/Material/Material2D/Bilinear2D/#syntax","title":"Syntax","text":"Text Only<pre><code>material Bilinear2D (1) (2) (3) (4) (5) (6) (7)\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, poissons ratio\n# (4) double, yield stress\n# [5] double, hardening ratio, default: 0.0\n# [6] double, beta, default: 1.0\n# [7] int, material type, plane stress = 0, plane strain = 1,, default: 0\n# [8] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material2D/Concrete21/","title":"Concrete21","text":"<p>The <code>Concrete21</code> material model implements the smeared rotating crack model for concrete. In general, it takes in-plane strain vector as the input, converts it into principal strains and calls uniaxial material models to compute uniaxial stress and stiffness response. These ae rotated back to the nominal direction using the same eigen vectors.</p> <p>The underlying uniaxial concrete model used is the <code>ConcreteTsai</code> model.</p>"},{"location":"Library/Material/Material2D/Concrete21/#reference","title":"Reference","text":"<ol> <li>10.1061/(ASCE)0733-9399(1989)115:3(578)</li> </ol>"},{"location":"Library/Material/Material2D/Concrete21/#syntax","title":"Syntax","text":"Text Only<pre><code>material Concrete21 (1) (2) (3) (4) (5) (6) (7) (8) (9) (10) [11]\n# (1) int, unique material tag\n# (2) double, compression strength, should be negative but sign insensitive\n# (3) double, tension strength, should be positive but sign insensitive\n# (4) double, MC\n# (5) double, NC\n# (6) double, MT\n# (7) double, NT\n# (8) double, middle point\n# (9) double, strain at compression strength\n# (10) double, strain at tension strength\n# [11] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material2D/Concrete21/#theory","title":"Theory","text":"<p>The formulation can be interpreted via two approaches. One in pure mathematics style and the other from engineering perspective. Fundamentally, the stress response is an isotropic tensor function of in-plane strain tensor. One can refer to 10.1002/cnm.1640091105 for a more general derivation of stiffness, which eventually gives the same expression as shown in 10.1061/(ASCE)0733-9399(1989)115:3(578).</p> <p>Let \\(\\(\\varepsilon\\)\\) and \\(\\(\\sigma\\)\\) be coaxial in-plane strain and stress tensor. Performing eigen decomposition gives two eigenvalues and eigenvectors.</p> \\[ \\varepsilon=\\sum_{i=1}^2\\hat\\varepsilon_in_i\\otimes{}n_i,\\\\ \\sigma=\\sum_{i=1}^2\\hat\\sigma_in_i\\otimes{}n_i. \\] <p>In which \\(\\(\\hat\\varepsilon_i\\)\\) and \\(\\(\\hat\\sigma_i\\)\\) are principal strain and stress that are related to each other via uniaxial material model, viz., \\(\\(\\hat\\sigma_i=f(\\hat\\varepsilon_i)\\)\\).</p> <p>Given that the Poisson's effect is not considered, the in-plane stiffness can be expressed as</p> \\[ K=\\sum_ {i=1}^2\\dfrac{\\mathrm{d}\\hat\\sigma_i}{\\mathrm{d}\\hat\\varepsilon_i}n_i\\otimes{}n_i\\otimes{}n_i\\otimes{}n_i+\\dfrac{1}{2}\\dfrac{\\hat\\sigma_1-\\hat\\sigma_2}{\\hat\\varepsilon_1-\\hat\\varepsilon_2}( n_1\\otimes{}n_2+n_2\\otimes{}n_1)\\otimes(n_1\\otimes{}n_2+n_2\\otimes{}n_1). \\] <p>If one arranges second order tensors \\(\\(n_i\\otimes{}n_j\\)\\) into Voigt form, then we define the transformation matrix</p> \\[ T_{3\\times3}=\\begin{bmatrix}n_1\\otimes{}n_1&amp;n_2\\otimes{}n_2&amp;n_1\\otimes{}n_2+n_2\\otimes{}n_1\\end{bmatrix}, \\] <p>then</p> \\[ K=T\\hat{K}T^\\mathrm{T}, \\] <p>where</p> \\[ \\hat{K}=\\begin{bmatrix}\\dfrac{\\mathrm{d}\\hat\\sigma_1}{\\mathrm{d}\\hat\\varepsilon_1}&amp;&amp;\\\\&amp;\\dfrac{\\mathrm{d}\\hat\\sigma_2}{\\mathrm{d}\\hat\\varepsilon_2}&amp;\\\\&amp;&amp;\\dfrac{1}{2}\\dfrac{\\hat\\sigma_1-\\hat\\sigma_2}{\\hat\\varepsilon_1-\\hat\\varepsilon_2}\\end{bmatrix}, \\] <p>which is identical to the expression shown in 10.1061/(ASCE)0733-9399(1989)115:3(578).</p>"},{"location":"Library/Material/Material2D/Concrete22/","title":"Concrete22","text":"<p>Fixed Crack Concrete Model</p>"},{"location":"Library/Material/Material2D/Concrete22/#syntax","title":"Syntax","text":"Text Only<pre><code>material Concrete22 (1) (2) (3) (4) (5) (6) (7) (8) (9) (10) (11) (12) [13]\n# (1) int, unique material tag\n# (2) double, compression strength, should be negative but sign insensitive\n# (3) double, tension strength, should be positive but sign insensitive\n# (4) double, MC\n# (5) double, NC\n# (6) double, MT\n# (7) double, NT\n# (8) double, middle point\n# (9) double, strain at compression strength\n# (10) double, strain at tension strength\n# (11) double, shear stress\n# (12) double, shear retention factor\n# [13] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material2D/Elastic2D/","title":"Elastic2D","text":"<p>2D Elastic Model</p>"},{"location":"Library/Material/Material2D/Elastic2D/#syntax","title":"Syntax","text":"Text Only<pre><code>material Elastic2D (1) (2) (3) [4] [5]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, poissons ratio\n# [4] double, density, default: 0.0\n# [5] int, material type, plane stress = 0, plane strain = 1,, default: 0\n</code></pre>"},{"location":"Library/Material/Material2D/Rebar2D/","title":"Rebar2D","text":"<p>Orthotropic Material</p>"},{"location":"Library/Material/Material2D/Rebar2D/#syntax","title":"Syntax","text":"Text Only<pre><code>material Rebar2D (1) (2) (3) (4) (5)\n# (1) int, unique material tag\n# (2) int, x direction steel material tag\n# (3) int, y direction steel material tag\n# (4) double, x direction reinforcement ratio\n# (5) double, y direction reinforcement ratio\n</code></pre> <p>The uniform reinforcement is defined along global axes. To have arbitrarily aligned layout, users can wrap it into a <code>Rotation2D</code> wrapper.</p>"},{"location":"Library/Material/Material3D/Material3D/","title":"Material3D","text":"<p>All 3D material models support the following basic output types.</p> variable label physical meaning S all stress components S11 \\(\\(\\sigma_{11}\\)\\) S12 \\(\\(\\sigma_{12}\\)\\) S13 \\(\\(\\sigma_{13}\\)\\) S22 \\(\\(\\sigma_{22}\\)\\) S23 \\(\\(\\sigma_{23}\\)\\) S33 \\(\\(\\sigma_{33}\\)\\) E all strain components E11 \\(\\(\\varepsilon_{11}\\)\\) E12 \\(\\(\\varepsilon_{12}\\)\\) E13 \\(\\(\\varepsilon_{13}\\)\\) E22 \\(\\(\\varepsilon_{22}\\)\\) E23 \\(\\(\\varepsilon_{23}\\)\\) E33 \\(\\(\\varepsilon_{33}\\)\\) SP all principal stress components SP1 principal stress component 1 SP2 principal stress component 2 SP3 principal stress component 3 EP all principal strain components EP1 principal strain component 1 EP2 principal strain component 2 EP3 principal strain component 3 EE elastic strain PE plastic strain EEP principal elastic strain PEP principal plastic strain PEEP equivalent plastic strain HYDRO hydrostatic stress HIST history variable vector <p>Depending on the specific material model, additional output types may be available.</p>"},{"location":"Library/Material/Material3D/Clay/CamClay/BilinearCC/","title":"BilinearCC","text":"<p>Bilinear Hardening Modified Cam-Clay Model</p>"},{"location":"Library/Material/Material3D/Clay/CamClay/BilinearCC/#theory","title":"Theory","text":"<p>This model defines a bilinear hardening rule for \\(\\(a(\\alpha)\\)\\), which is a non-negative function.</p> \\[ a(\\alpha)=a_0+H\\alpha\\ge0, \\] <p>in which \\(\\(H\\)\\) is the hardening modulus, note \\(\\(\\alpha=\\varepsilon_p=\\varepsilon_1+\\varepsilon_2+\\varepsilon_3\\)\\) is the volumetric plastic strain.</p> <p>The hardening modulus could be either positive or negative.</p> <p>This hardening rule does not imply any physical soil behavior.</p>"},{"location":"Library/Material/Material3D/Clay/CamClay/BilinearCC/#syntax","title":"Syntax","text":"Text Only<pre><code>material BilinearCC (1) (2) (3) (4) (5) (6) (7) (8) [9]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, poissons ratio\n# (4) double, beta, controls compression side shape\n# (5) double, m, slope of CSL\n# (6) double, p_t, initial tension strength\n# (7) double, a_0, initial a_0\n# (8) double, H, slope of hardening function\n# [9] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material3D/Clay/CamClay/ExpCC/","title":"ExpCC","text":"<p>Exponential Hardening Cam-Clay Model</p> <p>This hardening law is identical to the one documented in ABAQUS manual (4.4.3).</p>"},{"location":"Library/Material/Material3D/Clay/CamClay/ExpCC/#hardening","title":"Hardening","text":"<p>The hardening function is defined as</p> \\[ a=a_0\\exp\\left(\\left(1+e_0\\right)\\dfrac{1-\\alpha}{\\lambda-\\kappa\\alpha}\\right), \\] <p>where \\(\\(e_0\\)\\) is the initial void ratio, \\(\\(\\lambda\\)\\) and \\(\\(\\kappa\\)\\) are material constants.</p> <p>If experimental data is available, \\(\\(a_0\\)\\) can be determined as</p> \\[ a_0=\\dfrac{1}{2}\\exp\\left(\\dfrac{e_1-e_0-\\kappa\\ln{}p_0}{\\lambda-\\kappa}\\right) \\] <p>where \\(\\(p_0\\)\\) is the initial value of the equivalent pressure stress and \\(\\(e_1\\)\\) is the intercept of the virgin consolidation line with the void ratio axis in a plot of void ratio versus equivalent pressure stress.</p>"},{"location":"Library/Material/Material3D/Clay/CamClay/ExpCC/#syntax","title":"Syntax","text":"Text Only<pre><code>material ExpCC (1) (2) (3) (4) (5) (6) (7) (8) (9) (10) [11]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, poissons ratio\n# (4) double, beta, controls compression side shape\n# (5) double, m, slope of CSL\n# (6) double, p_t, initial tension strength\n# (7) double, a_0, initial a_0\n# (8) double, e_0, initial void ratio\n# (9) double, lambda\n# (10) double, kappa\n# [11] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material3D/Clay/CamClay/ExpCC/#usage","title":"Usage","text":""},{"location":"Library/Material/Material3D/Clay/CamClay/NonlinearCamClay/","title":"NonlinearCamClay","text":"<p>Modified Cam-Clay Model</p> <p>The <code>NonlinearCamClay</code> class defines a basic framework using modified Cam-Clay yield surface and associative flow rule. Theories can be seen in Chapter 10 in Computational Methods for Plasticity: Theory and Application, in which there are some minor errors in the derivation of consistent stiffness.</p> <p>This model resembles the one in ABAQUS but the third stress invariant does not enter yield surface. As a result, the yield surface on the \\(\\(\\pi\\)\\)-plane is a circle.</p> <p>The implementation is documented in a separated file.</p> <p>The following function is chosen as the yield surface.</p> \\[ F(\\sigma,a)=\\dfrac{(p-p_t+a)^2}{b^2}+\\dfrac{q^2}{M^2}-a^2 \\] <p>where \\(\\(p(\\sigma)=\\dfrac{1}{3}(\\sigma_1+\\sigma_2+\\sigma_3)\\)\\) is the hydrostatic pressure, \\(\\(q^2(\\sigma)=\\dfrac{3}{2}s: s\\)\\) with \\(\\(s\\)\\) denotes the deviatoric stress, \\(\\(a(\\alpha)\\)\\) is a hardening function in terms of internal hardening variable \\(\\(\\alpha\\)\\) that is defined as volumetric plastic strain, that is \\(\\(\\alpha=\\varepsilon_v^p\\)\\). \\(\\(b=1\\)\\) when \\(\\(p-p_t+a\\ge0\\)\\) and \\(\\(b=\\beta\\)\\) when \\(\\(p-p_t+a&lt;0\\)\\). This \\(\\(\\beta\\)\\) parameter changes the radius of the second half of this ellipse on the compressive side of the hydrostatic axis. The constant \\(\\(M\\)\\) modifies the radius of the ellipse along the \\(\\(q\\)\\) axis.</p> <p>The same function is used for plasticity potential so that \\(\\(\\Phi=F\\)\\) and</p> \\[ \\dot{\\varepsilon_p}=\\dot{\\gamma}\\dfrac{\\partial{}\\Phi}{\\partial\\sigma}=\\dot{\\gamma}(\\dfrac{3}{M^2}s+\\dfrac{2(p-p_t+a) }{3b^2}I) \\] <p>where \\(\\(I=[1~1~1~0~0~0]^\\mathrm{T}\\)\\) is the second order unit tensor.</p> <p>The <code>NonlinearCamClay</code> class allows \\(\\(a(\\alpha)\\)\\) to be user defined.</p>"},{"location":"Library/Material/Material3D/Clay/CamClay/NonlinearCamClay/#history-layout","title":"History Layout","text":"location paramater <code>initial_history(0)</code> accumulated plastic strain"},{"location":"Library/Material/Material3D/Clay/CamClay/ParabolicCC/","title":"ParabolicCC","text":"<p>Parabolic Hardening Modified Cam-Clay Model</p>"},{"location":"Library/Material/Material3D/Clay/CamClay/ParabolicCC/#theory","title":"Theory","text":"<p>This model defines a parabolic hardening rule for \\(\\(a(\\alpha)\\)\\), which is a non-negative function.</p> \\[ a(\\alpha)=a_0+H\\alpha^2\\ge0, \\] <p>in which \\(\\(H\\)\\) is the hardening modulus, note \\(\\(\\alpha=\\varepsilon_p=\\varepsilon_1+\\varepsilon_2+\\varepsilon_3\\)\\) is the volumetric plastic strain.</p> <p>The hardening modulus could be either positive or negative.</p> <p>This hardening rule does not imply any physical soil behavior.</p>"},{"location":"Library/Material/Material3D/Clay/CamClay/ParabolicCC/#syntax","title":"Syntax","text":"Text Only<pre><code>material ParabolicCC (1) (2) (3) (4) (5) (6) (7) (8) [9]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, poissons ratio\n# (4) double, beta, controls compression side shape\n# (5) double, m, slope of CSL\n# (6) double, p_t, initial tension strength\n# (7) double, a_0, initial a_0\n# (8) double, H, slope of hardening function\n# [9] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material3D/Concrete/CDP/","title":"CDP","text":"<p>Concrete Damage Plasticity Model</p>"},{"location":"Library/Material/Material3D/Concrete/CDP/#references","title":"References","text":"<ol> <li>10.1061/(ASCE)0733-9399(1998)124:8(892)</li> <li>10.1002/(SICI)1096-9845(199809)27:9&lt;937::AID-EQE764&gt;3.0.CO;2-5</li> <li>10.1002/1097-0207(20010120)50:2&lt;487::AID-NME44&gt;3.0.CO;2-N</li> <li>10.1016/0020-7683(89)90050-4</li> </ol>"},{"location":"Library/Material/Material3D/Concrete/CDP/#outline","title":"Outline","text":"<p>The CDP model supports stiffness degradation. The backbone envelops are defined as exponential functions in terms of plastic strain [4]. Apart from the listed references, readers can also refer to the corresponding section in Constitutive Modelling Cookbook .</p>"},{"location":"Library/Material/Material3D/Concrete/CDP/#syntax","title":"Syntax","text":"Text Only<pre><code>material CDP (1) (2) (3) (4) (5) (6) (7) (8) (9) (10) (11) (12) (13) (14) [15]\n# (1) int, unique tag\n# (2) double, elastic modulus\n# (3) double, poissons ratio\n# (4) double, crack stress f_t\n# (5) double, crush stress f_c\n# (6) double, normalized crack energy g_t\n# (7) double, normalized crush energy g_c\n# (8) double, initial tension hardening a_t&lt;1\n# (9) double, initial compression hardening a_c&gt;1\n# (10) double, damage factor at half crack stress d_t\n# (11) double, damage factor at peak crush stress d_c\n# (12) double, dilatancy parameter\n# (13) double, biaxial compression ratio\n# (14) double, initial stiffness recovery factor\n# [15] double, density, default: 2400E-12\n</code></pre>"},{"location":"Library/Material/Material3D/Concrete/CDP/#remarks","title":"Remarks","text":"<ol> <li>Poisson's ratio shall be smaller than \\(\\(0.5\\)\\), a typical value for concrete is around \\(\\(0.2\\)\\).</li> <li>Crack stress shall be greater than zero while crush stress shall be smaller than zero. But the program automatically    set the signs for both stresses.</li> <li>Normalized crack energy \\(\\(g_t=G_F/l_c\\)\\) equals the first mode crack energy \\(\\(G_F\\)\\) over the characteristic length    \\(\\(l_c\\)\\). For SI (millimeter) unit system, typical values are of order \\(\\(10^{-3}\\)\\). The compression conjugate \\(\\(g_c\\)\\)    is typically greater than \\(\\(g_t\\)\\) by the order of \\(\\(10^2\\)\\).</li> <li>Hardening parameters controls tension degradation slope and compression hardening shape. Values \\(\\(a_t\\approx0.5\\)\\) and    \\(\\(a_c\\approx2\\)\\) to \\(\\(a_c\\approx5\\)\\) give good results.</li> <li>Dilatancy parameter can be set to \\(\\(0.2\\)\\). Comparisons can be seen in Lee's doctoral dissertation.</li> <li>Biaxial compression ratio is defined as the ratio between biaxial and uniaxial compression strengths. According to    Kupfer et al. (1969), a value of \\(\\(1.16\\)\\) is recommended.</li> <li>Initial stiffness recovery factor controls the amount of stiffness recovery when loading direction changes.</li> <li>Theoretically, \\(\\(g_t\\)\\) and \\(\\(g_c\\)\\) shall be scaled according to the size of mesh grid. Practically, they cannot be    arbitrarily small due to numerical stability issues, meaning that the mesh grid cannot be arbitrarily large.</li> </ol>"},{"location":"Library/Material/Material3D/Concrete/CDP/#history-layout","title":"History Layout","text":"location parameter <code>initial_history(0)</code> \\(\\(d_t\\)\\) <code>initial_history(1)</code> \\(\\(d_c\\)\\) <code>initial_history(2)</code> \\(\\(\\kappa_t\\)\\) <code>initial_history(3)</code> \\(\\(\\kappa_c\\)\\) <code>initial_history(4-9)</code> plastic strain"},{"location":"Library/Material/Material3D/Concrete/CDPM2/","title":"CDPM2","text":"<p>CDPM2 model for concrete model.</p>"},{"location":"Library/Material/Material3D/Concrete/CDPM2/#reference","title":"Reference","text":"<ol> <li>10.1016/j.ijsolstr.2013.07.008</li> <li>10.1016/j.ijsolstr.2005.05.038</li> </ol>"},{"location":"Library/Material/Material3D/Concrete/CDPM2/#remarks","title":"Remarks","text":"<ol> <li>The Lode angle dependency is removed for simplicity.</li> <li>The isotropic damage is implemented.</li> <li>The anisotropic damage is implemented.</li> <li>For detailed explanations of parameters, please refer to    Reference 1.</li> <li>The default <code>CDPM2</code> uses isotropic damage.</li> <li>The token <code>CDPM2ANISO</code> uses anisotropic damage.</li> <li>If damage is activated, both tension and compression use exponential damage model, the degradation is controlled by    parameters [14] and [15]. The characteristic length can be accounted for by modifying [14].</li> </ol>"},{"location":"Library/Material/Material3D/Concrete/CDPM2/#syntax","title":"Syntax","text":"Text Only<pre><code>material CDPM2 (1) [2-16]\nmaterial CDPM2NO (1) [2-16]\nmaterial CDPM2ISO (1) [2-16]\nmaterial CDPM2ANISO (1) [2-16]\n# (1) int, unique material tag\n# [2] double, elastic modulus, default: 3E4\n# [3] double, poissons ratio, default: 0.3\n# [4] double, tension strength (positive), default: 3.0\n# [5] double, compression strength (positive), default: 10.0\n# [6] double, q_h0, initial hardening factor, default: 0.3\n# [7] double, h_p hardening ratio, default: .01\n# [8] double, d_f, default: .85\n# [9] double, a_h, hardening related parameter, default: 0.08\n# [10] double, b_h, hardening related parameter, default: 0.003\n# [11] double, c_h, hardening related parameter, default: 2.0\n# [12] double, d_h, hardening related parameter, default: 1E-6\n# [13] double, a_s, ductility related parameter, default: 5.0\n# [14] double, e_ft, tension softening parameter, default: 2E-4\n# [15] double, e_fc, compression softening parameter, default: 1E-4\n# [16] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material3D/Concrete/CustomCDP/","title":"CustomCDP","text":"<p>The CDP Model With Custom Backbones</p> <p>The formulation is identical to that of the <code>CDP</code> model.</p> <p>User should provide the backbones and damage evolutions via expressions.</p>"},{"location":"Library/Material/Material3D/Concrete/CustomCDP/#syntax","title":"Syntax","text":"Text Only<pre><code>material CustomCDP (1) (2) (3) (4) (5) (6) (7) [8] [9] [10] [11]\n# (1) int, unique material tag\n# (2) int, tension expression tag\n# (3) int, compression expression tag\n# (4) double, elastic modulus\n# (5) double, poisson's ratio\n# (6) double, normalized crack energy (+)\n# (7) double, normalized crush energy (+)\n# [8] double, dilatancy parameter, default: 0.2\n# [9] double, biaxial compression strength ratio, default: 1.16\n# [10] double, stiffness recovery ratio, default: 0.5\n# [11] double, density, default: 0\n</code></pre>"},{"location":"Library/Material/Material3D/Concrete/CustomCDP/#restrictions","title":"Restrictions","text":"<ol> <li>The expressions should take one input argument, the damage variable, \\(\\(\\kappa\\)\\).    The \\(\\(\\kappa\\)\\) is different from the degradation denoted as \\(\\(d\\)\\).    The output should have a size of six.</li> <li>The normalized energy should be provided, which is used to generate objective results.    It is typically around the size of the area under the curve.</li> <li>The output consists of six components, which are explained in the following.</li> </ol> <p>The expression shall generate six numbers based on the input \\(\\(\\kappa\\)\\):</p> Index Symbol Description 1 \\(\\(d\\)\\) damage degradation index 2 \\(\\(f\\)\\) final stress: \\(\\((1-d)\\bar{f}\\)\\) 3 \\(\\(\\bar{f}\\)\\) effective stress \\(\\(f/(1-d)\\)\\) 4 \\(\\(\\mathrm{d}~d\\)\\) derivative of \\(\\(d\\)\\) 5 \\(\\(\\mathrm{d}~f\\)\\) derivative of \\(\\(f\\)\\) 6 \\(\\(\\mathrm{d}~\\bar{f}\\)\\) derivative of \\(\\(\\bar{f}\\)\\) <p>The \\(\\(\\kappa\\)\\) ranges from 0 to 1.</p> <p>The damage degradation index \\(\\(d\\)\\) shall satisfy: \\(\\(d(0)=0\\)\\) and \\(\\(d(1)=1\\)\\).</p> <p>The \\(\\(f\\)\\) is the actual stress observed as the final output of the model.</p> <p>By following these rules imposed, users can implement any custom backbone and damage evolution.</p> <p>Further explanation of the curves can be seen in 10.1061/(ASCE)0733-9399(1998)124:8(892)</p>"},{"location":"Library/Material/Material3D/Concrete/CustomCDP/#example","title":"Example","text":"<p>For the porpose of illustration, we provide a simple example, which may not be applicable to real concrete behaviour.</p> <p>Let's, say for example, the damage degradation is a linear function of \\(\\(\\kappa\\)\\), that is</p> \\[ d(\\kappa)=\\kappa, \\] <p>so that \\(\\(d(0)=0\\)\\) and \\(\\(d(1)=1\\)\\).</p> <p>Assume the effective stess is a constant, say \\(\\(\\bar{f}=10\\)\\). The stress is then</p> \\[ f=\\bar{f}(1-d)=10(1-\\kappa). \\] <p>One can define an expression as follows:</p> Text Only<pre><code>expression SimpleVector 1 x y|6 example\n</code></pre> <p>where \\(\\(x\\)\\) maps to \\(\\(\\kappa\\)\\) and \\(\\(y\\)\\) maps to the six components of the output.</p> <p>The text file <code>example</code> contains the following:</p> Text Only<pre><code>y[0]:=x;\ny[1]:=10*(1-x);\ny[2]:=10;\ny[3]:=1;\ny[4]:=-10;\ny[5]:=0;\n</code></pre> <p>Then it can be used in a <code>CustomCDP</code> material model such that:</p> Text Only<pre><code># A TEST MODEL FOR CUSTOMCDP MATERIAL\n\nnode 1 5 -5 0\nnode 2 5 5 0\nnode 3 -5 5 0\nnode 4 -5 -5 0\nnode 5 5 -5 10\nnode 6 5 5 10\nnode 7 -5 5 10\nnode 8 -5 -5 10\nnode 9 5 -5 20\nnode 10 5 5 20\nnode 11 -5 5 20\nnode 12 -5 -5 20\n\nexpression SimpleVector 1 x y|6 example\n\nmaterial CustomCDP 1 1 1 5000 .2 2E-1 2E-1 .23 1.16 .4 2400E-12\n\nelement C3D8 1 1 2 3 4 5 6 7 8 1 G\nelement C3D8 2 5 6 7 8 9 10 11 12 1 G\n\nhdf5recorder 1 Element E33 1\nhdf5recorder 2 Element S33 1\nhdf5recorder 3 Element KAPPAT 1\n\nfix 1 1 1 2 5 6 9 10\nfix 2 2 1 4 5 8 9 12\nfix 3 3 1 2 3 4\n\ndisplacement 1 0 1 3 9 10 11 12\n\nstep static 1\nset fixed_step_size 1\nset ini_step_size 1E-2\nset symm_mat 0\n\nconverger RelIncreDisp 1 1E-9 10 1\n\nanalyze\n\nsave recorder 1 2 3\n\nexit\n</code></pre> <p>One can plot the strain-stress curve.</p> <p></p> <p>The plastic strain can be computed as</p> \\[ \\varepsilon_p=\\varepsilon-\\frac{\\sigma}{E} \\] <p>The curve can be plotted as</p> <p></p> <p>The \\(\\(\\kappa\\)\\) is the accumulated area under the plastic strain-stress curve over the given \\(\\(g\\)\\), in this example, \\(\\(g=0.2\\)\\).</p> \\[ \\kappa=\\dfrac{1}{g}\\int_0^{\\varepsilon_p^*}\\sigma{}d\\varepsilon_p \\] <p>The \\(\\(\\kappa\\)\\)-\\(\\(\\sigma\\)\\) curve can be processed as</p> <p></p>"},{"location":"Library/Material/Material3D/Concrete/Rebar3D/","title":"Rebar3D","text":"<p>Orthotropic Material</p>"},{"location":"Library/Material/Material3D/Concrete/Rebar3D/#syntax","title":"Syntax","text":"Text Only<pre><code>material Rebar3D (1) (2) (3) (4) (5) (6) (7)\n# (1) int, unique material tag\n# (2) int, x direction steel material tag\n# (3) int, y direction steel material tag\n# (4) int, z direction steel material tag\n# (5) double, x direction reinforcement ratio\n# (6) double, y direction reinforcement ratio\n# (7) double, z direction reinforcement ratio\n</code></pre> <p>The uniform reinforcement is defined along global axes. To have arbitrarily aligned layout, users can wrap it into a <code>Rotation3D</code> wrapper.</p>"},{"location":"Library/Material/Material3D/Concrete/TableCDP/","title":"TableCDP","text":"<p>The CDP Model With Tabular Data Support</p> <p>The formulation is identical to that of the <code>CDP</code> model.</p> <p>The tabular backbones and damage evolution are supported in this model to provide more flexibility in terms of customizing the response.</p> <p>In total, four tables are required.</p>"},{"location":"Library/Material/Material3D/Concrete/TableCDP/#syntax","title":"Syntax","text":"Text Only<pre><code>material TableCDP (1) (2) (3) (4) (5) (6) (7) [8] [9] [10] [11]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, poisson's ratio\n# (4) string, file name of tension backbone table\n# (5) string, file name of compression backbone table\n# (6) string, file name of tension damage table\n# (7) string, file name of compression damage table\n# [8] double, dilatancy parameter, default: 0.2\n# [9] double, biaxial compression strength ratio, default: 1.16\n# [10] double, stiffness recovery ratio, default: 0.5\n# [11] double, density, default: 0\n</code></pre>"},{"location":"Library/Material/Material3D/Concrete/TableCDP/#restrictions","title":"Restrictions","text":"<ol> <li>For backbone tables, the slope between the last two points cannot be zero. The last stress value shall be as    close to zero as possible.</li> <li>For damage tables, the first point must be \\(\\((0,0)\\)\\), the last point does not have to be \\(\\((1,1)\\)\\) but shall stay in    the unit square.</li> </ol>"},{"location":"Library/Material/Material3D/Damage/IsotropicDamage/","title":"IsotropicDamage","text":"<p>Independent Isotropic Damage Model</p> <p>The <code>IsotropicDamage</code> model interacts with an associated 3D material model and compute damage factor based on total strain or other related quantities.</p>"},{"location":"Library/Material/Material3D/Damage/IsotropicDamage/#interface","title":"Interface","text":"<p>The <code>update_trial_status(const vec&amp;)</code> is implemented so that <code>trial_stress</code> and <code>trial_stiffness</code> store the corresponding response of the associated material model and calls the <code>update_damage()</code> method.</p> <p>The <code>update_damage()</code> method shall be implemented in all derived class.</p> <p>Alternatively, material state update method <code>update_trial_status(const vec&amp;)</code> can be thoroughly overridden by the derived classed.</p>"},{"location":"Library/Material/Material3D/Damage/LinearDamage/","title":"LinearDamage","text":"<p>Linear Damage Degradation With Cut-offs</p>"},{"location":"Library/Material/Material3D/Damage/LinearDamage/#syntax","title":"Syntax","text":"Text Only<pre><code>material LinearDamage (1) (2) (3) (4) [5]\n# (1) int, unique material tag\n# (2) int, associated material tag\n# (3) double, start strain\n# (4) double, end strain\n# [5] double, end damage value, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material3D/Damage/LinearDamage/#theory","title":"Theory","text":"<p>In this model, the equivalent total strain is used to characterize the damage development, namely, \\(\\(d=f(\\varepsilon_ {eq})\\)\\). Then the final response is defined as</p> \\[ \\mathbf\\sigma=d\\mathbf{\\bar\\sigma}, \\] <p>where \\(\\(\\mathbf{\\bar\\sigma}\\)\\) is the intact stress response of the associated material model.</p> <p>The final stiffness can be derived as</p> \\[ \\mathbf{K}=\\dfrac{\\mathrm{d}\\mathbf{\\sigma}}{\\mathrm{d}\\mathbf{\\varepsilon}}=\\dfrac{\\mathrm{d}\\mathbf{\\bar\\sigma}}{\\mathrm{d}\\mathbf{\\varepsilon}}d+\\mathbf{\\bar\\sigma}\\otimes\\dfrac{\\mathrm{d}d}{\\mathrm{d}\\mathbf{\\varepsilon}}=\\mathbf{\\bar{K}}d+\\mathbf{\\bar\\sigma}\\otimes\\dfrac{\\mathrm{d}d}{\\mathrm{d}\\mathbf{\\varepsilon}}. \\]"},{"location":"Library/Material/Material3D/DruckerPrager/BilinearDP/","title":"BilinearDP","text":"<p>Bilinear Drucker-Prager Model</p>"},{"location":"Library/Material/Material3D/DruckerPrager/BilinearDP/#syntax","title":"Syntax","text":"Text Only<pre><code>material BilinearDP (1) (2) (3) (4) (5) (6) (7) (8) [9]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, poissons ratio\n# (4) double, \\eta_y\n# (5) double, \\eta_f\n# (6) double, \\xi\n# (7) double, cohesion\n# (8) double, hardening ratio\n# [9] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material3D/DruckerPrager/CustomDP/","title":"CustomDP","text":"<p>Drucker-Prager model With Custom Hardening</p>"},{"location":"Library/Material/Material3D/DruckerPrager/CustomDP/#syntax","title":"Syntax","text":"Text Only<pre><code>material CustomDP (1) (2) (3) (4) (5) (6) (7) [8]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, poissons ratio\n# (4) double, \\eta_y\n# (5) double, \\eta_f\n# (6) double, \\xi\n# (7) unsigned, cohesion expression tag\n# [8] double, density, default: 0.0\n</code></pre> <p>The expressions shall be able to compute derivatives.</p>"},{"location":"Library/Material/Material3D/DruckerPrager/ExpDP/","title":"ExpDP","text":"<p>Exponential Drucker-Prager model</p>"},{"location":"Library/Material/Material3D/DruckerPrager/ExpDP/#syntax","title":"Syntax","text":"Text Only<pre><code>material ExpDP (1) (2) (3) (4) (5) (6) (7) (8) (9) [10]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, poissons ratio\n# (4) double, \\eta_y\n# (5) double, \\eta_f\n# (6) double, \\xi\n# (7) double, cohesion\n# (8) double, cohesion_a\n# (9) double, cohesion_b\n# [10] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material3D/DruckerPrager/NonlinearDruckerPrager/","title":"NonlinearDruckerPrager","text":"<p>Drucker-Prager Material Model</p> <p>The Drucker-Prager model use the following function as the yield surface.</p> \\[ F(\\sigma,c)=\\sqrt{J_2}+\\eta_yp-\\xi{}c \\] <p>in which \\(\\(J_2=\\dfrac{1}{2}s:s\\)\\) is the second invariant of stress \\(\\(\\sigma\\)\\), \\(\\(p=\\dfrac{1}{3}( \\sigma_1+\\sigma_2+\\sigma_3)\\)\\) is the hydrostatic stress, \\(\\(c(\\bar{\\varepsilon_p})\\)\\) is cohesion, \\(\\(\\eta_y\\)\\) and \\(\\(\\xi\\)\\) are material constants.</p> <p>Either associated or non-associated flow rule can be applied. The flow potential is defined as</p> \\[ \\Phi(\\sigma,c)=\\sqrt{J_2}+\\eta_fp \\] <p>with \\(\\(\\eta_f\\)\\) is another material constant. If \\(\\(\\eta_f=\\eta_y\\)\\), the associative plasticity is defined so that the symmetry of stiffness matrix is recovered.</p>"},{"location":"Library/Material/Material3D/DruckerPrager/NonlinearDruckerPrager/#history-variable-layout","title":"History Variable Layout","text":"location parameter <code>initial_history(0)</code> accumulated plastic strain"},{"location":"Library/Material/Material3D/DruckerPrager/NonlinearDruckerPrager/#decision-of-material-constants","title":"Decision of Material Constants","text":"<p>There are quite a lot of schemes to determine the material constants used in Drucker-Prager model. Here a few are presented.</p>"},{"location":"Library/Material/Material3D/DruckerPrager/NonlinearDruckerPrager/#geomaterials","title":"Geomaterials","text":"<p>The friction angle \\(\\(\\phi\\)\\) and initial cohesion \\(\\(c_0\\)\\) shall be determined by experiments.</p>"},{"location":"Library/Material/Material3D/DruckerPrager/NonlinearDruckerPrager/#outer-mohr-coulomb","title":"Outer Mohr-Coulomb","text":"\\[ \\eta_y=\\dfrac{6\\sin\\phi}{\\sqrt{3}(3-\\sin\\phi)},\\qquad\\xi=\\dfrac{6\\cos\\phi}{\\sqrt{3}(3-\\sin\\phi)} \\]"},{"location":"Library/Material/Material3D/DruckerPrager/NonlinearDruckerPrager/#inner-mohr-coulomb","title":"Inner Mohr-Coulomb","text":"\\[ \\eta_y=\\dfrac{6\\sin\\phi}{\\sqrt{3}(3+\\sin\\phi)},\\qquad\\xi=\\dfrac{6\\cos\\phi}{\\sqrt{3}(3+\\sin\\phi)} \\]"},{"location":"Library/Material/Material3D/DruckerPrager/NonlinearDruckerPrager/#plane-strain-fitting","title":"Plane Strain Fitting","text":"\\[ \\eta_y=\\dfrac{3\\tan\\phi}{\\sqrt{9+12\\tan^2\\phi}},\\qquad\\xi=\\dfrac{3}{\\sqrt{9+12\\tan^2\\phi}} \\]"},{"location":"Library/Material/Material3D/DruckerPrager/NonlinearDruckerPrager/#concrete-rock-etc","title":"Concrete, Rock, etc","text":"<p>To fit uniaxial tension and compression strength, the friction angle and cohesion shall be computed as</p> \\[ \\phi=\\sin^{-1}\\dfrac{f_c-f_t}{f_c+f_t},\\qquad{}c=\\dfrac{f_cf_t}{f_c-f_t}\\tan\\phi \\] <p>in which \\(\\(f_t\\ge0\\)\\) and \\(\\(f_c\\ge0\\)\\) are tension and compression strength respectively.</p>"},{"location":"Library/Material/Material3D/DruckerPrager/NonlinearDruckerPrager/#uniaxial-tensioncompression","title":"Uniaxial Tension/Compression","text":"\\[ \\eta_y=\\dfrac{3\\sin\\phi}{\\sqrt{3}},\\qquad\\xi=\\dfrac{2\\sin\\phi}{\\sqrt{3}} \\]"},{"location":"Library/Material/Material3D/DruckerPrager/NonlinearDruckerPrager/#biaxial-tensioncompression","title":"Biaxial Tension/Compression","text":"\\[ \\eta_y=\\dfrac{3\\sin\\phi}{2\\sqrt{3}},\\qquad\\xi=\\dfrac{2\\sin\\phi}{\\sqrt{3}} \\]"},{"location":"Library/Material/Material3D/Elastic/BlatzKo/","title":"BlatzKo","text":"<p>Blatz-Ko Hyperelastic Material</p> <p>The Blatz-Ko material can be used to simulate foam rubber.</p>"},{"location":"Library/Material/Material3D/Elastic/BlatzKo/#reference","title":"Reference","text":"<ol> <li>10.1016/0045-7949(86)90199-9</li> </ol>"},{"location":"Library/Material/Material3D/Elastic/BlatzKo/#syntax","title":"Syntax","text":"Text Only<pre><code>material BlatzKo (1) (2) (3)\n# (1) int, unique tag\n# (2) double, elastic modulus\n# (3) double, poissons ratio\n</code></pre>"},{"location":"Library/Material/Material3D/Elastic/IsotropicElastic3D/","title":"IsotropicElastic3D","text":"<p>Isotropic Elastic Material</p>"},{"location":"Library/Material/Material3D/Elastic/IsotropicElastic3D/#syntax","title":"Syntax","text":"Text Only<pre><code>material IsotropicElastic3D (1) (2) (3) [4]\n# (1) int, unique tag\n# (2) double, elastic modulus\n# (3) double, poissons ratio\n# [4] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material3D/Elastic/IsotropicNonlinearElastic3D/","title":"IsotropicNonlinearElastic3D","text":"<p>General Nonlinear Elastic Isotropic 3D Material Framework</p> <p>The <code>IsotropicNonlinearElastic3D</code> class is an abstract general purpose framework.</p> <p>It offers an interface to allow users to define arbitrary strain energy potential based on volumetric strain and equivalent strain (squared), that is</p> \\[ W=f\\left(\\varepsilon_v,\\varepsilon_p^2\\right), \\] <p>where</p> \\[ \\varepsilon_v=\\text{trace}\\left(\\varepsilon\\right),\\qquad\\varepsilon_p=\\sqrt{\\dfrac{2}{3}\\varepsilon_d: \\varepsilon_d}. \\] <p>Note it is normally expressed in terms of equivalent strain rather than its square. However, the derivation of tangent stiffness would be too cumbersome.</p>"},{"location":"Library/Material/Material3D/Elastic/IsotropicNonlinearElastic3D/#overridden-method","title":"Overridden Method","text":"<p>The <code>IsotropicNonlinearElastic3D</code> provides a method that shall be overridden.</p> C++<pre><code>virtual vec compute_derivative(double, double) = 0;\n</code></pre> <p>The first argument is \\(\\(\\varepsilon_v\\)\\). The second argument is \\(\\(\\varepsilon_s=\\varepsilon_p^2\\)\\).</p> <p>The method shall return a vector of size six with following values computed.</p> index value \\(\\(0\\)\\) \\(\\(\\dfrac{\\partial{}W}{\\partial\\varepsilon_v}\\)\\) \\(\\(1\\)\\) \\(\\(\\dfrac{\\partial{}W}{\\partial\\varepsilon_s}\\)\\) \\(\\(2\\)\\) \\(\\(\\dfrac{\\partial^2W}{\\partial\\varepsilon_v^2}\\)\\) \\(\\(3\\)\\) \\(\\(\\dfrac{\\partial^2W}{\\partial\\varepsilon_s^2}\\)\\) \\(\\(4\\)\\) \\(\\(\\dfrac{\\partial^2W}{\\partial\\varepsilon_v\\partial\\varepsilon_s}\\)\\) \\(\\(5\\)\\) \\(\\(\\dfrac{\\partial^2W}{\\partial\\varepsilon_s\\partial\\varepsilon_v}\\)\\)"},{"location":"Library/Material/Material3D/Elastic/MooneyRivlin/","title":"MooneyRivlin","text":"<p>Mooney-Rivlin Rubber Material</p> <p>The regularized Mooney-Rivlin material for compressible rubbers uses the following expression to measure strain energy.</p> \\[ W=A_{10}(J_1-3)+A_{01}(J_2-3)+\\dfrac{K}{2}(J_3-1)^2, \\] <p>where \\(\\(A_{10}\\)\\) and \\(\\(A_{01}\\)\\) are two material constants and \\(\\(K\\)\\) is the bulk modulus.</p>"},{"location":"Library/Material/Material3D/Elastic/MooneyRivlin/#syntax","title":"Syntax","text":"Text Only<pre><code>material MoonetRivlin (1) (2) (3) (4) [5]\n# (1) int, unique tag\n# (2) double, bulk modulus\n# (3) double, A_{10}\n# (4) double, A_{01}\n# [5] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material3D/Elastic/MooneyRivlin/#remarks","title":"Remarks","text":"<ol> <li>Nonlinear geometry switch shall be turned on in related elements.</li> <li>The model takes the Green strain as input. To implement any elements that incorporate this material model, the Green    strain in Voigt notation shall be passed as strain input.</li> </ol>"},{"location":"Library/Material/Material3D/Elastic/MooneyRivlin/#usage","title":"Usage","text":""},{"location":"Library/Material/Material3D/Elastic/NLE3D01/","title":"NLE3D01","text":"<p>Nonlinear Elastic 3D Model</p>"},{"location":"Library/Material/Material3D/Elastic/NLE3D01/#syntax","title":"Syntax","text":"Text Only<pre><code>material NLE3D01 (1) (2) (3) (4) (5) [6]\n# (1) int, unique material tag\n# (2) double, bulk modulus\n# (3) double, reference strain\n# (4) double, reference stress\n# (5) double, m\n# [6] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material3D/Elastic/NLE3D01/#theory","title":"Theory","text":"<p>The strain energy potential is expressed as</p> \\[ W=\\dfrac{9}{2}K\\varepsilon_v^2+\\dfrac{\\varepsilon_0\\sigma_0}{1-m}\\left(\\dfrac{\\varepsilon_p}{\\varepsilon_0}\\right)^{( 1-m)}, \\] <p>where \\(\\(K\\)\\) is the bulk modulus, \\(\\(\\varepsilon_0\\)\\) is the reference strain, \\(\\(\\sigma_0\\)\\) is the reference stress and \\(\\(m\\in[0,1]\\)\\) is an exponent controls nonlinearity. The volumetric strain \\(\\(\\varepsilon_v\\)\\) and equivalent strain \\(\\(\\varepsilon_p\\)\\) are expressed as</p> \\[ \\varepsilon_v=\\text{trace}\\left(\\varepsilon\\right),\\qquad\\varepsilon_p=\\sqrt{\\dfrac{2}{3}\\varepsilon_d: \\varepsilon_d}. \\]"},{"location":"Library/Material/Material3D/Elastic/OrthotropicElastic3D/","title":"OrthotropicElastic3D","text":"<p>Orthotropic Elastic Material</p>"},{"location":"Library/Material/Material3D/Elastic/OrthotropicElastic3D/#syntax","title":"Syntax","text":"Text Only<pre><code>material OrthotropicElastic3D (1) (2...7) (8...10) [11]\n# (1) int, unique tag\n# (2..7) double, six moduli\n# (8...10) double, three poissons ratio\n# [11] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material3D/Elastic/Yeoh/","title":"Yeoh","text":"<p>Regularized Yeoh Material For Compressible Rubbers</p> <p>The following strain energy density is used.</p> \\[ W=\\sum_{i=1}^nC_{i0}(J_1-3)^i+\\sum_{i=1}^nC_{i1}(J_3-1)^{2i}. \\] <p>where \\(\\(C_{i0}\\)\\) and \\(\\(C_{i1}\\)\\) are material constants. \\(\\(J_1\\)\\) and \\(\\(J_3\\)\\) are reduced invariants of the right Cauchy-Green deformation tensor.</p>"},{"location":"Library/Material/Material3D/Elastic/Yeoh/#syntax","title":"Syntax","text":"Text Only<pre><code>material Yeoh (1) (2...)\n# (1) int, unique material tag\n# (2...) double, material constants with possible density\n</code></pre>"},{"location":"Library/Material/Material3D/Elastic/Yeoh/#remarks","title":"Remarks","text":"<ol> <li>The above command takes input list of arbitrary length (\\(\\(\\ge2\\)\\), excluding tag).</li> <li>If the number of double inputs is odd, the last one is interpreted as density.</li> <li>If the number of double inputs is even, the density is assumed to be zero.</li> <li>The first half of double inputs is read as \\(\\(C_{i0}\\)\\) and the second half \\(\\(C_{i1}\\)\\).</li> </ol>"},{"location":"Library/Material/Material3D/Elastic/Yeoh/#examples","title":"Examples","text":"<p>For \\(\\(i=1\\)\\), let \\(\\(C_{10}=20\\)\\) and \\(\\(C_{11}=4000\\)\\), the strain energy density is</p> \\[ W=20(J_1-3)+4000(J_3-1)^2. \\] <p>The following command shall be used.</p> Text Only<pre><code>material Yeoh 1 20 4000\n</code></pre> <p>If density is nonzero, say for example \\(\\(\\rho=1E-4\\)\\), then the following command shall be used.</p> Text Only<pre><code>material Yeoh 1 20 4000 1E-4\n</code></pre> <p>For \\(\\(i=3\\)\\), let \\(\\(C_{10}=20\\)\\), \\(\\(C_{20}=30\\)\\), \\(\\(C_{30}=40\\)\\), \\(\\(C_{11}=2000\\)\\),\\(\\(C_{21}=3000\\)\\) and \\(\\(C_{31}=4000\\)\\), the strain energy density is</p> \\[ W=20(J_1-3)+30(J_1-3)^2+40(J_1-3)^3+2000(J_3-1)^2+3000(J_3-1)^4+4000(J_3-1)^6. \\] <p>The following command shall be used.</p> Text Only<pre><code>material Yeoh 1 20 30 40 2000 3000 4000\n</code></pre>"},{"location":"Library/Material/Material3D/Hoffman/BilinearHoffman/","title":"BilinearHoffman","text":"<p>Bilinear Hardening Hoffman Model</p>"},{"location":"Library/Material/Material3D/Hoffman/BilinearHoffman/#syntax","title":"Syntax","text":"Text Only<pre><code>material BilinearHoffman (1) (2...7) (8...10) (11...19) [20] [21]\n# (1) int, unique material tag\n# (2...7) double, six moduli: E_{xx}, E_{yy}, E_{zz}, E_{xy}, E_{yz}, E_{zx}\n# (8...10) double, three poissions ratios: v_{xx}, v_{yy}, v_{zz}\n# (11...19) double, nine yield stress\n# [20] double, hardening ratio, default: 0.0\n# [21] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material3D/Hoffman/CustomHoffman/","title":"CustomHoffman","text":"<p>Hoffman Model With Custom Isotropic Hardening</p>"},{"location":"Library/Material/Material3D/Hoffman/CustomHoffman/#syntax","title":"Syntax","text":"Text Only<pre><code>material CustomHoffman (1) (2...7) (8...10) (11...19) (20) [21]\n# (1) int, unique material tag\n# (2...7) double, six moduli: E_{xx}, E_{yy}, E_{zz}, E_{xy}, E_{yz}, E_{zx}\n# (8...10) double, three poissions ratios: v_{xx}, v_{yy}, v_{zz}\n# (11...19) double, nine yield stress\n# (20) int, isotropic hardening expression tag\n# [21] double, density, default: 0.0\n</code></pre> <p>The expressions shall be able to compute derivatives.</p>"},{"location":"Library/Material/Material3D/Hoffman/ExpHoffman/","title":"ExpHoffman","text":"<p>Exponential Hardening Hoffman Model</p>"},{"location":"Library/Material/Material3D/Hoffman/ExpHoffman/#theory","title":"Theory","text":"<p>The isotropic hardening rule is defined as</p> \\[ K(\\bar\\varepsilon_p)=1+a(1-e^{-b\\bar\\varepsilon_p}) \\]"},{"location":"Library/Material/Material3D/Hoffman/ExpHoffman/#syntax","title":"Syntax","text":"Text Only<pre><code>material ExpHoffman (1) (2...7) (8...10) (11...19) (20) (21) [22]\n# (1) int, unique material tag\n# (2...7) double, six moduli: E_{xx}, E_{yy}, E_{zz}, E_{xy}, E_{yz}, E_{zx}\n# (9...10) double, three poissions ratios: v_{xx}, v_{yy}, v_{zz}\n# (11...19) double, nine yield stress\n# (20) double, a\n# (21) double, b\n# [22] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material3D/Hoffman/NonlinearHill/","title":"NonlinearHill","text":"<p>Orthotropic Hill Material</p> <p>This is a wrapper of Hoffman model. Please check the <code>NonlinearHoffman</code> material model.</p>"},{"location":"Library/Material/Material3D/Hoffman/NonlinearHoffman/","title":"NonlinearHoffman","text":"<p>Orthotropic Hoffman Material</p> <p>The <code>NonlinearHoffman</code> defines an orthotropic material using Hoffman yield criterion and associative plasticity.</p> <p>The yield surface is defined as</p> \\[ \\begin{multline} F(\\sigma,\\bar\\varepsilon_p)=C_1(\\sigma_{11}-\\sigma_{22})^2+C_2(\\sigma_{22}-\\sigma_{33})^2+C_3( \\sigma_{33}-\\sigma_{11})^2+\\\\[4mm] C_4\\sigma_{12}^2+C_5\\sigma_{23}^2+C_6\\sigma_{13}^2+C_7\\sigma_{11}+C_8\\sigma_{22}+C_9\\sigma_{33}-K^2(\\bar\\varepsilon_p) \\end{multline} \\] <p>with \\(\\(\\sigma=[\\sigma_{11}~\\sigma_{22}~\\sigma_{33}~\\sigma_{12}~\\sigma_{23}~\\sigma_{13}]^\\mathrm{T}\\)\\) is the stress, \\(\\(C_1\\)\\) to \\(\\(C_9\\)\\) are material constants. \\(\\(K(\\bar\\epsilon_p)\\)\\) is the isotropic hardening function.</p> <p>The constants are defined as follows.</p> \\[ \\begin{align*} C_1&amp;=\\dfrac{1}{2}(\\dfrac{1}{\\sigma_{11}^t\\sigma_{11}^c}+\\dfrac{1}{\\sigma_{22}^t\\sigma_ {22}^c}-\\dfrac{1}{\\sigma_{33}^t\\sigma_{33}^c}),\\\\[4mm] C_2&amp;=\\dfrac{1}{2}(\\dfrac{1}{\\sigma_{22}^t\\sigma_{22}^c}+\\dfrac{1}{\\sigma_{33}^t\\sigma_{33}^c}-\\dfrac{1}{\\sigma_ {11}^t\\sigma_{11}^c}),\\\\[4mm] C_3&amp;=\\dfrac{1}{2}(\\dfrac{1}{\\sigma_{33}^t\\sigma_{33}^c}+\\dfrac{1}{\\sigma_{11}^t\\sigma_{11}^c}-\\dfrac{1}{\\sigma_ {22}^t\\sigma_{22}^c}),\\\\[4mm] C_4&amp;=\\dfrac{1}{\\sigma_{12}^0\\sigma_{12}^0},\\quad{}C_5=\\dfrac{1}{\\sigma_{23}^0\\sigma_{23}^0},\\quad{}C_6=\\dfrac{1}{\\sigma_ {13}^0\\sigma_{13}^0},\\\\[4mm] C_7&amp;=\\dfrac{\\sigma_{11}^c-\\sigma_{11}^t}{\\sigma_{11}^t\\sigma_{11}^c},\\quad{}C_8=\\dfrac{\\sigma_{22}^c-\\sigma_ {22}^t}{\\sigma_{22}^t\\sigma_{22}^c},\\quad{}C_9=\\dfrac{\\sigma_{33}^c-\\sigma_{33}^t}{\\sigma_{33}^t\\sigma_{33}^c}. \\end{align*} \\] <p>The Hoffman function allows different yield stresses for tension and compression. To recover the original Hill yield function, simply set \\(\\(\\sigma_{ii}^t=\\sigma_{ii}^c\\)\\) for \\(\\(i=1,~2,~3\\)\\).</p> <p>The hardening function \\(\\(K(\\bar\\varepsilon_p)\\)\\) can be user defined. It shall be noted that \\(\\(K(0)=1\\)\\). The following method shall be implemented.</p> C++<pre><code>virtual double compute_k(double) const = 0;\nvirtual double compute_dk(double) const = 0;\n</code></pre>"},{"location":"Library/Material/Material3D/Hoffman/NonlinearHoffman/#history-layout","title":"History Layout","text":"location parameter <code>initial_history(0)</code> accumulated plastic strain"},{"location":"Library/Material/Material3D/Sand/DafaliasManzari/","title":"DafaliasManzari","text":"<p>The modified Dafalias--Manzari sand model.</p> <p>The original model 10.1061/(ASCE)0733-9399(2004)130:6(622) is modified slightly. Readers can also refer to the corresponding section in Constitutive Modelling Cookbook for details on the theory.</p> <p>The modifications can be summaries as follows.</p> <ol> <li>The continuum mechanics convention (tension positive) is used. All volumetric strain and hydrostatic stress related    quantities shall flip their signs.</li> <li>The Lode angle dependency is removed, which is equivalent to set \\(\\(c=1\\)\\) in Eq. (19).</li> <li>Constants such as \\(\\(2/3\\)\\) and \\(\\(\\sqrt{2/3}\\)\\) are removed. They can be combined with the model parameters.</li> <li>The hardening related parameter \\(\\(h\\)\\) as defined in Eq. (24) causes numerical issues under small cyclic loads. Hence,    it is changed to a similar form.</li> </ol> <p>The algorithm is correct but the theory needs validation. Your collaboration would be much appreciated.</p>"},{"location":"Library/Material/Material3D/Sand/DafaliasManzari/#syntax","title":"Syntax","text":"Text Only<pre><code>material DafaliasMazanri (1) (2-18) [19]\n(1) int, unique material tag\n(2) double, reference shear modulus G_0 ==&gt; 125\n(3) double, poissons ratio \\nu\n(4) double, \\alpha^c ==&gt; 1.5\n(5) double, slope of critical state line \\lambda_c ==&gt; 0.02\n(6) double, initial void ratio e_0\n(7) double, exponent \\xi ==&gt; 0.7\n(8) double, initial yield surface size m ==&gt; 0.01\n(9) double, hardening constant h_0\n(10) double, hardening constant h_1 ==&gt; 0.1\n(11) double, hardening constant c_h ==&gt; 0.9\n(12) double, n^b ==&gt; 1.1\n(13) double, dilatancy constant A_0 ==&gt; -0.7\n(14) double, n^d ==&gt; 3.5\n(15) double, z_{max} ==&gt; 4\n(16) double, c_z ==&gt; 600\n(17) double, atmospheric pressure p_{at} ==&gt; -130\n(18) double, threshold G_r ==&gt; 0.1\n[19] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material3D/Sand/DafaliasManzari/#theory","title":"Theory","text":""},{"location":"Library/Material/Material3D/Sand/DafaliasManzari/#hyperelasticity","title":"Hyperelasticity","text":"<p>The hyperelastic response is defined as</p> \\[ G=G_0\\dfrac{\\left(2.97-e\\right)^2}{1+e}\\sqrt{pp_{at}},\\qquad K=\\dfrac{2}{3}\\dfrac{1+\\nu}{1-2\\nu}G. \\] <p>To improve numerical stability, \\(\\(G\\)\\) is bounded by \\(\\(G_rG_0|p_{at}|\\)\\) where \\(\\(G_r\\)\\) is a constant can be chosen as for example \\(\\(0.1\\)\\). This is equivalent to define an elastic response for \\(\\(|p|&lt;0.01|p_{at}|\\)\\).</p> <p>The void ratio can be associated to strain so that</p> \\[ e=e_0+\\left(1+e_0\\right)\\mathrm{tr~}{\\varepsilon^{tr}}. \\] <p>The strain increment can be decomposed into elastic and plastic parts.</p> \\[ \\mathbf{\\varepsilon}^{tr}=\\mathbf{\\varepsilon}_n+\\Delta\\mathbf{\\varepsilon}=\\mathbf{\\varepsilon}_ n+\\Delta\\mathbf{\\varepsilon}^{e}+\\Delta\\mathbf{\\varepsilon}^{p}. \\] <p>As such, the stress increment can be expressed accordingly,</p> \\[ \\mathbf{\\sigma}=\\mathbf{\\sigma}_n+\\Delta\\mathbf{\\sigma}=\\mathbf{\\sigma}_n+2G\\left( \\Delta{}\\mathbf{e}-\\Delta{}\\mathbf{e}^{p}\\right)+K\\left(\\Delta\\varepsilon_v-\\Delta\\varepsilon_v^p\\right)\\mathbf{I}. \\] <p>In deviatoric and spherical components,</p> \\[ \\mathbf{\\sigma}=\\mathbf{s}+p\\mathbf{I},\\\\ p=p_n+K\\left(\\Delta\\varepsilon_v-\\Delta\\varepsilon_v^p\\right),\\\\ \\mathbf{s}=\\mathbf{s}_n+2G\\left(\\Delta{}\\mathbf{e}-\\Delta{}\\mathbf{e}^{p}\\right), \\] <p>with</p> \\[ \\Delta\\mathbf{\\varepsilon}=\\Delta{}\\mathbf{e}+\\dfrac{1}{3}\\Delta\\varepsilon_v\\mathbf{I}, \\] <p>where \\(\\(\\mathbf{s}=\\mathrm{dev~}{\\mathbf{\\sigma}}\\)\\) is the deviatoric stress, \\(\\(p=\\dfrac{1}{3}\\mathrm{tr~ }{\\mathbf{\\sigma}}\\)\\) is the hydrostatic stress.</p>"},{"location":"Library/Material/Material3D/Sand/DafaliasManzari/#critical-state","title":"Critical State","text":"<p>The critical state parameter is chosen as</p> \\[ \\psi=e-e_0+\\lambda_c\\left(\\dfrac{p}{p_{at}}\\right)^\\xi. \\] <p>The dilatancy surface is defined as</p> \\[ \\alpha^d=\\alpha^c\\exp\\left(n^d\\psi\\right). \\] <p>The bounding surface is defined as</p> \\[ \\alpha^b=\\alpha^c\\exp\\left(-n^b\\psi\\right). \\]"},{"location":"Library/Material/Material3D/Sand/DafaliasManzari/#yield-function","title":"Yield Function","text":"<p>A wedge-like function is chosen to be the yield surface.</p> \\[ F=\\big|\\mathbf{s}+p\\mathbf{\\alpha}\\big|+mp=\\big|\\mathbf{\\eta}\\big|+mp, \\] <p>where \\(\\(\\alpha\\)\\) is the so called back stress ratio and \\(\\(m\\)\\) characterises the size of the wedge. For simplicity, \\(\\(m\\)\\) is assumed to be a constant in this model.</p> <p>By denoting \\(\\(\\mathbf{\\eta}=\\mathbf{s}+p\\mathbf{\\alpha}\\)\\), the directional unit tensor is defined as</p> \\[ \\mathbf{n}=\\dfrac{\\mathbf{\\eta}}{\\big|\\mathbf{\\eta}\\big|}. \\]"},{"location":"Library/Material/Material3D/Sand/DafaliasManzari/#flow-rule","title":"Flow Rule","text":"<p>A non-associated plastic flow is used, the corresponding flow rule is defined as follows.</p> \\[ \\Delta\\mathbf{\\varepsilon}^p=\\gamma\\left(\\mathbf{n}+\\dfrac{1}{3}D\\mathbf{I}\\right), \\] <p>where \\(\\(D\\)\\) is the dilatancy parameter.</p> \\[ D=A_d\\left(\\alpha^d-m-\\mathbf{\\alpha}:\\mathbf{n}\\right)=A_0\\left(1+\\left\\langle\\mathbf{z}: \\mathbf{n}\\right\\rangle\\right)\\left(\\alpha_d-m-\\mathbf{\\alpha}:\\mathbf{n}\\right). \\] <p>Due to the change of sign convention, a negative \\(\\(D\\)\\) gives contractive response, thus \\(\\(A_0\\)\\) often needs to be negative.</p>"},{"location":"Library/Material/Material3D/Sand/DafaliasManzari/#hardening-rule","title":"Hardening Rule","text":"<p>The evolution rate of the back stress ratio \\(\\(\\mathbf{\\alpha}\\)\\) is defined in terms of a proper distance measure from the bounding surface,</p> \\[ \\Delta\\mathbf{\\alpha}=\\gamma{}h\\left(\\left(\\alpha^b-m\\right)\\mathbf{n}-\\mathbf{\\alpha}\\right), \\] <p>where \\(\\(h\\)\\) controls the hardening rate,</p> \\[ h=b_0\\exp\\left(h_1\\left(\\mathbf{\\alpha}_{in}-\\mathbf{\\alpha}\\right):\\mathbf{n}\\right). \\] <p>The parameter \\(\\(b_0\\)\\) is defined as a function of current state,</p> \\[ b_0=G_0h_0\\left(1-c_he\\right)\\sqrt{\\dfrac{p_{at}}{p}}. \\] <p>\\(\\(\\mathbf{\\alpha}_{in}\\)\\) is updated whenever load reversal occurs.</p>"},{"location":"Library/Material/Material3D/Sand/DafaliasManzari/#fabric-effect","title":"Fabric Effect","text":"<p>The fabric tensor changes when \\(\\(\\Delta\\varepsilon^p_v\\)\\) is positive,</p> \\[ \\Delta\\mathbf{z}=c_z\\left\\langle\\Delta\\varepsilon^p_v\\right\\rangle\\left(z_m\\mathbf{n}-\\mathbf{z}\\right). \\]"},{"location":"Library/Material/Material3D/Sand/SimpleSand/","title":"SimpleSand","text":"<p>A Simple Sand Model</p> <p>The continuum mechanics based sign convention (tension is positive) is used for consistency.</p> <p>The <code>SimpleSand</code> model is a simple sand hardening model that adopts a bounding surface concept.</p> <p>Readers can also refer to the corresponding section in Constitutive Modelling Cookbook for details on the theory.</p>"},{"location":"Library/Material/Material3D/Sand/SimpleSand/#syntax","title":"Syntax","text":"Text Only<pre><code>material SimpleSand (1) (2) (3) (4) (5) (6) (7) (8) (9) (10) (11) (12) (13) [14]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, poissons ratio\n# (4) double, m, size of yield surface\n# (5) double, A, dilatancy related parameter, often negative\n# (6) double, h, dilatancy related hardening parameter\n# (7) double, alpha_c, critical alpha\n# (8) double, n_b, bounding surface evolution parameter\n# (9) double, n_d, dilatancy surface evolution parameter\n# (10) double, v_c, critical specific volume\n# (11) double, p_c, critical hydrostatic stress, should be negative\n# (12) double, lambda_c, the slope of critical state line\n# (13) double, v_0, initial specific volume\n# [14] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material3D/Sand/SimpleSand/#theory","title":"Theory","text":""},{"location":"Library/Material/Material3D/Sand/SimpleSand/#critical-state","title":"Critical State","text":"<p>The state parameter is defined as</p> \\[ \\psi=v-v_c+\\lambda_c\\ln\\left(\\dfrac{p}{p_c}\\right) \\] <p>The specific volume can be expressed in terms of strain,</p> \\[ v=v_0\\left(1+\\mathrm{tr}~\\varepsilon\\right). \\] <p>Thus, the bounding surface and dilatancy surface can be defined to evolve with \\(\\(\\psi\\)\\),</p> \\[ \\alpha^b=\\alpha^c\\exp\\left(-n^b\\psi\\right),\\qquad \\alpha^d=\\alpha^c\\exp\\left(n^d\\psi\\right), \\] <p>where \\(\\(\\alpha^c\\)\\) is the initial size of surfaces.</p>"},{"location":"Library/Material/Material3D/Sand/SimpleSand/#yield-surface","title":"Yield Surface","text":"<p>The following wedge-like function is chosen to be the yield surface,</p> \\[ F=|s+p\\alpha|+mp, \\] <p>where \\(\\(s\\)\\) is the deviatoric stress, \\(\\(p\\)\\) is the hydrostatic stress, \\(\\(\\alpha\\)\\) is the back stress ratio and \\(\\(m\\)\\) is a constant that controls the size of the wedge.</p>"},{"location":"Library/Material/Material3D/Sand/SimpleSand/#flow-rule","title":"Flow Rule","text":"<p>A non-associated flow rule is defined.</p> \\[ \\Delta\\varepsilon^p=\\Delta\\gamma{}\\left(n+\\dfrac{1}{3}DI\\right), \\] <p>where \\(\\(n=\\dfrac{s+p\\alpha}{|s+p\\alpha|}\\)\\) is a unit tensor, \\(\\(I\\)\\) is the second order unit tensor and \\(\\(D=A\\left( \\alpha^d-\\alpha:n\\right)\\)\\) is the dilatancy parameter.</p> <p>Note due to the change of sign convention, a negative \\(\\(D\\)\\) leads to contractive response, thus \\(\\(A\\)\\) often needs to be negative.</p>"},{"location":"Library/Material/Material3D/Sand/SimpleSand/#hardening-rule","title":"Hardening Rule","text":"<p>The evolution of \\(\\(\\alpha\\)\\) is similar to the Armstrong-Frederick hardening law.</p> \\[ \\Delta\\alpha=\\Delta\\gamma{}h\\left(\\alpha^bn-\\alpha\\right), \\] <p>where \\(\\(h\\)\\) is a constant that controls the speed of hardening.</p>"},{"location":"Library/Material/Material3D/Sand/SimpleSand/#example","title":"Example","text":"<p>Please refer to triaxial-compression-of-sand.</p>"},{"location":"Library/Material/Material3D/vonMises/ArmstrongFrederick/","title":"ArmstrongFrederick","text":"<p>Armstrong-Frederick Steel Model</p>"},{"location":"Library/Material/Material3D/vonMises/ArmstrongFrederick/#reference","title":"Reference","text":"<ol> <li>10.1016/S0749-6419(01)00049-3</li> <li>10.1115/1.3264257</li> <li>10.1179/096034007X207589</li> </ol>"},{"location":"Library/Material/Material3D/vonMises/ArmstrongFrederick/#theory","title":"Theory","text":"<p>Implementation can be found in a separate document.</p> <p>A von Mises type yield function is used. The associated plasticity is assumed. Both isotropic and kinematic hardening rules are employed.</p> <p>Although the plastic flow is associative, the hardening rules are not. As the result, the consistent tangent modulus is not symmetric.</p>"},{"location":"Library/Material/Material3D/vonMises/ArmstrongFrederick/#isotropic-hardening","title":"Isotropic Hardening","text":"<p>An exponential function is added to the linear hardening law.</p> \\[ k=\\sigma_y+k_s(1-e^{-mp})+k_lp, \\] <p>where \\(\\(\\sigma_y\\)\\) is the initial elastic limit (yielding stress), \\(\\(k_s\\)\\) is the saturated stress, \\(\\(k_l\\)\\) is the linear hardening modulus, \\(\\(m\\)\\) is a constant that controls the speed of hardening, \\(\\(\\mathrm{d}p=\\sqrt{\\dfrac{2}{3}\\mathrm{d}\\varepsilon^p:\\mathrm{d}\\varepsilon^p}\\)\\) is the rate of accumulated plastic strain \\(\\(p\\)\\).</p>"},{"location":"Library/Material/Material3D/vonMises/ArmstrongFrederick/#kinematic-hardening","title":"Kinematic Hardening","text":"<p>The Armstrong-Frederick type rule is used. Multiple back stresses are defined,</p> \\[ \\beta=\\sum\\beta^i \\] <p>in which</p> \\[ \\mathrm{d}\\beta^i=\\sqrt{\\dfrac{2}{3}}a^i~\\mathrm{d}\\varepsilon^p-b^i\\beta~\\mathrm{d}p, \\] <p>where \\(\\(a^i\\)\\) and \\(\\(b^i\\)\\) are material constants. Note here a slightly different definition is adopted as in the original literature \\(\\(\\dfrac{2}{3}\\)\\) is used instead of \\(\\(\\sqrt{\\dfrac{2}{3}}\\)\\). This is purely for a slightly more tidy derivation and does not affect anything.</p>"},{"location":"Library/Material/Material3D/vonMises/ArmstrongFrederick/#syntax","title":"Syntax","text":"Text Only<pre><code>material ArmstrongFrederick (1) (2) (3) (4) (5) (6) (7) [(8) (9)...] [10]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, poissons ratio\n# (4) double, yield stress\n# (5) double, saturated stress\n# (6) double, linear hardening modulus\n# (7) double, m\n# (8) double, a\n# (9) double, b\n# [10] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material3D/vonMises/ArmstrongFrederick/#history-layout","title":"History Layout","text":"location parameter <code>initial_history(0)</code> accumulated plastic strain <code>initial_history(1-6)</code> back stress for the first pair of \\(\\(a^1\\)\\) and \\(\\(b^1\\)\\) <code>initial_history(7-12)</code> back stress for the second pair of \\(\\(a^2\\)\\) and \\(\\(b^2\\)\\) if defined ... more back stresses"},{"location":"Library/Material/Material3D/vonMises/ArmstrongFrederick/#example","title":"Example","text":"<p>Here a few examples are shown.</p>"},{"location":"Library/Material/Material3D/vonMises/ArmstrongFrederick/#isotropic-hardening-only","title":"Isotropic Hardening Only","text":"<p>There is no difference between the classic J2 plasticity model and this AF steel model if only isotropic hardening is defined.</p> Text Only<pre><code>material ArmstrongFrederick 1 2E2 .2 .1 .05 1. 1000.\n</code></pre> <p></p>"},{"location":"Library/Material/Material3D/vonMises/ArmstrongFrederick/#kinematic-hardening-only","title":"Kinematic Hardening Only","text":"<p>If \\(\\(a\\neq0\\)\\) and \\(\\(b=0\\)\\), there is no difference between the classic J2 plasticity model and this AF steel model. A linear kinematic hardening rule is implied. Normally at least one set of \\(\\(a^1\\)\\) and \\(\\(b^1\\)\\) is defined.</p> Text Only<pre><code>material ArmstrongFrederick 1 2E2 .2 .1 0. 0. 0. 50. 500.\n</code></pre> <p></p> <p>By definition, if one set of \\(\\(a^1\\)\\) and \\(\\(b^1\\)\\) is defined, then the maximum stress can be computed as</p> \\[ \\sigma_{max}=\\sigma_y+\\sqrt{\\dfrac{3}{2}}\\dfrac{a^1}{b^1}. \\] <p>In this case, it is</p> \\[ \\sigma_{max}=0.1~\\mathrm{GPa}+\\sqrt{\\dfrac{3}{2}}\\dfrac{50}{500}~\\mathrm{GPa}=222.47~\\mathrm{MPa}. \\] <p>The cyclic response is shown as follows.</p> <p></p> <p>Of course, multiple sets of \\(\\(a^i\\)\\) and \\(\\(b^i\\)\\) can be defined.</p> Text Only<pre><code>material ArmstrongFrederick 1 2E2 .2 .1 0. 0. 0. 50. 500. 100. 600.\n</code></pre> <p>Accordingly, the maximum stress is</p> \\[ \\sigma_{max}=\\sigma_y+\\sqrt{\\dfrac{3}{2}}\\sum\\dfrac{a^i}{b^i}=0.1+\\sqrt{\\dfrac{3}{2}}\\left( \\dfrac{50}{500}+\\dfrac{100}{600}\\right)=426.60~\\mathrm{MPa}. \\] <p></p> <p>The cyclic response is shown as follows.</p> <p></p>"},{"location":"Library/Material/Material3D/vonMises/ArmstrongFrederick/#zero-elastic-range","title":"Zero Elastic Range","text":"<p>It is possible to define a zero plastic range response, although the initial stiffness cannot be explicitly assigned.</p> Text Only<pre><code>material ArmstrongFrederick 1 2E2 .2 0. 0. 0. 0. 40.82482305 500.\n</code></pre> <p>The corresponding maximum stress is \\(\\(100~\\mathrm{MPa}\\)\\).</p> <p></p> <p>With some linear isotropic hardening,</p> Text Only<pre><code>material ArmstrongFrederick 1 2E2 .2 0. 0. .1 0. 40.82482305 500.\n</code></pre> <p></p>"},{"location":"Library/Material/Material3D/vonMises/BilinearJ2/","title":"BilinearJ2","text":"<p>Bilinear J2 Plasticity</p>"},{"location":"Library/Material/Material3D/vonMises/BilinearJ2/#syntax","title":"Syntax","text":"Text Only<pre><code>material BilinearJ2 (1) (2) (3) (4) [5] [6] [7]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, poissons ratio\n# (4) double, yield stress\n# [5] double, hardening ratio, default: 0.0\n# [6] double, beta, default: 1.0\n# [7] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material3D/vonMises/BilinearPeric/","title":"BilinearPeric","text":"<p>Bilinear Peric Viscous Plasticity Model</p>"},{"location":"Library/Material/Material3D/vonMises/BilinearPeric/#theory","title":"Theory","text":"<p>The rate of plasticity multiplier is defined as</p> \\[ \\dot{\\gamma}=\\dfrac{1}{\\mu}\\left(\\dfrac{q}{\\sigma_y}-1\\right)^{\\dfrac{1}{\\epsilon}} \\] <p>where \\(\\(\\epsilon\\)\\) and \\(\\(\\mu\\)\\) are two material constants, \\(\\(\\sigma_y\\)\\) is the initial yield stress, \\(\\(q=\\sqrt{\\dfrac{3}{2}s:s}=\\sqrt{3J_2}\\)\\) is the von Mises stress.</p> <p>The yielding surface is identical to that of the von Mises model.</p>"},{"location":"Library/Material/Material3D/vonMises/BilinearPeric/#syntax","title":"Syntax","text":"Text Only<pre><code>material BilinearPeric (1) (2) (3) (4) (5) (6) (7) [8]\n# (1) int, unique tag\n# (2) double, elastic modulus\n# (3) double, poissons ratio\n# (4) double, yield stress\n# (5) double, hardening modulus\n# (6) double, mu\n# (7) double, epsilon\n# [8] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material3D/vonMises/CustomGurson/","title":"CustomGurson","text":""},{"location":"Library/Material/Material3D/vonMises/CustomGurson/#syntax","title":"Syntax","text":"Text Only<pre><code>material CustomGurson (1) (2) (3) (4) [5] [6] [7] [8] [9] [10]\n# (1) int, unique material tag\n# (2) int, expression tag\n# (3) double, elastic modulus\n# (4) double, poissons ratio\n# [5] double, q1, default: 1.0\n# [6] double, q2, default: 1.0\n# [7] double, fn, default: 0.0\n# [8] double, sn, default: 1.0\n# [9] double, en, default: 0.0\n# [10] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material3D/vonMises/CustomJ2/","title":"CustomJ2","text":"<p>J2 Plasticity Model With Custom Hardening</p>"},{"location":"Library/Material/Material3D/vonMises/CustomJ2/#theory","title":"Theory","text":"<p>This model is an implementation of the <code>NonlinearJ2</code> abstract model.</p>"},{"location":"Library/Material/Material3D/vonMises/CustomJ2/#syntax","title":"Syntax","text":"Text Only<pre><code>material CustomJ2 (1) (2) (3) (4) (5) [6]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, possions ratio\n# (4) int, isotropic hardening expression tag\n# (5) int, kinematic hardening expression tag\n# [6] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material3D/vonMises/CustomJ2/#remarks","title":"Remarks","text":"<p>Both hardening functions shall be defined in terms of the equivalent plastic strain.</p> <p>The isotropic hardening function evaluates to the yield stress for trivial equivalent plastic strain.</p> <p>The kinematic hardening function evaluates to zero for trivial equivalent plastic strain.</p> <p>The usage is similar to that of <code>CustomMises1D</code>.</p> <p>The expressions shall be able to compute derivatives.</p>"},{"location":"Library/Material/Material3D/vonMises/ExpGurson/","title":"ExpGurson","text":""},{"location":"Library/Material/Material3D/vonMises/ExpGurson/#syntax","title":"Syntax","text":"Text Only<pre><code>material ExpGurson (1) (2) (3) (4) (5) [6] [7] [8] [9] [10] [11]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, poissons ratio\n# (4) double, yield stress\n# (5) double, n\n# [6] double, q1, default: 1.0\n# [7] double, q2, default: 1.0\n# [8] double, fn, default: 0.0\n# [9] double, sn, default: 1.0\n# [10] double, en, default: 0.0\n# [11] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material3D/vonMises/ExpGurson/#remarks","title":"Remarks","text":"<ol> <li>Due to that the yield function has the quadratic term \\(\\(q^2\\)\\), it shall be noted that the unit of the model shal be    selected carefully. For example, if the yield stress is \\(\\(1000~\\mathrm{MPa}\\)\\) and \\(\\(\\mathrm{Pascal}\\)\\) is used as the    unit for stress, then the input number is \\(\\(10^9\\)\\), the square of which is greater than \\(\\(10^{16}\\)\\) so that the yield    function likely overflows.</li> </ol>"},{"location":"Library/Material/Material3D/vonMises/ExpJ2/","title":"ExpJ2","text":"<p>Exponential Isotropic Hardening J2 Model</p> <p>The kinematic hardening is not defined in this model.</p>"},{"location":"Library/Material/Material3D/vonMises/ExpJ2/#theory","title":"Theory","text":"<p>The backbone function is defined as</p> \\[ \\sigma=\\sigma_y\\left(\\left(1+a\\right)e^{-b\\varepsilon_p}-ae^{-2b\\varepsilon_p}\\right), \\] <p>where \\(\\(a\\)\\) and \\(\\(b\\)\\) are two constants that control the shape of the backbone. The initial stiffness \\(\\(\\sigma'|_ {\\varepsilon_p=0}=\\sigma_y(a-1)b\\)\\).</p>"},{"location":"Library/Material/Material3D/vonMises/ExpJ2/#syntax","title":"Syntax","text":"Text Only<pre><code>material ExpJ2 (1) (2) (3) (4) (5) (6) [7]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, poissons ratio\n# (4) double, yield stress\n# (5) double, a\n# (6) double, b\n# [7] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material3D/vonMises/MultilinearJ2/","title":"MultilinearJ2","text":"<p>Multilinear Hardening J2 Model</p>"},{"location":"Library/Material/Material3D/vonMises/MultilinearJ2/#syntax","title":"Syntax","text":""},{"location":"Library/Material/Material3D/vonMises/NonlinearGurson/","title":"NonlinearGurson","text":"<p>Nonlinear General Gurson Porous Model</p>"},{"location":"Library/Material/Material3D/vonMises/NonlinearGurson/#yield-function","title":"Yield Function","text":"<p>An extended yield function is used,</p> \\[ F=q^2+2q_1f\\sigma_y^2\\cosh\\left(\\dfrac{3}{2}\\dfrac{q_2p}{\\sigma_y}\\right)-\\sigma_y^2\\left(q_1^2f^2+1\\right), \\] <p>where</p> \\[ s=\\mathrm{dev}~\\sigma,\\qquad{}p=\\dfrac{\\mathrm{tr}~ \\sigma}{3}=\\dfrac{I_1}{3},\\qquad{}q=\\sqrt{3J_2}=\\sqrt{\\dfrac{3}{2}s:s}=\\sqrt{\\dfrac{3}{2}}|s|. \\] <p>Furthermore, \\(\\(q_1\\)\\), \\(\\(q_2\\)\\) and \\(\\(q_3=q_1^2\\)\\) are model constants, \\(\\(f(\\varepsilon_m^p)\\)\\) is the volume fraction, \\(\\(\\sigma_y(\\varepsilon_m^p)\\)\\) is the yield stress, \\(\\(\\varepsilon_m^p\\)\\) is the equivalent plastic strain.</p> <ul> <li>\\(\\(q_1=q_2=1\\)\\) The original Gurson model is recovered.</li> <li>\\(\\(q_1=0\\)\\) The von Mises model is recovered.</li> </ul>"},{"location":"Library/Material/Material3D/vonMises/NonlinearGurson/#evolution-of-equivalent-plastic-strain","title":"Evolution of Equivalent Plastic Strain","text":"<p>The evolution of \\(\\(\\varepsilon_m^p\\)\\) is assumed to be governed by the equivalent plastic work expression,</p> \\[ \\left(1-f\\right)\\sigma_y\\Delta\\varepsilon^p_m=\\sigma:\\Delta\\varepsilon^p=2\\Delta\\gamma\\left( \\dfrac{q^{tr}}{1+6G\\Delta\\gamma}\\right)^2+3q_1q_2p\\Delta\\gamma{}f\\sigma_y\\sinh\\left( \\dfrac{3}{2}\\dfrac{q_2p}{\\sigma_y}\\right). \\]"},{"location":"Library/Material/Material3D/vonMises/NonlinearGurson/#evolution-of-volume-fraction","title":"Evolution of Volume Fraction","text":"<p>The evolution of volume fraction consists of two parts.</p> \\[ \\Delta{}f=\\Delta{}f_g+\\Delta{}f_n, \\] <p>where</p> \\[ \\Delta{}f_g=(1-f)\\Delta\\varepsilon_v,\\qquad\\Delta{}f_n=A\\Delta\\varepsilon_m^p \\] <p>with</p> \\[ A=\\dfrac{f_N}{s_N\\sqrt{2\\pi}}\\exp\\left(-\\dfrac{1}{2}\\left(\\dfrac{\\varepsilon_m^p-\\varepsilon_N}{s_N}\\right)^2\\right). \\] <p>Parameters \\(\\(f_N\\)\\), \\(\\(s_N\\)\\) and \\(\\(\\varepsilon_N\\)\\) controls the normal distribution of volume fraction. If (\\(f_N=0\\)\\), the nucleation is disabled. In this case, when (\\(f_0=0\\)\\), the volume fraction will stay at zero regardless of strain history.</p>"},{"location":"Library/Material/Material3D/vonMises/NonlinearJ2/","title":"NonlinearJ2","text":"<p>Nonlinear General J2 Plasticity Model</p>"},{"location":"Library/Material/Material3D/vonMises/NonlinearJ2/#summary","title":"Summary","text":"<p>This is an abstract material class thus cannot be used directly. This class defines a general plasticity model using J2 yielding criterion with associated flow rule and mixed hardening rule. The isotropic/kinematic hardening response can be customized.</p> <p>To use this model, a derived class shall be defined first.</p> C++<pre><code>class YourJ2 final : public NonlinearJ2 {\n// class definition\n}\n</code></pre> <p>The derived class only needs to implement four pure virtual methods that define the isotropic and kinematic hardening rules.</p> C++<pre><code>virtual double compute_k(double) const = 0; // isotropic hardening\nvirtual double compute_dk(double) const = 0; // derivative isotropic\nvirtual double compute_h(double) const = 0; // kinematic hardening\nvirtual double compute_dh(double) const = 0; // derivative kinematic\n</code></pre> <p>All four methods take equivalent plastic strain as the input argument, on output, the corresponding quantities shall be provided.</p> <p>The isotropic hardening function \\(\\(K(\\bar\\varepsilon_p)\\)\\) defines the isotropic hardening rule, there are some requirements:</p> <ol> <li>\\(\\(K(\\bar\\varepsilon_p)\\)\\) should be non-negative,</li> <li>\\(\\(K(\\bar\\varepsilon_p=0)=\\sigma_y\\)\\) where \\(\\(\\sigma_y\\)\\) is the initial yielding stress.</li> </ol> <p>There is no requirement for the kinematic hardening function \\(\\(H(\\bar\\varepsilon_p)\\)\\). Both hardening rules can coexist. However, to successfully solve the trial status, there is an additional constraint that shall be applied on the model:</p> \\[ E+H'(\\bar\\varepsilon_p)+K'(\\bar\\varepsilon_p)\\geqslant0~\\text{for all}~\\bar\\varepsilon_p \\] <p>Otherwise, the local Newton iteration will fail.</p>"},{"location":"Library/Material/Material3D/vonMises/NonlinearJ2/#brief-on-theory","title":"Brief On Theory","text":"<p>The <code>NonlinearJ2</code> abstract class defines an associative plasticity framework using the von Mises yield criterion, which is defined as follows.</p> \\[ F(\\sigma,\\bar\\varepsilon_p)=\\sqrt{\\dfrac{3}{2}(s-\\beta(\\bar\\varepsilon_p)):(s-\\beta(\\bar\\varepsilon_p))}-\\sigma_y( \\bar\\varepsilon_p) \\] <p>where \\(\\(\\beta(\\bar\\varepsilon_p)\\)\\) is the back stress depends on the equivalent plastic strain \\(\\(\\bar\\varepsilon_p\\)\\) and \\(\\(\\sigma_y(\\bar\\varepsilon_p)\\)\\) is the yield stress. Note</p> \\[ \\sqrt{3J_2}=\\sqrt{\\dfrac{3}{2}(s-\\beta(\\bar\\varepsilon_p)):(s-\\beta(\\bar\\varepsilon_p))} \\] <p>It is also called J2 plasticity model. A detailed discussion can be seen elsewhere. \\(\\(\\beta(\\bar\\varepsilon_p)=H( \\bar\\varepsilon_p)\\)\\) and \\(\\(\\sigma_y(\\bar\\varepsilon_p)=K(\\bar\\varepsilon_p)\\)\\).</p>"},{"location":"Library/Material/Material3D/vonMises/NonlinearJ2/#history-layout","title":"History Layout","text":"location paramater <code>initial_history(0)</code> accumulated plastic strain <code>initial_history(1-6)</code> back stress"},{"location":"Library/Material/Material3D/vonMises/NonlinearJ2/#kinematic-hardening","title":"Kinematic Hardening","text":"<p>The back stress \\(\\(\\beta(\\bar{\\varepsilon}_p)\\)\\) defines a kinematic hardening response. For example a linear kinematic hardening could be defined as:</p> \\[ \\beta(\\bar\\varepsilon_p)=E_K\\bar\\varepsilon_p \\] <p>and the derivative</p> \\[ \\dfrac{\\mathrm{d}\\beta(\\bar\\varepsilon_p)}{\\mathrm{d}\\bar\\varepsilon_p}=E_K \\] <p>in which \\(\\(E_K\\)\\) is the kinematic hardening stiffness.</p> <p>In this case, user shall override the corresponding two methods with such an implmentation.</p> C++<pre><code>double SampleJ2::compute_h(const double p_strain) const { return e_kin * p_strain; }\ndouble SampleJ2::compute_dh(const double) const { return e_kin; }\n</code></pre> <p>Of course, a nonlinear relationship could also be defined.</p>"},{"location":"Library/Material/Material3D/vonMises/NonlinearJ2/#isotropic-hardening","title":"Isotropic Hardening","text":"<p>The isotropic hardening is defined by function \\(\\(\\sigma_y(\\bar\\varepsilon_p)\\)\\). The value \\(\\(\\sigma_y(0)\\)\\) should be the initial yield stress. Also, for a bilinear isotropic hardening response, user shall override the following two methods.</p> C++<pre><code>double SampleJ2::compute_k(const double p_strain) const { return e_iso * p_strain + yield_stress; }\ndouble SampleJ2::compute_dk(const double) const { return e_iso; }\n</code></pre> <p>Here another polynomial based isotropic hardening function is shown as an additional example. The function is defined as</p> \\[ \\sigma_y=\\sigma_0(1+\\sum_{i=1}^{n}a_i\\bar\\varepsilon_p^i) \\] <p>where \\(\\(a_i\\)\\) are material constants. It is easy to see \\(\\(\\sigma_y|_{\\bar\\varepsilon_p=0}=\\sigma_0\\)\\). The derivative is</p> \\[ \\dfrac{\\mathrm{d}\\sigma_y}{\\mathrm{d}\\bar\\varepsilon_p}=\\sigma_0\\sum_{i=1}^{n}ia_i\\bar\\varepsilon_p^{i-1} \\] <p>To define such a hardening behavior, a vector shall be used to store all constants.</p> C++<pre><code>// PolyJ2.h\nconst vec poly_para; // poly_para is a vector stores a_i\n</code></pre> <p>The methods could be written as follows.</p> C++<pre><code>// PolyJ2.cpp\ndouble PolyJ2::compute_k(const double p_strain) const {\nvec t_vec(poly_para.n_elem);\nt_vec(0) = 1.;\nfor(uword I = 1; I &lt; t_vec.n_elem; ++I) t_vec(I) = t_vec(I - 1) * p_strain;\nreturn yield_stress * dot(poly_para, t_vec);\n}\ndouble PolyJ2::compute_dk(const double p_strain) const {\nvec t_vec(poly_para.n_elem);\nt_vec(0) = 0.;\nt_vec(1) = 1.;\nfor(uword I = 2; I &lt; t_vec.n_elem; ++I) t_vec(I) = (double(I) + 1.) * pow(p_strain, double(I));\nreturn yield_stress * dot(poly_para, t_vec);\n}\n</code></pre>"},{"location":"Library/Material/Material3D/vonMises/NonlinearJ2/#example","title":"Example","text":"<p>A few different models are shown as examples. User can define arbitrary models.</p>"},{"location":"Library/Material/Material3D/vonMises/NonlinearPeric/","title":"NonlinearPeric","text":"<p>Viscoplasticity</p> <p>Similar to the classic rate independent J2 plasticity, the <code>NonlinearPeric</code> class defines a J2 plasticity incorporates viscoplatisicity using Peric's model, that is</p> \\[ \\dot\\gamma(\\sigma,\\sigma_y)=\\left\\{\\begin{array}{ll}\\dfrac{1}{\\mu}\\left[\\dfrac{q(\\sigma)}{\\sigma_y}-1\\right] ^{1/\\epsilon},&amp;\\Phi\\ge0,\\\\0,&amp;\\Phi&lt;0.\\end{array}\\right. \\] <p>In which, \\(\\(\\mu\\)\\) is viscosity related parameter, \\(\\(\\epsilon\\)\\) is rate sensitivity, larger \\(\\(\\epsilon\\)\\) represents response to be more sensitive to rate, \\(\\(q(\\sigma)=\\sqrt{\\dfrac{3}{2}\\eta:\\eta}\\)\\) as before is the effective von Mises stress.</p>"},{"location":"Library/Material/Material3D/vonMises/PolyJ2/","title":"PolyJ2","text":"<p>Polynomial Hardening J2 Model</p> <p>The <code>PolyJ2</code> defines a J2 material with isotropic hardening. The isotropic hardening is controlled by a polynomial. The kinematic hardening is disabled.</p>"},{"location":"Library/Material/Material3D/vonMises/PolyJ2/#syntax","title":"Syntax","text":"Text Only<pre><code>material PolyJ2 (1) (2) (3) (4) [(5)...]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, poisson's ratio\n# (4) double, density\n# [(5)...] double, parameters in polynomial\n</code></pre>"},{"location":"Library/Material/Material3D/vonMises/PolyJ2/#example","title":"Example","text":"<p>The isotropic hardening function is defined to be a polynomial function of equivalent plastic strain.</p> \\[ \\sigma_y(\\bar\\varepsilon_p)=a_0+a_1\\bar\\varepsilon_p+a_2\\bar\\varepsilon_p^2+\\cdots+a_n\\bar\\varepsilon_p^n. \\] <p>Clearly, \\(\\(a_0\\)\\) is the initial yielding stress.</p> <p>To define for example the following hardening</p> \\[ \\sigma_y(\\bar\\varepsilon_p)=100+4000\\bar\\varepsilon_p+80000\\bar\\varepsilon_p^3 \\] <p>with \\(\\(E=200000\\)\\) and \\(\\(\\nu=0.3\\)\\), the following command can be used.</p> Text Only<pre><code>material PolyJ2 1 2E5 .3 .0 1E2 4E3 0. 8E4\n</code></pre>"},{"location":"Library/Material/Material3D/vonMises/VAFCRP/","title":"VAFCRP","text":"<p>Viscous J2 Steel Model</p> <p>Before I can find a proper name for it, I would call it <code>VAFCRP</code> model. Although the name is a bit weird, it contains all the initials of researchers. Similar models are available as: <code>ArmstrongFrederick</code> , <code>ExpJ2</code> and <code>NonlinearPeric</code>.</p>"},{"location":"Library/Material/Material3D/vonMises/VAFCRP/#reference","title":"Reference","text":"<ol> <li>https://doi.org/10.1017/S0368393100118759</li> <li>https://doi.org/10.1179/096034007X207589</li> <li>https://doi.org/10.1016/0749-6419(89)90015-6</li> <li>https://doi.org/10.1002/nme.1620360807</li> </ol>"},{"location":"Library/Material/Material3D/vonMises/VAFCRP/#theory","title":"Theory","text":"<p>The <code>VAFCRP</code> model is a von Mises J2 yield criterion based model and uses an associative plasticity flow. The yield function is defined as</p> \\[ F=\\sqrt{\\dfrac{3}{2}(s-\\beta):(s-\\beta)}-k=q-k. \\] <p>So the plastic flow is</p> \\[ \\dot{\\varepsilon}^p=\\gamma\\dfrac{\\partial{}F}{\\partial{}\\sigma}=\\sqrt{\\dfrac{3}{2}}\\gamma{}n, \\] <p>where \\(\\(n=\\dfrac{\\eta}{|\\eta|}=\\dfrac{s-\\beta}{|s-\\beta|}\\)\\).</p>"},{"location":"Library/Material/Material3D/vonMises/VAFCRP/#v","title":"V","text":"<p>The Voce (1955) type isotropic hardening equation is used.</p> \\[ k=\\sigma_y+k_s(1-e^{-mp})+k_lp, \\] <p>where \\(\\(\\sigma_y\\)\\) is the initial elastic limit (yielding stress), \\(\\(k_s\\)\\) is the saturated stress, \\(\\(k_l\\)\\) is the linear hardening modulus, \\(\\(m\\)\\) is a constant that controls the speed of hardening, \\(\\(\\mathrm{d}p=\\sqrt{\\dfrac{2}{3}\\mathrm{d}\\varepsilon^p:\\mathrm{d}\\varepsilon^p}\\)\\) is the rate of accumulated plastic strain \\(\\(p\\)\\).</p>"},{"location":"Library/Material/Material3D/vonMises/VAFCRP/#af","title":"AF","text":"<p>The Armstrong-Frederick (1966) kinematic hardening rule is used. The rate form of back stress \\(\\(\\beta^i\\)\\) is</p> \\[ \\mathrm{d}\\beta^i=\\sqrt{\\dfrac{2}{3}}a^i~\\mathrm{d}\\varepsilon^p-b^i\\beta~\\mathrm{d}p, \\] <p>where \\(\\(a^i\\)\\) and \\(\\(b^i\\)\\) are material constants. Note here a slightly different definition is adopted as in the original literature \\(\\(\\dfrac{2}{3}\\)\\) is used instead of \\(\\(\\sqrt{\\dfrac{2}{3}}\\)\\). This is purely for a slightly more tidy derivation and does not affect anything.</p>"},{"location":"Library/Material/Material3D/vonMises/VAFCRP/#cr","title":"CR","text":"<p>A multiplicative formulation (Chaboche and Rousselier, 1983) is used for the total back stress.</p> \\[ \\beta=\\sum\\beta^i. \\]"},{"location":"Library/Material/Material3D/vonMises/VAFCRP/#p","title":"P","text":"<p>The Peric (1993) type definition is used for viscosity.</p> \\[ \\dfrac{\\gamma}{\\Delta{}t}=\\dot{\\gamma}=\\dfrac{1}{\\mu}\\left(\\left(\\dfrac{q}{k}\\right)^{\\dfrac{1}{\\epsilon}}-1\\right), \\] <p>where \\(\\(\\mu\\)\\) and \\(\\(\\epsilon\\)\\) are two material constants that controls viscosity. Note either (\\(\\mu\\)\\) or (\\(\\epsilon\\)\\) can be set to zero to disable rate-dependent response, in that case this model is identical to the Armstrong-Frederick model.</p> <p>Also note the Perzyna type definition, which is defined as</p> \\[ \\dfrac{\\gamma}{\\Delta{}t}=\\dot{\\gamma}=\\dfrac{1}{\\mu}\\left(\\dfrac{q}{k}-1\\right)^{\\dfrac{1}{\\epsilon}}, \\] <p>is not used. It shall in fact be avoided as it is less numerically stable than the Peric definition since it is not known whether \\(\\(\\dfrac{q}{k}-1\\)\\) is greater or smaller than \\(\\(1\\)\\).</p>"},{"location":"Library/Material/Material3D/vonMises/VAFCRP/#syntax","title":"Syntax","text":"Text Only<pre><code>material VAFCRP (1) (2) (3) (4) (5) (6) (7) (8) (9) [10 11...] [12]\n# (1) int, unique material tag\n# (2) double, elastic modulus\n# (3) double, poissons ratio\n# (4) double, yield stress\n# (5) double, saturated stress\n# (6) double, linear hardening modulus\n# (7) double, m\n# (8) double, mu\n# (9) double, epsilon\n# (10) double, a\n# (11) double, b\n# [12] double, density, default: 0.0\n</code></pre>"},{"location":"Library/Material/Material3D/vonMises/VAFCRP/#example","title":"Example","text":"<p>This model is essentially a viscous extension of the <code>ArmstrongFrederick</code> model. Only some different behavior is shown here.</p>"},{"location":"Library/Material/Material3D/vonMises/VAFCRP/#viscosity","title":"Viscosity","text":"<p>For static analysis with viscosity material, the step time is not analytical time anymore, it represents real time as it is used in the computation of viscous response. The step time shall be properly set to be consistent with the material parameters used in the model.</p> Text Only<pre><code>material VAFCRP 1 2E2 .2 .1 0. 0. 0. 1. 0. 50. 500. 100. 600.\nmaterial VAFCRP 2 2E2 .2 .1 0. 0. 0. 1. 10. 50. 500. 100. 600.\nmaterial VAFCRP 3 2E2 .2 .1 0. 0. 0. 1. 20. 50. 500. 100. 600.\nmaterial VAFCRP 4 2E2 .2 .1 0. 0. 0. 1. 50. 50. 500. 100. 600.\n</code></pre> <p></p>"},{"location":"Library/Material/Material3D/vonMises/VAFCRP/#relaxation","title":"Relaxation","text":"Text Only<pre><code>material VAFCRP 1 2E2 .2 .1 0. 0. 0. 1. 10.\n</code></pre>"},{"location":"Library/Material/Wrapper/Axisymmetric/","title":"Axisymmetric","text":"<p>Axisymmetric Wrapper</p>"},{"location":"Library/Material/Wrapper/Axisymmetric/#syntax","title":"Syntax","text":"Text Only<pre><code>material Axisymmetric (1) (2)\n# (1) int, unique tag\n# (2) int, 3D material tag\n</code></pre> <p>The response of attached 3D material model will be output when recorded.</p>"},{"location":"Library/Material/Wrapper/Laminated/","title":"Laminated","text":"<p>Parallel Wrapper For 2D Material Models</p>"},{"location":"Library/Material/Wrapper/Laminated/#syntax","title":"Syntax","text":"Text Only<pre><code>material Laminated (1) (2...)\n# (1) int, unique material tag\n# (2...) int, material tags of 2D models need to be contained\n</code></pre> <p>The response of attached 2D material models will be output when recorded. The output has the uniform size and data is arranged in the order as defined.</p>"},{"location":"Library/Material/Wrapper/Parallel/","title":"Parallel","text":"<p>Container of Material Models In Parallel</p>"},{"location":"Library/Material/Wrapper/Parallel/#syntax","title":"Syntax","text":"Text Only<pre><code>material Parallel (1) (2...)\n# (1) int, unique material tag\n# (2...) int, material tags of 1D models need to be contained\n</code></pre>"},{"location":"Library/Material/Wrapper/Parallel/#caveat","title":"Caveat","text":"<p>Please do not include any viscosity related models into the wrapper. This container is only designed for rate-independent hysteric models. The response of attached 1D material models will be output when recorded. The output has the uniform size and data is arranged in the order as defined.</p>"},{"location":"Library/Material/Wrapper/PlaneStrain/","title":"PlaneStrain","text":"<p>Plane Strain Wrapper</p>"},{"location":"Library/Material/Wrapper/PlaneStrain/#syntax","title":"Syntax","text":"Text Only<pre><code>material PlainStrain (1) (2)\n# (1) int, unique tag\n# (2) int, 3D material tag\n</code></pre> <p>The response of attached 3D material model will be output when recorded.</p>"},{"location":"Library/Material/Wrapper/PlaneStress/","title":"PlaneStress","text":"<p>Plane Stress Wrapper</p>"},{"location":"Library/Material/Wrapper/PlaneStress/#syntax","title":"Syntax","text":"Text Only<pre><code>material PlaneStress (1) (2)\n# (1) int, unique tag\n# (2) int, 3D material tag\n</code></pre> <p>The response of attached 3D material model will be output when recorded.</p>"},{"location":"Library/Material/Wrapper/PlaneSymmetric/","title":"PlaneSymmetric","text":"<p>Plane Symmetric Wrapper</p>"},{"location":"Library/Material/Wrapper/PlaneSymmetric/#syntax","title":"Syntax","text":"Text Only<pre><code>material PlaneSymmetric13 (1) (2)\nmaterial PlaneSymmetric23 (1) (2)\n# (1) int, unique material tag\n# (2) int, 3D reference material tag\n</code></pre>"},{"location":"Library/Material/Wrapper/PlaneSymmetric/#remarks","title":"Remarks","text":"<ol> <li>The token <code>PlaneSymmetric13</code> indicates \\(\\(\\sigma_{11}=\\sigma_{33}\\)\\) and \\(\\(\\tau_{12}=\\tau_{32}\\)\\).</li> <li>The token <code>PlaneSymmetric23</code> indicates \\(\\(\\sigma_{22}=\\sigma_{33}\\)\\) and \\(\\(\\tau_{12}=\\tau_{31}\\)\\).</li> </ol>"},{"location":"Library/Material/Wrapper/Rotation2D/","title":"Rotation2D","text":"<p>2D Rotation Wrapper</p>"},{"location":"Library/Material/Wrapper/Rotation2D/#syntax","title":"Syntax","text":"Text Only<pre><code>material Rotation2D (1) (2) (3)\n# (1) int, unique material tag\n# (2) int, associated material tag\n# (3) double, angle rotated (anti-clockwise positive)\n</code></pre> <p>The response of attached 2D material model will be output when recorded.</p>"},{"location":"Library/Material/Wrapper/Rotation3D/","title":"Rotation3D","text":"<p>3D Rotation Wrapper</p>"},{"location":"Library/Material/Wrapper/Rotation3D/#syntax","title":"Syntax","text":"Text Only<pre><code>material Rotation3D (1) (2) (3...5)\n# (1) int, unique material tag\n# (2) int, associated material tag\n# (3...5) double, three components of rotation vector\n</code></pre> <p>Rotations in 3D space may have different forms. The Euler vector is used to represent the axis and angle of rotation. Parameters <code>(3)</code> to <code>(5)</code> are three components of the vector \\(\\(\\mathbf{\\theta}\\)\\).</p> <p>The response of attached 3D material model will be output when recorded.</p>"},{"location":"Library/Material/Wrapper/Sequential/","title":"Sequential","text":"<p>Container of Material Models In Sequence</p>"},{"location":"Library/Material/Wrapper/Sequential/#syntax","title":"Syntax","text":"Text Only<pre><code>material Sequential (1) (2...)\n# (1) int, unique material tag\n# (2...) int, material tags of 1D models need to be contained\n</code></pre>"},{"location":"Library/Material/Wrapper/Sequential/#caveat","title":"Caveat","text":"<p>Please do not include any viscosity related models into the wrapper. This container is only designed for rate-independent hysteric models. The response of attached 1D material models will be output when recorded. The output has the uniform size and data is arranged in the order as defined.</p>"},{"location":"Library/Material/Wrapper/Stacked/","title":"Stacked","text":"<p>Parallel Wrapper For 3D Material Models</p>"},{"location":"Library/Material/Wrapper/Stacked/#syntax","title":"Syntax","text":"Text Only<pre><code>material Stacked (1) (2...)\n# (1) int, unique material tag\n# (2...) int, material tags of 3D models need to be contained\n</code></pre> <p>The response of attached 3D material models will be output when recorded. The output has the uniform size and data is arranged in the order as defined.</p>"},{"location":"Library/Material/Wrapper/Uniaxial/","title":"Uniaxial","text":"<p>Uniaxial Wrapper</p> Text Only<pre><code>material Uniaxial (1) (2) [3]\n# (1) int, unique material tag\n# (2) int, associated 3D material tag\n# [3] int, maximum iteration allowed, default: 1\n</code></pre> <p>The response of attached 3D material models will be output when recorded. The output has the uniform size and data is arranged in the order as defined.</p>"},{"location":"Library/Recorder/OutputFolder/","title":"Output Folder","text":"<p>By default, all recorders record files and store the data under the initial current working directory. The initial current working directory is the working directory where the main program is executed. Note that here initial is emphasized given the fact that users can use <code>pwd</code> command to change the current working directory.</p> <p>Internally, the output folder is managed by an independent path that is initialised to the current working directory when starting the program.</p> <p>What if we want to manage the output folder separately to better organise the recorded data? It is possible to do so by using the <code>output_folder</code> attribute.</p>"},{"location":"Library/Recorder/OutputFolder/#syntax","title":"Syntax","text":"Text Only<pre><code># check current output folder\npeek output_folder\n\n# change output folder\nset output_folder (1)\n# (1) string, absolute/relative path to the output folder\n</code></pre> <p>A few points to note:</p> <ol> <li>The program tries to create the given output folder it does not exist. The creation itself may fail. In case of any    failure, the output folder is not changed.</li> <li>The output folder can be either absolute or relative (to current output folder).</li> <li>A special token <code>$pwd</code> is available to set the output folder to the current working directory, which may have been    changed manually.</li> </ol>"},{"location":"Library/Recorder/OutputFolder/#example","title":"Example","text":"<p>The following are some examples to demonstrate the usage of the <code>output_folder</code> attribute.</p> Bash<pre><code># on entering, pwd and output_folder are set to the current working directory\nsuanPan ~&lt;&gt; pwd\n/home/theodore/Demo\nsuanPan ~&lt;&gt; peek output_folder\n/home/theodore/Demo\nsuanPan ~&lt;&gt; pwd ..\n# change pwd does not affect output_folder\nsuanPan ~&lt;&gt; pwd\n/home/theodore\nsuanPan ~&lt;&gt; peek output_folder\n/home/theodore/Demo\n# change output_folder, result-u folder will be created\nsuanPan ~&lt;&gt; set output_folder result-u\n/home/theodore/Demo/result-u\n# change to another folder, result-f folder will be created\nsuanPan ~&lt;&gt; set output_folder ../result-f\n/home/theodore/Demo/result-f\nsuanPan ~&lt;&gt; peek output_folder /home/theodore/Demo/result-f\n# change to pwd, which has been changed previously\nsuanPan ~&lt;&gt; set output_folder $pwd\n/home/theodore\n# change pwd and then set output_folder to pwd\nsuanPan ~&lt;&gt; pwd Demo\nsuanPan ~&lt;&gt; set output_folder $pwd\n/home/theodore/Demo\n# the following two folders are created by setting output_folder\nsuanPan ~&lt;&gt; terminal ls\nresult-f  result-u\nsuanPan ~&lt;&gt; exit\n</code></pre>"},{"location":"Library/Recorder/OutputFolder/#control-output-folder-for-recorders","title":"Control Output Folder For Recorders","text":"<p>The <code>output_folder</code> attribute is a global attribute that will be accessed by recorders when the <code>save</code> command is invoked. This means it is possible to set different folders for different recorders prior to save the data. The following is a simple example that shows how to store displacement and resistance data in different folders.</p> <p>The example model is an elastic cantilever beam with a point load at the free end.</p> Text Only<pre><code>node 1 0 0\nnode 2 1 0\n\nmaterial Elastic1D 1 10 1E-4\nsection Rectangle2D 1 12 1 1\nelement B21 1 1 2 1 6 1\n\nfix 1 P 1\ncload 1 0 10 2 2\n\nplainrecorder 1 Node U 1 2\nplainrecorder 2 Node RF 1 2\n\nstep static 1 1\nset ini_step_size .1\nset fixed_step_size true\n\nanalyze\n\n# when saving, change the output folder to result-u for displacement recorder\nset output_folder result-u\nsave recorder 1\n# change the output folder to result-f for resistance recorder\nset output_folder ../result-f\nsave recorder 2\n\nexit\n</code></pre> <p>Now when it is executed, two folders are created under the current working directory. For brevity, the <code>np</code> flag is used to suppress the output to screen.</p> Text Only<pre><code>$ tree\n.\n\u2514\u2500\u2500 B21.sp\n\n0 directories, 1 file\n$ suanpan -np -f ./B21.sp \n$ tree\n.\n\u251c\u2500\u2500 B21.sp\n\u251c\u2500\u2500 result-f\n\u2502         \u251c\u2500\u2500 R2-RF1.txt\n\u2502         \u2514\u2500\u2500 R2-RF2.txt\n\u2514\u2500\u2500 result-u\n    \u251c\u2500\u2500 R1-U1.txt\n    \u2514\u2500\u2500 R1-U2.txt\n\n2 directories, 5 files\n</code></pre>"},{"location":"Library/Recorder/OutputType/","title":"Output Type","text":"<p>Currently, the available types of output variables are listed as follows.</p> <p>Please note, in principle, it is possible to define any types on any recorders, but if the target recorder does not  support the type, trivial/empty values will be returns. If saving recorder does not create any files on the disk,  meaning that the output type is not available for the target object. For example, recording strain/stress <code>E</code>/<code>S</code>  values of any nodes is not possible and will lead to no output.</p> <p>The complete support list is still under development. In principle, basic types such as  displacement/velocity/acceleration are available for nodes. For elemental response, generally stress/strain and  their components are available. Some output types are only supported by certain elements. Please feel free to open  an issue if you need more information.</p> variable label physical meaning A all acceleration components A1 acceleration along DoF 1 A2 acceleration along DoF 2 A3 acceleration along DoF 3 A4 acceleration along DoF 4 A5 acceleration along DoF 5 A6 acceleration along DoF 6 AR rotation acceleration components AR1 rotation acceleration along DoF 1 AR2 rotation acceleration along DoF 2 AR3 rotation acceleration along DoF 3 AT translation acceleration AXIAL axial force DC compressive damage defined in CDP model DT tension damage defined in CDP model E all strain components E11 \\(\\(\\varepsilon_{11}\\)\\) E12 \\(\\(\\varepsilon_{12}\\)\\) E13 \\(\\(\\varepsilon_{13}\\)\\) E22 \\(\\(\\varepsilon_{22}\\)\\) E23 \\(\\(\\varepsilon_{23}\\)\\) E33 \\(\\(\\varepsilon_{33}\\)\\) ED damper strain defined in Maxwell model EE all elastic strain components EE11 \\(\\(\\varepsilon^e_{11}\\)\\) EE12 \\(\\(\\varepsilon^e_{12}\\)\\) EE13 \\(\\(\\varepsilon^e_{13}\\)\\) EE22 \\(\\(\\varepsilon^e_{22}\\)\\) EE23 \\(\\(\\varepsilon^e_{23}\\)\\) EE33 \\(\\(\\varepsilon^e_{33}\\)\\) EEEQ equivalent elastic strain EEP all principal elastic strain components EEP1 principal elastic strain component 1 EEP2 principal elastic strain component 2 EEP3 principal elastic strain component 3 EEQ equivalent strain EINT interpolation parameters of the strain field defined in (S)GCMQ element EP all principal strain components EP1 principal strain component 1 EP2 principal strain component 2 EP3 principal strain component 3 ES spring strain HYDRO hydrostatic stress K stiffness matrix KAPPAC \\(\\(\\kappa_c\\)\\) defined in CDP model KAPPAP KAPPAT \\(\\(\\kappa_t\\)\\) defined in CDP model KE kinetic energy LITR location iteration M mass matrix MISES von Mises stress MOMENT section moment MOMENTUM system momentum vector MOMENTUMX nodal/global momentum component 1 MOMENTUMY nodal/global momentum component 2 MOMENTUMZ nodal/global momentum component 3 MOMENTUMRX nodal/global momentum component 4 MOMENTUMRY nodal/global momentum component 5 MOMENTUMRZ nodal/global momentum component 6 NL NMISES averaged von Mises stress on element level PE all plastic strain components PE11 \\(\\(\\varepsilon^p_{11}\\)\\) PE12 \\(\\(\\varepsilon^p_{12}\\)\\) PE13 \\(\\(\\varepsilon^p_{13}\\)\\) PE22 \\(\\(\\varepsilon^p_{22}\\)\\) PE23 \\(\\(\\varepsilon^p_{23}\\)\\) PE33 \\(\\(\\varepsilon^p_{33}\\)\\) PEEQ equivalent plastic strain PEP all principal plastic strain components PEP1 principal plastic strain component 1 PEP2 principal plastic strain component 2 PEP3 principal plastic strain component 3 REBARE rebar strain REBARS rebar stress RESULTANT all resultant forces RF all reaction force components RF1 reaction force along DoF 1 RF2 reaction force along DoF 2 RF3 reaction force along DoF 3 RM all reaction moment components RM1 reaction moment along DoF 1 RM2 reaction moment along DoF 2 RM3 reaction moment along DoF 3 RT all translational reaction moment components DF all nodal damping force components DF1 damping force along DoF 1 DF2 damping force along DoF 2 DF3 damping force along DoF 3 DM1 damping force along DoF 4 DM2 damping force along DoF 5 DM3 damping force along DoF 6 IF all nodal inertial force components IF1 inertial force along DoF 1 IF2 inertial force along DoF 2 IF3 inertial force along DoF 3 IM1 inertial force along DoF 4 IM2 inertial force along DoF 5 IM3 inertial force along DoF 6 S all stress components S11 \\(\\(\\sigma_{11}\\)\\) S12 \\(\\(\\sigma_{12}\\)\\) S13 \\(\\(\\sigma_{13}\\)\\) S22 \\(\\(\\sigma_{22}\\)\\) S23 \\(\\(\\sigma_{23}\\)\\) S33 \\(\\(\\sigma_{33}\\)\\) SD damper stress SE strain energy SHEAR section shear force SINT interpolation parameters of the stress field defined in (S)GCMQ element SINV SP all principal stress components SP1 principal stress component 1 SP2 principal stress component 2 SP3 principal stress component 3 SS spring stress defined in Maxwell model TORSION TRESC Tresca stress U all displacement components U1 displacement along DoF 1 U2 displacement along DoF 2 U3 displacement along DoF 3 U4 displacement along DoF 4 U5 displacement along DoF 5 U6 displacement along DoF 6 UR all rotational displacement components UR1 rotational displacement along DoF 1 UR2 rotational displacement along DoF 2 UR3 rotational displacement along DoF 3 UT all translational displacement components V all velocity components V1 velocity along DoF 1 V2 velocity along DoF 2 V3 velocity along DoF 3 V4 velocity along DoF 4 V5 velocity along DoF 5 V6 velocity along DoF 6 VD damper velocity defined in Maxwell model VF void fraction defined in Gurson related models VR all angular velocity components VR1 angular velocity along DoF 1 VR2 angular velocity along DoF 2 VR3 angular velocity along DoF 3 VS VT"},{"location":"Library/Recorder/Recorder/","title":"Recorder","text":"<p>Record Model Response</p> <p>The available output types are listed in OutputType file.</p> <p>To control the folders to which the recorder will write the output, please check OutputFolder file.</p> <p>Not all quantities at every time step need to be stored. Only those explicitly specified will be stored as history output.</p> <p>Currently, there are several types of recorders. Analysts can choose to record either element response at integration points (strain, stress, etc., some elements support response at elemental nodes) or nodal response at model nodes (displacement, velocity, acceleration, reaction, etc.). The third type supports the output of the summation of the same quantity of several nodes/elements. Alternatively, analyst can recorder global quantities such as global stiffness/mass, global kinetic energy, etc.</p>"},{"location":"Library/Recorder/Recorder/#syntax","title":"Syntax","text":"<p>Two types of format are supported. The output file can be either plain text or HDF5 file if the program is compiled with HDF5 support. The general form to define a record is as follows.</p> Text Only<pre><code>recorder (1) plain (2) (3) [every 4] [5...]\nrecorder (1) hdf5 (2) (3) [every 4] [5...]\n# (1) int, unique recorder tag\n# (2) string, recorder type\n# (3) string, object type that needs to be recorded\n# [4] int, optional argument with leading keyword \"every\" to indicate the interval of recording, for example: \"every 10\" means the recorder will record the response every ten converged substeps.\n# [5...] int, tags of elements/nodes, etc.\n</code></pre> <p>Alternatively, it is possible to use the following two equivalences.</p> Text Only<pre><code>plainrecorder (1) (2) (3) [every 4] [5...]\nhdf5recorder (1) (2) (3) [every 4] [5...]\n</code></pre> <p>There are some recorder types that do not need tags of elements/nodes as they record the response of the whole model.</p>"},{"location":"Library/Recorder/Recorder/#eigen-recorder","title":"Eigen Recorder","text":"Text Only<pre><code># to record eigenvalues and eigenvectors if current step is an eigenanalysis step\nrecorder (1) plain Eigen\nrecorder (1) hdf5 Eigen\n# (1) int, unique recorder tag\n</code></pre>"},{"location":"Library/Recorder/Recorder/#frame-recorder","title":"Frame Recorder","text":"Text Only<pre><code># to record response of the whole model, this one only supports HDF5\nrecorder (1) hdf5 Frame (3) [every 4]\n# (1) int, unique recorder tag\n# (3) string, object type that needs to be recorded\n# [4] int, optional argument with leading keyword \"every\" to indicate the interval of recording, for example: \"every 10\" means the recorder will record the response every ten converged substeps.\n</code></pre>"},{"location":"Library/Recorder/Recorder/#visualization-recorder","title":"Visualization Recorder","text":"Text Only<pre><code># to record response of the whole model and write to VTK files for visualisation, this one is enabled only with VTK support.\nrecorder (1) plain Visualisation (3) [every 4]\nrecorder (1) hdf5 Visualisation (3) [every 4]\n# (1) int, unique recorder tag\n# (3) string, object type that needs to be recorded\n# [4] int, optional argument with leading keyword \"every\" to indicate the interval of recording, for example: \"every 10\" means the recorder will record the response every ten converged substeps.\n</code></pre> <p>The <code>Visualisation</code> will immediately write the disk with incremental file names.</p>"},{"location":"Library/Recorder/Recorder/#node-recorder","title":"Node Recorder","text":"<p>To record nodal response,</p> Text Only<pre><code>recorder (1) plain Node (3) [every 4] [5...]\nrecorder (1) hdf5 GroupNode (3) [every 4] [5...]\n# (1) int, unique recorder tag\n# (3) string, object type that needs to be recorded\n# [4] int, optional argument with leading keyword \"every\" to indicate the interval of recording, for example: \"every 10\" means the recorder will record the response every ten converged substeps.\n# [5...] int, tags of nodes or node groups, etc.\n</code></pre> <p>If <code>GroupNode</code> is used, then the tags of node groups shall be used.</p>"},{"location":"Library/Recorder/Recorder/#element-recorder","title":"Element Recorder","text":"<p>To record element response,</p> Text Only<pre><code>recorder (1) plain Element (3) [every 4] [5...]\nrecorder (1) hdf5 GroupElement (3) [every 4] [5...]\n# (1) int, unique recorder tag\n# (3) string, object type that needs to be recorded\n# [4] int, optional argument with leading keyword \"every\" to indicate the interval of recording, for example: \"every 10\" means the recorder will record the response every ten converged substeps.\n# [5...] int, tags of elements or element groups, etc.\n</code></pre> <p>If <code>GroupElement</code> is used, then the tags of element groups shall be used.</p>"},{"location":"Library/Recorder/Recorder/#global-recorder","title":"Global Recorder","text":"<p>Sometimes, it is necessary to record global quantities.</p> <p>Currently, it is possible to record energy quantities.</p> Text Only<pre><code>recorder (1) plain Global (3) [every 4]\nrecorder (1) hdf5 Global (3) [every 4]\n# (1) int, unique recorder tag\n# (3) string, object type that needs to be recorded\n# [4] int, optional argument with leading keyword \"every\" to indicate the interval of recording, for example: \"every 10\" means the recorder will record the response every ten converged substeps.\n</code></pre> <p>The <code>(3)</code> can be:</p> <ol> <li><code>KE</code>: kinetic energy</li> <li><code>SE</code>: strain energy (potential energy)</li> <li><code>VE</code>: energy dissipated via viscosity</li> <li><code>K</code>: global stiffness matrix, vectorised</li> <li><code>M</code>: global mass matrix, vectorised</li> </ol> <p>For energy terms, the recorder records two quantities computed from different sources: the first column is the summation of all corresponding energy terms collected from all valid elements; the second column is the global energy term.</p> <p>The reason to have two different columns is to mainly account for the fact that some models/theories may impose global level energy dissipation.</p> <p>A very direct example is the global damping models used in seismic engineering. Take the <code>Rayleigh</code> model as an example. Since it can be implemented in two ways, either apply linear combination of stiffness and mass at element level after computing elemental stiffness and mass (see Rayleigh <code>Modifier</code>), or globally after assembling global stiffness and mass (see <code>RayleighNewmark</code>). If the former is selected, each element can record its own energy dissipation term. If the latter is selected, the dissipated energy can only be computed from global stored quantities.</p> <p>Some other models cannot be applied at element level, resulting in missing energy if those energy terms are only collected from elements.</p> <p>As a rule of thumb, often two columns are equal to each other, if there is no global energy 'modifier'. Otherwise, there would be a difference between two columns. Depending on whether the elemental energy or global energy is under investigation, users can flexibly choose the columns to be compared.</p>"},{"location":"Library/Section/Code/EU/","title":"EU","text":"<p>Eurocode 3 Sections</p> Text Only<pre><code>section EU2D (1) (2) (3) [4] [5] [6]\n# (1) string, designation\n# (2) int, unique tag\n# (3) int, material model tag\n# [4] double, scale, default: 1.0\n# [5] int, number of integration points, default: 6\n# [6] double, eccentricity, default: 0.0\n\nsection EU3D (1) (2) (3) [4] [5] [6] [7]\n# (1) string, designation\n# (2) int, unique tag\n# (3) int, material model tag\n# [4] double, scale, default: 1.0\n# [5] int, number of integration points, default: 6\n# [6] double, eccentricity of y axis, default: 0.0\n# [7] double, eccentricity of z axis, default: 0.0\n</code></pre>"},{"location":"Library/Section/Code/EU/#remarks","title":"Remarks","text":"<ol> <li>By default, millimeter is used as length unit, if users wants to switch to another unit, set <code>scale</code> to corresponding    values. For example, to use meter, <code>scale=0.001</code>, to use inch, <code>scale=1/25.4=0.03937007874</code>.</li> </ol>"},{"location":"Library/Section/Code/EU/#supported-designations","title":"Supported Designations","text":"HEA HEB HEM IPE HEA100 HEB100 HEM100 IPE80 HEA120 HEB120 HEM120 IPE100 HEA140 HEB140 HEM140 IPE120 HEA160 HEB160 HEM160 IPE140 HEA180 HEB180 HEM180 IPE160 HEA200 HEB200 HEM200 IPE180 HEA220 HEB220 HEM220 IPE200 HEA240 HEB240 HEM240 IPE220 HEA260 HEB260 HEM260 IPE240 HEA280 HEB280 HEM280 IPE270 HEA300 HEB300 HEM300 IPE300 HEA320 HEB320 HEM320 IPE330 HEA340 HEB340 HEM340 IPE360 HEA360 HEB360 HEM360 IPE400 HEA400 HEB400 HEM400 IPE450 HEA450 HEB450 HEM450 IPE500 HEA500 HEB500 HEM500 IPE550 HEA550 HEB550 HEM550 IPE600 HEA600 HEB600 HEM600 HEA650 HEB650 HEM650 HEA700 HEB700 HEM700 HEA800 HEB800 HEM800 HEA900 HEB900 HEM900 HEA1000 HEB1000 HEM1000"},{"location":"Library/Section/Code/NZ/","title":"NZ","text":"<p>NZ Code Sections</p> <p>Sections in accordance with AS/NZ standards are available in both 2D and 3D applications.</p>"},{"location":"Library/Section/Code/NZ/#syntax","title":"Syntax","text":"<p>To define a section, analysts can use the following commands.</p> Text Only<pre><code>section NZ2D (1) (2) (3) [4] [5] [6]\n# (1) string, designation\n# (2) int, unique tag\n# (3) int, material model tag\n# [4] double, scale, default: 1.0\n# [5] int, number of integration points, default: 6\n# [6] double, eccentricity, default: 0.0\n\nsection NZ3D (1) (2) (3) [4] [5] [6] [7]\n# (1) string, designation\n# (2) int, unique tag\n# (3) int, material model tag\n# [4] double, scale, default: 1.0\n# [5] int, number of integration points, default: 6\n# [6] double, eccentricity of y axis, default: 0.0\n# [7] double, eccentricity of z axis, default: 0.0\n</code></pre>"},{"location":"Library/Section/Code/NZ/#remarks","title":"Remarks","text":"<ol> <li>By default, millimeter is used as length unit, if users wants to switch to another unit, set <code>scale</code> to corresponding    values. For example, to use meter, <code>scale=0.001</code>, to use inch, <code>scale=1/25.4=0.03937007874</code>.</li> <li>For 2D sections, the number of integration points is set to 2 using Gauss quadrature for flanges in I-sections.</li> <li>For 3D sections, along web/flange thickness, one integration point is used. along flange width and web height, the    same amount of integration points are used as defined by user.</li> </ol>"},{"location":"Library/Section/Code/NZ/#supported-designations","title":"Supported Designations","text":"<p>Currently, following designations are available.</p>"},{"location":"Library/Section/Code/NZ/#i-sections","title":"I-Sections","text":"<p><code>AS/NZ 3679.1:2016</code> and <code>AS/NZ 3679.2:2016</code></p> Welded Beams Welded Columns Universal Beams Universal Columns 1200WB455 500WC440 610UB125 320UC158 1200WB423 500WC414 610UB113 310UC137 1200WB392 500WC383 610UB101 310UC118 1200WB342 500WC340 530UB92.4 310UC96.8 1200WB317 500WC290 530UB82.0 250UC89.5 1200WB278 500WC267 460UB82.1 250UC72.9 1200WB249 500WC228 460UB74.6 200UC59.5 1000WB322 400WC361 460UB67.1 200UC52.2 1000WB296 400WC328 410UB59.7 200UC46.2 1000WB258 400WC303 410UB53.7 150UC37.2 1000WB215 400WC270 360UB56.7 150UC30.0 900WB282 400WC212 360UB50.7 150UC23.4 900WB257 400WC181 360UB44.7 100UC14.8 900WB218 400WC144 310UB46.2 900WB175 350WC280 310UB40.4 800WB192 350WC258 310UB32.0 800WB168 350WC230 250UB37.3 800WB146 350WC197 250UB31.4 800WB122 250UB25.7 700WB173 200UB29.8 700WB150 200UB25.4 700WB130 200UB22.3 700WB115 200UB18.2 180UB22.2 180UB18.1 180UB16.1 150UB18.0 150UB14.0"},{"location":"Library/Section/Code/NZ/#rectangularsquare-hollow-sections","title":"Rectangular/Square Hollow Sections","text":"<p>Note for hollow sections, due to FE idealization, the moment of inertia is larger than the one(s) shown in the standard. The difference can be as large as \\(\\(10\\%\\)\\).</p> <p><code>AS/NZS 1163:2016</code></p> RHS RHS SHS SHS 250X150X9.0RHS 75X50X4.0RHS 250X9.0SHS 65X3.0SHS 250X150X6.0RHS 75X50X3.0RHS 250X6.0SHS 65X2.5SHS 250X150X5.0RHS 75X50X2.5RHS 200X9.0SHS 65X2.0SHS 200X100X9.0RHS 75X50X2.0RHS 200X6.0SHS 50X4.0SHS 200X100X6.0RHS 75X25X2.5RHS 200X5.0SHS 50X3.0SHS 200X100X5.0RHS 75X25X2.0RHS 150X9.0SHS 50X2.5SHS 200X100X4.0RHS 75X25X1.6RHS 150X6.0SHS 50X2.0SHS 150X100X6.0RHS 65X35X3.0RHS 150X5.0SHS 50X1.6SHS 150X100X5.0RHS 65X35X2.5RHS 125X9.0SHS 40X4.0SHS 150X100X4.0RHS 65X35X2.0RHS 125X6.0SHS 40X2.5SHS 150X50X5.0RHS 50X25X3.0RHS 125X5.0SHS 40X2.0SHS 150X50X4.0RHS 50X25X2.5RHS 125X4.0SHS 40X1.6SHS 150X50X3.0RHS 50X25X2.0RHS 100X9.0SHS 35X3.0SHS 125X75X5.0RHS 50X25X1.6RHS 100X6.0SHS 35X2.5SHS 125X75X4.0RHS 50X20X3.0RHS 100X5.0SHS 35X2.0SHS 125X75X3.0RHS 50X20X2.5RHS 100X4.0SHS 35X1.6SHS 100X50X6.0RHS 50X20X2.0RHS 100X3.0SHS 30X2.0SHS 100X50X5.0RHS 50X20X1.6RHS 89X6.0SHS 30X1.6SHS 100X50X4.0RHS 89X5.0SHS 25X3.0SHS 100X50X3.5RHS 89X3.5SHS 25X2.5SHS 100X50X3.0RHS 75X6.0SHS 25X2.0SHS 100X50X2.5RHS 75X5.0SHS 25X1.6SHS 100X50X2.0RHS 75X4.0SHS 20X1.6SHS 75X3.5SHS 75X3.0SHS 75X2.5SHS"},{"location":"Library/Section/Code/NZ/#circular-hollow-sections","title":"Circular Hollow Sections","text":"<p><code>AS/NZS 1163:2016</code></p> CHS CHS CHS CHS 610.0X12.7CHS 76.1X5.9CHS 355.6X12.7CHS 139.7X3.5CHS 610.0X9.5CHS 76.1X4.5CHS 355.6X9.5CHS 139.7X3.0CHS 610.0X6.4CHS 76.1X3.6CHS 355.6X6.4CHS 114.3X6.0CHS 508.0X12.7CHS 60.3X5.4CHS 323.9X12.7CHS 114.3X4.8CHS 508.0X9.5CHS 60.3X4.5CHS 323.9X9.5CHS 114.3X3.6CHS 508.0X6.4CHS 60.3X3.6CHS 323.9X6.4CHS 114.3X3.2CHS 165.1X5.4CHS 48.3X5.4CHS 273.1X9.3CHS 101.6X3.2CHS 165.1X5.0CHS 48.3X4.0CHS 273.1X6.4CHS 101.6X2.6CHS 139.7X5.4CHS 48.3X3.2CHS 273.1X4.8CHS 88.9X5.5CHS 139.7X5.0CHS 42.4X4.9CHS 219.1X8.2CHS 88.9X4.8CHS 114.3X5.4CHS 42.4X4.0CHS 219.1X6.4CHS 88.9X3.2CHS 114.3X4.5CHS 42.4X3.2CHS 219.1X4.8CHS 88.9X2.6CHS 101.6X5.0CHS 457.0X12.7CHS 168.3X7.1CHS 76.1X3.2CHS 101.6X4.0CHS 457.0X9.5CHS 168.3X6.4CHS 76.1X2.3CHS 88.9X5.9CHS 457.0X6.4CHS 168.3X4.8CHS 88.9X5.0CHS 406.4X12.7CHS 165.1X3.5CHS 88.9X4.0CHS 406.4X9.5CHS 165.1X3.0CHS 406.4X6.4CHS"},{"location":"Library/Section/Code/US/","title":"US","text":""},{"location":"Library/Section/Code/US/#aisc","title":"AISC","text":"<p>A collection of <code>W</code>, <code>M</code>, <code>S</code>, <code>HP</code>, <code>WT</code>, <code>MT</code>, <code>ST</code> sections are predefined using inch as default length unit.</p>"},{"location":"Library/Section/Code/US/#syntax","title":"Syntax","text":"<p>To define a section, users can use the following commands.</p> Text Only<pre><code>section US2D (1) (2) (3) [4] [5] [6]\n# (1) string, designation\n# (2) int, unique tag\n# (3) int, material model tag\n# [4] double, scale, default: 1.0\n# [5] int, number of integration points along web height, default: 6\n# [6] double, eccentricity, default: 0.0\n\nsection US3D (1) (2) (3) [4] [5] [6] [7]\n# (1) string, designation\n# (2) int, unique tag\n# (3) int, material model tag\n# [4] double, scale, default: 1.0\n# [5] int, number of integration points along web height and flange width, default: 6\n# [6] double, eccentricity of y axis, default: 0.0\n# [7] double, eccentricity of z axis, default: 0.0\n</code></pre>"},{"location":"Library/Section/Code/US/#remarks","title":"Remarks","text":"<ol> <li>By default, inch is used as length unit, if users wants to switch to another unit, set <code>scale</code> to corresponding    values. For example, to use millimeter, <code>scale=25.4</code>.</li> <li>For 2D sections, the number of integration points is set to 2 using Gauss quadrature.</li> <li>For 3D sections, along web/flange thickness, one integration point is used. along flange width and web height, the    same amount of integration points are used as defined by user.</li> </ol>"},{"location":"Library/Section/Code/US/#supported-designations","title":"Supported Designations","text":"WT WT W W MT &amp; ST M &amp; S HP WT22X167.5 WT9X155.5 W44X335 W18X311 MT6.25X6.2 M12.5X12.4 HP18X204 WT22X145 WT9X141.5 W44X290 W18X283 MT6.25X5.8 M12.5X11.6 HP18X181 WT22X131 WT9X129 W44X262 W18X258 MT6X5.9 M12X11.8 HP18X157 WT22X115 WT9X117 W44X230 W18X234 MT6X5.4 M12X10.8 HP18X135 WT20X327.5 WT9X105.5 W40X655 W18X211 MT6X5 M12X10 HP16X183 WT20X296.5 WT9X96 W40X593 W18X192 MT5X4.5 M10X9 HP16X162 WT20X251.5 WT9X87.5 W40X503 W18X175 MT5X4 M10X8 HP16X141 WT20X215.5 WT9X79 W40X431 W18X158 MT5X3.75 M10X7.5 HP16X121 WT20X198.5 WT9X71.5 W40X397 W18X143 MT4X3.25 M8X6.5 HP16X101 WT20X186 WT9X65 W40X372 W18X130 MT4X3.1 M8X6.2 HP16X88 WT20X181 WT9X59.5 W40X362 W18X119 MT3X2.2 M6X4.4 HP14X117 WT20X162 WT9X53 W40X324 W18X106 MT3X1.85 M6X3.7 HP14X102 WT20X148.5 WT9X48.5 W40X297 W18X97 MT2.5X9.45 M5X18.9 HP14X89 WT20X138.5 WT9X43 W40X277 W18X86 MT2X3 M4X6 HP14X73 WT20X124.5 WT9X38 W40X249 W18X76 ST12X60.5 M4X4.08 HP12X89 WT20X107.5 WT9X35.5 W40X215 W18X71 ST12X53 M4X3.45 HP12X84 WT20X99.5 WT9X32.5 W40X199 W18X65 ST12X50 M4X3.2 HP12X74 WT20X196 WT9X30 W40X392 W18X60 ST12X45 M3X2.9 HP12X63 WT20X165.5 WT9X27.5 W40X331 W18X55 ST12X40 S24X121 HP12X53 WT20X163.5 WT9X25 W40X327 W18X50 ST10X48 S24X106 HP10X57 WT20X147 WT9X23 W40X294 W18X46 ST10X43 S24X100 HP10X42 WT20X139 WT9X20 W40X278 W18X40 ST10X37.5 S24X90 HP8X36 WT20X132 WT9X17.5 W40X264 W18X35 ST10X33 S24X80 WT20X117.5 WT8X50 W40X235 W16X100 ST9X35 S20X96 WT20X105.5 WT8X44.5 W40X211 W16X89 ST9X27.35 S20X86 WT20X91.5 WT8X38.5 W40X183 W16X77 ST7.5X25 S20X75 WT20X83.5 WT8X33.5 W40X167 W16X67 ST7.5X21.45 S20X66 WT20X74.5 WT8X28.5 W40X149 W16X57 ST6X25 S18X70 WT18X462.5 WT8X25 W36X925 W16X50 ST6X20.4 S18X54.7 WT18X426.5 WT8X22.5 W36X853 W16X45 ST6X17.5 S15X50 WT18X401 WT8X20 W36X802 W16X40 ST6X15.9 S15X42.9 WT18X361.5 WT8X18 W36X723 W16X36 ST5X17.5 S12X50 WT18X326 WT8X15.5 W36X652 W16X31 ST5X12.7 S12X40.8 WT18X264.5 WT8X13 W36X529 W16X26 ST4X11.5 S12X35 WT18X243.5 WT7X436.5 W36X487 W14X873 ST4X9.2 S12X31.8 WT18X220.5 WT7X404 W36X441 W14X808 ST3X8.6 S10X35 WT18X197.5 WT7X365 W36X395 W14X730 ST3X6.25 S10X25.4 WT18X180.5 WT7X332.5 W36X361 W14X665 ST2.5X5 S8X23 WT18X165 WT7X302.5 W36X330 W14X605 ST2X4.75 S8X18.4 WT18X151 WT7X275 W36X302 W14X550 ST2X3.85 S6X17.25 WT18X141 WT7X250 W36X282 W14X500 ST1.5X3.75 S6X12.5 WT18X131 WT7X227.5 W36X262 W14X455 ST1.5X2.85 S5X10 WT18X123.5 WT7X213 W36X247 W14X426 S4X9.5 WT18X115.5 WT7X199 W36X231 W14X398 S4X7.7 WT18X128 WT7X185 W36X256 W14X370 S3X7.5 WT18X116 WT7X171 W36X232 W14X342 S3X5.7 WT18X105 WT7X155.5 W36X210 W14X311 WT18X97 WT7X141.5 W36X194 W14X283 WT18X91 WT7X128.5 W36X182 W14X257 WT18X85 WT7X116.5 W36X170 W14X233 WT18X80 WT7X105.5 W36X160 W14X211 WT18X75 WT7X96.5 W36X150 W14X193 WT18X67.5 WT7X88 W36X135 W14X176 WT16.5X193.5 WT7X79.5 W33X387 W14X159 WT16.5X177 WT7X72.5 W33X354 W14X145 WT16.5X159 WT7X66 W33X318 W14X132 WT16.5X145.5 WT7X60 W33X291 W14X120 WT16.5X131.5 WT7X54.5 W33X263 W14X109 WT16.5X120.5 WT7X49.5 W33X241 W14X99 WT16.5X110.5 WT7X45 W33X221 W14X90 WT16.5X100.5 WT7X41 W33X201 W14X82 WT16.5X84.5 WT7X37 W33X169 W14X74 WT16.5X76 WT7X34 W33X152 W14X68 WT16.5X70.5 WT7X30.5 W33X141 W14X61 WT16.5X65 WT7X26.5 W33X130 W14X53 WT16.5X59 WT7X24 W33X118 W14X48 WT15X195.5 WT7X21.5 W30X391 W14X43 WT15X178.5 WT7X19 W30X357 W14X38 WT15X163 WT7X17 W30X326 W14X34 WT15X146 WT7X15 W30X292 W14X30 WT15X130.5 WT7X13 W30X261 W14X26 WT15X117.5 WT7X11 W30X235 W14X22 WT15X105.5 WT6X168 W30X211 W12X336 WT15X95.5 WT6X152.5 W30X191 W12X305 WT15X86.5 WT6X139.5 W30X173 W12X279 WT15X74 WT6X126 W30X148 W12X252 WT15X66 WT6X115 W30X132 W12X230 WT15X62 WT6X105 W30X124 W12X210 WT15X58 WT6X95 W30X116 W12X190 WT15X54 WT6X85 W30X108 W12X170 WT15X49.5 WT6X76 W30X99 W12X152 WT15X45 WT6X68 W30X90 W12X136 WT13.5X269.5 WT6X60 W27X539 W12X120 WT13.5X184 WT6X53 W27X368 W12X106 WT13.5X168 WT6X48 W27X336 W12X96 WT13.5X153.5 WT6X43.5 W27X307 W12X87 WT13.5X140.5 WT6X39.5 W27X281 W12X79 WT13.5X129 WT6X36 W27X258 W12X72 WT13.5X117.5 WT6X32.5 W27X235 W12X65 WT13.5X108.5 WT6X29 W27X217 W12X58 WT13.5X97 WT6X26.5 W27X194 W12X53 WT13.5X89 WT6X25 W27X178 W12X50 WT13.5X80.5 WT6X22.5 W27X161 W12X45 WT13.5X73 WT6X20 W27X146 W12X40 WT13.5X64.5 WT6X17.5 W27X129 W12X35 WT13.5X57 WT6X15 W27X114 W12X30 WT13.5X51 WT6X13 W27X102 W12X26 WT13.5X47 WT6X11 W27X94 W12X22 WT13.5X42 WT6X9.5 W27X84 W12X19 WT12X185 WT6X8 W24X370 W12X16 WT12X167.5 WT6X7 W24X335 W12X14 WT12X153 WT5X56 W24X306 W10X112 WT12X139.5 WT5X50 W24X279 W10X100 WT12X125 WT5X44 W24X250 W10X88 WT12X114.5 WT5X38.5 W24X229 W10X77 WT12X103.5 WT5X34 W24X207 W10X68 WT12X96 WT5X30 W24X192 W10X60 WT12X88 WT5X27 W24X176 W10X54 WT12X81 WT5X24.5 W24X162 W10X49 WT12X73 WT5X22.5 W24X146 W10X45 WT12X65.5 WT5X19.5 W24X131 W10X39 WT12X58.5 WT5X16.5 W24X117 W10X33 WT12X52 WT5X15 W24X104 W10X30 WT12X51.5 WT5X13 W24X103 W10X26 WT12X47 WT5X11 W24X94 W10X22 WT12X42 WT5X9.5 W24X84 W10X19 WT12X38 WT5X8.5 W24X76 W10X17 WT12X34 WT5X7.5 W24X68 W10X15 WT12X31 WT5X6 W24X62 W10X12 WT12X27.5 WT4X33.5 W24X55 W8X67 WT10.5X137.5 WT4X29 W21X275 W8X58 WT10.5X124 WT4X24 W21X248 W8X48 WT10.5X111.5 WT4X20 W21X223 W8X40 WT10.5X100.5 WT4X17.5 W21X201 W8X35 WT10.5X91 WT4X15.5 W21X182 W8X31 WT10.5X83 WT4X14 W21X166 W8X28 WT10.5X73.5 WT4X12 W21X147 W8X24 WT10.5X66 WT4X10.5 W21X132 W8X21 WT10.5X61 WT4X9 W21X122 W8X18 WT10.5X55.5 WT4X7.5 W21X111 W8X15 WT10.5X50.5 WT4X6.5 W21X101 W8X13 WT10.5X46.5 WT4X5 W21X93 W8X10 WT10.5X41.5 WT3X12.5 W21X83 W6X25 WT10.5X36.5 WT3X10 W21X73 W6X20 WT10.5X34 WT3X7.5 W21X68 W6X15 WT10.5X31 WT3X8 W21X62 W6X16 WT10.5X27.5 WT3X6 W21X55 W6X12 WT10.5X24 WT3X4.5 W21X48 W6X9 WT10.5X28.5 WT3X4.25 W21X57 W6X8.5 WT10.5X25 WT2.5X9.5 W21X50 W5X19 WT10.5X22 WT2.5X8 W21X44 W5X16 WT2X6.5 W4X13"},{"location":"Library/Section/Section1D/Circle1D/","title":"Circle1D","text":"<p>1D Circle Section</p>"},{"location":"Library/Section/Section1D/Circle1D/#syntax","title":"Syntax","text":"Text Only<pre><code>section Circle1D (1) (2) (3)\n# (1) int, unique section tag\n# (2) double, radius\n# (3) int, material tag\n</code></pre>"},{"location":"Library/Section/Section1D/Fibre1D/","title":"Fibre1D","text":"<p>1D Fibre Section</p>"},{"location":"Library/Section/Section1D/Fibre1D/#syntax","title":"Syntax","text":"Text Only<pre><code>section Fibre1D (1) [(2)...]\n# (1) int, unique section tag\n# [(2)...] int, associated section tags\n</code></pre>"},{"location":"Library/Section/Section1D/Rectangle1D/","title":"Rectangle1D","text":"<p>1D Rectangle Section</p>"},{"location":"Library/Section/Section1D/Rectangle1D/#syntax","title":"Syntax","text":"Text Only<pre><code>section Rectangle1D (1) (2) (3) (4)\n# (1) int, unique section tag\n# (2) double, section width\n# (3) double, section height\n# (4) int, material tag\n</code></pre>"},{"location":"Library/Section/Section1D/TrussSection/","title":"TrussSection","text":"<p>1D Truss Section</p>"},{"location":"Library/Section/Section1D/TrussSection/#syntax","title":"Syntax","text":"Text Only<pre><code>section TrussSection (1) (2) (3)\n# (1) int, unique section tag\n# (2) double, section area\n# (3) int, material tag\n</code></pre>"},{"location":"Library/Section/Section2D/Bar2D/","title":"Bar2D","text":"<p>2D Reinforcing Bar Section</p>"},{"location":"Library/Section/Section2D/Bar2D/#syntax","title":"Syntax","text":"Text Only<pre><code>section Bar2D (1) (2) (3) [4]\n# (1) int, unique section tag\n# (2) double, area\n# (3) int, material tag\n# [4] double, eccentricity, default: 0.0\n</code></pre>"},{"location":"Library/Section/Section2D/Box2D/","title":"Box2D","text":"<p>2D Box Section</p>"},{"location":"Library/Section/Section2D/Box2D/#syntax","title":"Syntax","text":"Text Only<pre><code>section Box2D (1) (2) (3) (4) (5) [6] [7]\n# (1) int, unique section tag\n# (2) double, width\n# (3) double, height\n# (4) double, thickness\n# (5) int, material tag\n# [6] int, number of integration points, default: 6\n# [7] double, eccentricity, default: 0.0\n</code></pre>"},{"location":"Library/Section/Section2D/Circle2D/","title":"Circle2D","text":"<p>2D Circle Section</p>"},{"location":"Library/Section/Section2D/Circle2D/#syntax","title":"Syntax","text":"Text Only<pre><code>section Circle2D (1) (2) (3) [4] [5]\n# (1) int, unique section tag\n# (2) double, radius\n# (3) int, material tag\n# [4] int, number of integration points, default: 6\n# [5] double, eccentricity, default: 0.0\n</code></pre>"},{"location":"Library/Section/Section2D/CircularHollow2D/","title":"CircularHollow2D","text":"<p>2D Hollow Circular Section</p>"},{"location":"Library/Section/Section2D/CircularHollow2D/#syntax","title":"Syntax","text":"Text Only<pre><code>section CircularHollow2D (1) (2) (3) (4) [5] [6]\n# (1) int, unique section tag\n# (2) double, radius\n# (3) double, thickness\n# (4) int, material tag\n# [5] int, number of integration points, default: 10\n# [6] double, eccentricity, default: 0.0\n</code></pre>"},{"location":"Library/Section/Section2D/Fibre2D/","title":"Fibre2D","text":"<p>2D Fibre Section</p>"},{"location":"Library/Section/Section2D/Fibre2D/#syntax","title":"Syntax","text":"Text Only<pre><code>section Fibre2D (1) [(2)...]\n# (1) int, unique section tag\n# [(2)...] int, associated section tags\n</code></pre>"},{"location":"Library/Section/Section2D/HSection2D/","title":"HSection2D","text":"<p>2D H-Section</p>"},{"location":"Library/Section/Section2D/HSection2D/#syntax","title":"Syntax","text":"Text Only<pre><code>section HSection2D (1) (2...7) (8) [9] [10]\n# (1) int, unique tag\n# (2...7) double, section dimensions\n# (8) int, material tag\n# [9] int, number of integration points, default: 6\n# [10] double, eccentricity measured from the centre, default: 0.0\n</code></pre>"},{"location":"Library/Section/Section2D/HSection2D/#remarks","title":"Remarks","text":"<ol> <li>Section dimensions are:</li> <li><code>(2)</code> left flange height</li> <li><code>(3)</code> left flange thickness</li> <li><code>(4)</code> right flange height</li> <li><code>(5)</code> right flange thickness</li> <li><code>(6)</code> web width</li> <li><code>(7)</code> web thickness</li> </ol>"},{"location":"Library/Section/Section2D/ISection2D/","title":"ISection2D","text":"<p>2D I-Section</p>"},{"location":"Library/Section/Section2D/ISection2D/#syntax","title":"Syntax","text":"Text Only<pre><code>section ISection2D (1) (2...7) (8) [9] [10]\n# (1) int, unique tag\n# (2...7) double, section dimensions\n# (8) int, material tag\n# [9] int, number of integration points, default: 6\n# [10] double, eccentricity measured from the centre, default: 0.0\n</code></pre>"},{"location":"Library/Section/Section2D/ISection2D/#remarks","title":"Remarks","text":"<ol> <li>Section dimensions are:</li> <li><code>(2)</code> top flange height</li> <li><code>(3)</code> top flange thickness</li> <li><code>(4)</code> bottom flange height</li> <li><code>(5)</code> bottom flange thickness</li> <li><code>(6)</code> web width</li> <li><code>(7)</code> web thickness</li> </ol>"},{"location":"Library/Section/Section2D/Rectangle2D/","title":"Rectangle2D","text":"<p>2D Rectangle Section</p>"},{"location":"Library/Section/Section2D/Rectangle2D/#syntax","title":"Syntax","text":"Text Only<pre><code>section Rectangle2D (1) (2) (3) (4) [5] [6]\n# (1) int, unique tag\n# (2) double, section width\n# (3) double, section height\n# (4) int, material tag\n# [5] int, number of integration points, default: 6\n# [6] double, eccentricity measured from the centre, default: 0.0\n</code></pre>"},{"location":"Library/Section/Section2D/TSection2D/","title":"TSection2D","text":"<p>2D T-Section</p>"},{"location":"Library/Section/Section2D/TSection2D/#syntax","title":"Syntax","text":"Text Only<pre><code>section TSection2D (1) (2...5) (6) [7] [8]\n# (1) int, unique tag\n# (2...5) double, section dimensions\n# (6) int, material tag\n# [7] int, number of integration points, default: 6\n# [8] double, eccentricity measured from the centre, default: 0.0\n</code></pre>"},{"location":"Library/Section/Section2D/TSection2D/#remarks","title":"Remarks","text":"<ol> <li>Section dimensions are:</li> <li><code>(2)</code> top flange height</li> <li><code>(3)</code> top flange thickness</li> <li><code>(4)</code> web width</li> <li><code>(5)</code> web thickness</li> <li>By default, the flange is at top.</li> </ol>"},{"location":"Library/Section/Section3D/Bar3D/","title":"Bar3D","text":"<p>3D Reinforcing Bar Section</p>"},{"location":"Library/Section/Section3D/Bar3D/#syntax","title":"Syntax","text":"Text Only<pre><code>section Bar3D (1) (2) (3) [4] [5]\n# (1) int, unique section tag\n# (2) double, area\n# (3) int, material tag\n# [4] double, eccentricity along y axis, default: 0.0\n# [5] double, eccentricity along z axis, default: 0.0\n</code></pre>"},{"location":"Library/Section/Section3D/Box3D/","title":"Box3D","text":"<p>3D Box Section</p>"},{"location":"Library/Section/Section3D/Box3D/#syntax","title":"Syntax","text":"Text Only<pre><code>section Box3D (1) (2) (3) (4) (5) [6] [7] [8]\n# (1) int, unique section tag\n# (2) double, width\n# (3) double, height\n# (4) double, thickness\n# (5) int, material tag\n# [6] int, number of integration points, default: 3\n# [7] double, eccentricity along y axis, default: 0.0\n# [8] double, eccentricity along z axis, default: 0.0\n</code></pre>"},{"location":"Library/Section/Section3D/Circle3D/","title":"Circle3D","text":"<p>3D Circle Section</p>"},{"location":"Library/Section/Section3D/Circle3D/#syntax","title":"Syntax","text":"Text Only<pre><code>section Circle3D (1) (2) (3) [4] [5] [6]\n# (1) int, unique section tag\n# (2) double, radius\n# (3) int, material tag\n# [4] int, number of integration points, default: 6\n# [5] double, eccentricity along y axis, default: 0.0\n# [6] double, eccentricity along z axis, default: 0.0\n</code></pre>"},{"location":"Library/Section/Section3D/CircularHollow3D/","title":"CircleHollow3D","text":"<p>3D Hollow Circle Section</p>"},{"location":"Library/Section/Section3D/CircularHollow3D/#syntax","title":"Syntax","text":"Text Only<pre><code>section CircularHollow3D (1) (2) (3) (4) [5] [6] [7]\n# (1) int, unique section tag\n# (2) double, radius\n# (3) double, thickness\n# (4) int, material tag\n# [5] int, number of integration points, default: 10\n# [6] double, eccentricity along y axis, default: 0.0\n# [7] double, eccentricity along z axis, default: 0.0\n</code></pre>"},{"location":"Library/Section/Section3D/Fibre3D/","title":"Fibre3D","text":"<p>3D Fibre Section</p>"},{"location":"Library/Section/Section3D/Fibre3D/#syntax","title":"Syntax","text":"Text Only<pre><code>section Fibre3D (1) [(2)...]\n# (1) int, unique section tag\n# [(2)...] int, associated section tags\n</code></pre>"},{"location":"Library/Section/Section3D/ISection3D/","title":"ISection3D","text":"<p>3D I-Section</p>"},{"location":"Library/Section/Section3D/ISection3D/#syntax","title":"Syntax","text":"Text Only<pre><code>section ISection3D (1) (2) (3) (4) (5) (6) (7) (8) [9] [10] [11]\n# (1) int, unique section tag\n# (2) double, top flange width\n# (3) double, top flange thickness\n# (4) double, bottom flange width\n# (5) double, bottom flange thickness\n# (6) double, web height\n# (7) double, web thickness\n# (8) int, material tag\n# [9] int, number of integration points, default: 3\n# [10] double, eccentricity along y axis, default: 0.0\n# [11] double, eccentricity along z axis, default: 0.0\n</code></pre>"},{"location":"Library/Section/Section3D/ISection3D/#remarks","title":"Remarks","text":"<ol> <li>The flange/web is assumed to be slender. Thus, only one integration point is assigned across the thickness. The web,    top flange and bottom flange share the same number of integration points over the height/width no matter how    wide/tall the section is.</li> </ol>"},{"location":"Library/Section/Section3D/Rectangle3D/","title":"Rectangle3D","text":"<p>3D Rectangle Section</p>"},{"location":"Library/Section/Section3D/Rectangle3D/#syntax","title":"Syntax","text":"Text Only<pre><code>section Rectangle3D (1) (2) (3) (4) [5] [6] [7]\n# (1) int, unique section tag\n# (2) double, section width\n# (3) double, section height\n# (4) int, material tag\n# [5] int, number of integration points, default: 3\n# [6] double, eccentricity along y axis, default: 0.0\n# [7] double, eccentricity along z axis, default: 0.0\n</code></pre>"},{"location":"Library/Section/Section3D/TSection3D/","title":"TSection3D","text":"<p>3D T-Section</p>"},{"location":"Library/Section/Section3D/TSection3D/#syntax","title":"Syntax","text":"Text Only<pre><code>section TSection3D (1) (2) (3) (4) (5) (6) [7] [8] [9]\n# (1) int, unique section tag\n# (2) double, top flange width\n# (3) double, top flange thickness\n# (4) double, web height\n# (5) double, web thickness\n# (6) int, material tag\n# [7] int, number of integration points, default: 3\n# [8] double, eccentricity along y axis, default: 0.0\n# [9] double, eccentricity along z axis, default: 0.0\n</code></pre>"},{"location":"Library/Section/Section3D/TSection3D/#remarks","title":"Remarks","text":"<ol> <li>The flange/web is assumed to be slender. Thus, only one integration point is assigned across the thickness. The web,    top flange and bottom flange share the same number of integration points over the height/width no matter how    wide/tall the section is.</li> </ol>"},{"location":"Library/Section/SectionNM/NM2D1/","title":"NM2D1","text":"<p>\\(\\(N\\)\\)-\\(\\(M\\)\\) Interaction Elastic Section</p>"},{"location":"Library/Section/SectionNM/NM2D1/#syntax","title":"Syntax","text":"Text Only<pre><code>section NM2D1 (1) (2) (3) (4)\n# (1) int, unique section tag\n# (2) double, EA\n# (3) double, EI\n# (4) double, linear density\n</code></pre>"},{"location":"Library/Section/SectionNM/NM2D2/","title":"NM2D2","text":"<p>\\(\\(N\\)\\)-\\(\\(M\\)\\) Interaction Inelastic Section</p>"},{"location":"Library/Section/SectionNM/NM2D2/#reference","title":"Reference","text":"<ol> <li>10.1007/978-94-007-6573-3_3</li> <li>10.1002/nme.1620371506</li> </ol>"},{"location":"Library/Section/SectionNM/NM2D2/#syntax","title":"Syntax","text":""},{"location":"Library/Section/SectionNM/NM2D2/#option-one","title":"Option One","text":"Text Only<pre><code>section NM2D2 (1) (2...9)\n# (1) int, unique section tag\n# (2) double, EA\n# (3) double, EI\n# (4) double, yielding axial force\n# (5) double, yielding strong axis moment\n# (6) double, c\n# (7) double, isotropic hardening parameter H\n# (8) double, kinematic hardening parameter K\n# (9) double, linear density\n</code></pre> <p>If the <code>NM2D2</code> section is defined by using the above command, it is assumed that the \\(\\(N\\)\\)-\\(\\(M\\)\\) interaction surface is defined as follows.</p> \\[ f=1.15p^2+m_s^2+3.67p^2m_s^2-c \\] <p>where \\(\\(p\\)\\) and \\(\\(m_s\\)\\) are normalised axial force and moment (about strong axis). The surface is suitable for I-sections.</p>"},{"location":"Library/Section/SectionNM/NM2D2/#option-two","title":"Option Two","text":"<p>One may wish to customise the surface by assigning different weights and orders, it is possible by using the following syntax.</p> Text Only<pre><code>section NM2D2 (1) (2...9) [(10 11 12)...]\n# (1) int, unique section tag\n# (2) double, EA\n# (3) double, EI\n# (4) double, yielding axial force\n# (5) double, yielding strong axis moment\n# (6) double, d\n# (7) double, isotropic hardening parameter H\n# (8) double, kinematic hardening parameter K\n# (9) double, linear density\n# (10) double, a_i\n# (11) double, b_i\n# (12) double, c_i\n</code></pre> <p>In the above command, parameters <code>(10)</code>, <code>(11)</code> and <code>(12)</code> form a triplet and can be appended as many groups as analyst wishes. The surface is assumed to possess the following form,</p> \\[ f=\\sum_{i=1}^na_ip^{b_i}m_s^{c_i}-d. \\] <p>For example, the previous surface \\(\\(f=1.15p^2+m_s^2+3.67p^2m_s^2-c\\)\\) can be equivalently expressed with the second syntax as follows.</p> Text Only<pre><code>section NM2D2 (1) (2...9) 1.15 2. 0. 1. 0. 2. 3.67 2. 2.\n</code></pre> <p>The only validation implemented is the number of triplets. The command takes \\(\\(3n\\)\\) parameters and interprets them accordingly. Please make sure the definition is correct.</p>"},{"location":"Library/Section/SectionNM/NM2D2/#remarks","title":"Remarks","text":"<p>The true hardening ratio is defined as</p> \\[ \\dfrac{H+K}{1+H+K}, \\] <p>given that \\(\\(H\\)\\) and \\(\\(K\\)\\) are hardening ratios based on plastic strain.</p>"},{"location":"Library/Section/SectionNM/NM3D1/","title":"NM3D1","text":"<p>\\(\\(N\\)\\)-\\(\\(M\\)\\) Interaction Elastic Section</p>"},{"location":"Library/Section/SectionNM/NM3D1/#syntax","title":"Syntax","text":"Text Only<pre><code>section NM3D1 (1) (2) (3) (4)\n# (1) int, unique section tag\n# (2) double, EA\n# (3) double, EI of strong axis\n# (4) double, EI of weak axis\n# (5) double, linear density\n</code></pre>"},{"location":"Library/Section/SectionNM/NM3D2/","title":"NM3D2","text":"<p>\\(\\(N\\)\\)-\\(\\(M\\)\\) Interaction Inelastic Section</p>"},{"location":"Library/Section/SectionNM/NM3D2/#reference","title":"Reference","text":"<ol> <li>10.1007/978-94-007-6573-3_3</li> <li>10.1002/nme.1620371506</li> </ol>"},{"location":"Library/Section/SectionNM/NM3D2/#syntax","title":"Syntax","text":""},{"location":"Library/Section/SectionNM/NM3D2/#option-one","title":"Option One","text":"Text Only<pre><code>section NM3D2 (1) (2...11)\n# (1) int, unique section tag\n# (2) double, EA\n# (3) double, strong axis EI\n# (4) double, weak axis EI\n# (5) double, yielding axial force\n# (6) double, yielding strong axis moment\n# (7) double, yielding weak axis moment\n# (8) double, c\n# (9) double, isotropic hardening parameter H\n# (10) double, kinematic hardening parameter K\n# (11) double, linear density\n</code></pre> <p>The \\(\\(N\\)\\)-\\(\\(M\\)\\) interaction surface is defined as follows.</p> \\[ f=1.15p^2+m_s^2+m_w^4+3.67p^2m_s^2+3p^6m_w^2+4.65m_s^4m_w^2-c \\] <p>where \\(\\(p\\)\\), \\(\\(m_s\\)\\) and \\(\\(m_w\\)\\) are normalised axial force and moments about strong and weak axes. The surface is suitable for I-sections.</p>"},{"location":"Library/Section/SectionNM/NM3D2/#option-two","title":"Option Two","text":"<p>One may wish to customise the surface by assigning different weights and orders, it is possible by using the following syntax.</p> Text Only<pre><code>section NM3D2 (1) (2...11) [(12 13 14 15)...]\n# (1) int, unique section tag\n# (2) double, EA\n# (3) double, strong axis EI\n# (4) double, weak axis EI\n# (5) double, yielding axial force\n# (6) double, yielding strong axis moment\n# (7) double, yielding weak axis moment\n# (8) double, c\n# (9) double, isotropic hardening parameter H\n# (10) double, kinematic hardening parameter K\n# (11) double, linear density\n# (12) double, a_i\n# (13) double, b_i\n# (14) double, c_i\n# (15) double, d_i\n</code></pre> <p>In the above command, parameters <code>(12)</code>, <code>(13)</code>, <code>(14)</code> and <code>(15)</code> form a set of parameters and can be appended as many groups as analyst wishes. The surface is assumed to possess the following form,</p> \\[ f=\\sum_{i=1}^na_ip^{b_i}m_s^{c_i}m_w^{d_i}-e. \\] <p>For example, the previous surface \\(\\(f=1.15p^2+m_s^2+m_w^4+3.67p^2m_s^2+3p^6m_w^2+4.65m_s^4m_w^2-c\\)\\) can be equivalently expressed with the second syntax as follows.</p> Text Only<pre><code>section NM3D2 (1) (2...11) 1.15 2. 0. 0. 1. 0. 2. 0. 3.67 2. 2. 0. 3. 6. 0. 2. 4.65 0. 4. 2.\n</code></pre> <p>The only validation implemented is the number of triplets. The command takes \\(\\(4n\\)\\) parameters and interprets them accordingly. Please make sure the definition is correct.</p>"},{"location":"Library/Section/SectionNM/NM3D2/#remarks","title":"Remarks","text":"<p>The true hardening ratio is defined as</p> \\[ \\dfrac{H+K}{1+H+K}, \\] <p>given that \\(\\(H\\)\\) and \\(\\(K\\)\\) are hardening ratios based on plastic strain.</p>"},{"location":"Library/Section/SectionNM/SectionNM/","title":"SectionNM","text":"<p>\\(\\(N\\)\\)-\\(\\(M\\)\\) Interaction Abstract Section</p>"},{"location":"Library/Section/SectionNM/SectionNM/#reference","title":"Reference","text":"<ol> <li>10.1007/978-94-007-6573-3_3</li> <li>10.1002/nme.1620371506</li> </ol> <p>Please note the formulation is similar but different from the one shown in the above references.</p>"},{"location":"Library/Section/SectionNM/SectionNM/#remarks","title":"Remarks","text":"<p>Apart from the provided sections, other interaction surfaces can be defined.</p> <p>One can define a derived class based on, for example, <code>SurfaceNM2D</code>, and implement methods.</p> C++<pre><code>[[nodiscard]] double compute_sf(const vec&amp;, const vec&amp;) const;\n[[nodiscard]] vec compute_dsf(const vec&amp;, const vec&amp;) const;\n[[nodiscard]] mat compute_ddsf(const vec&amp;, const vec&amp;) const;\n</code></pre> <p>All methods take the normalised shifted resistance \\(\\(\\mathbf{s}=\\mathbf{q}-\\mathbf{\\beta}\\)\\) and equivalent plastic  strain \\(\\(\\alpha\\)\\) as input where \\(\\(\\mathbf{q}\\)\\) is the normalised nodal resistance and \\(\\(\\mathbf{\\beta}\\)\\) is the back  resistance which is similar to the concept of back stress.</p>"},{"location":"Library/Solver/BFGS/","title":"BFGS","text":"<p>The <code>BGFS</code> solver uses the rank two update algorithm BGFS. Alternatively, the limited memory version can also be switched on.</p>"},{"location":"Library/Solver/BFGS/#syntax","title":"Syntax","text":"Text Only<pre><code>solver BFGS (1)\nsolver LBFGS (1) [2]\n# (1) int, unique solver tag\n# [2] int, number of steps stored, default: 20\n</code></pre>"},{"location":"Library/Solver/MPDC/","title":"MPDC","text":"<p>Multiple Points Displacement Control</p>"},{"location":"Library/Solver/MPDC/#syntax","title":"Syntax","text":"Text Only<pre><code>solver MPDC (1)\nsolver DisplacementControl (1)\n# (1) int, unique solver tag\n</code></pre>"},{"location":"Library/Solver/MPDC/#remarks","title":"Remarks","text":"<ol> <li>The <code>MPDC</code> solver is automatically enabled if the current step has an active displacement load.</li> </ol>"},{"location":"Library/Solver/Newton/","title":"Newton","text":"<p>The <code>Newton</code> solver defines a classic (modified) Newton-Raphson solver.</p>"},{"location":"Library/Solver/Newton/#syntax","title":"Syntax","text":"Text Only<pre><code>solver Newton (1)\nsolver modifiedNewton (1)\nsolver mNewton (1)\n# (1) int, unique solver tag\n</code></pre>"},{"location":"Library/Solver/Newton/#remarks","title":"Remarks","text":"<ol> <li>The modified Newton method only assembles tangent stiffness at the beginning of each sub-step. Automatic stepping can    be enabled to obtain optimized computational workload.</li> <li>The Aitken acceleration is automatically enabled in the modified Newton method.</li> </ol>"},{"location":"Library/Solver/Ramm/","title":"Ramm","text":"<p>Arc Length Algorithm Using Ramm's Approach</p> <p>The Ramm's version of arc length algorithm is implemented. This solver can only be used in solving static problems.</p>"},{"location":"Library/Solver/Ramm/#syntax","title":"Syntax","text":"Text Only<pre><code>solver Ramm (1) [2] [3]\n# (1) int, unique solver tag\n# [2] double, arc length, default: 0.1\n# [3] bool string, fixed arc length switch, default: false\n</code></pre>"},{"location":"Library/Solver/Ramm/#remarks","title":"Remarks","text":"<ol> <li>A proper arc length shall be manually input to achieve an efficient analysis.</li> <li>Often the arc length is allowed to change depending on the smoothness of the turning point. It is not recommended    fixing arc length.</li> <li>The computation of determinant is involved. A proper matrix storage scheme shall be activated. For dense matrix    storage, please use asymmetric schemes by <code>set symm_mat false</code>. For sparse solvers, please use <code>MUMPS</code> only.</li> </ol>"},{"location":"Library/Step/ArcLength/","title":"ArcLength","text":""},{"location":"Library/Step/ArcLength/#syntax","title":"Syntax","text":"Text Only<pre><code>step ArcLength (1) (2) (3) (4)\n# (1) int, unique step tag\n# (2) int, reference node tag\n# (3) int, reference dof tag\n# (4) double, reference magnitude of applied load\n</code></pre>"},{"location":"Library/Step/ArcLength/#remarks","title":"Remarks","text":"<ol> <li>A <code>Ramm</code> solver with default parameters is automatically enabled if no valid <code>Ramm</code> solver is    defined. Not all storage schemes are supported, please check <code>Ramm</code> documentation.</li> </ol>"},{"location":"Library/Step/Buckle/","title":"Buckle","text":"<p>The <code>Buckle</code> step defines a linear buckling analysis.</p>"},{"location":"Library/Step/Buckle/#syntax","title":"Syntax","text":"Text Only<pre><code>step Buckle (1)\nstep Buckling (1)\n# (1) int, unique step tag\n</code></pre>"},{"location":"Library/Step/Dynamic/","title":"Dynamic","text":""},{"location":"Library/Step/Dynamic/#syntax","title":"Syntax","text":"Text Only<pre><code>step dynamic (1) (2)\n# (1) int, unique step tag\n# (2) double, step size\n</code></pre>"},{"location":"Library/Step/Dynamic/#remarks","title":"Remarks","text":"<ol> <li>Displacement control solver <code>MPDC</code> is automatically enabled if a displacement load is active.</li> <li>The <code>Newmark</code> is automatically enabled if there is no valid integrator defined.</li> </ol>"},{"location":"Library/Step/Frequency/","title":"Frequency","text":"<p>The (generalized) eigenvalue problem is handled in the <code>Frequency</code> step. To define a valid step, please use the following command.</p> Text Only<pre><code>step frequency (1) (2)\n# (1) int, unique step tag\n# (2) int, number of eigen modes to be solved\n</code></pre> <p>To successfully run an eigen analysis, the system shall be symmetric, otherwise complex eigen values are computed. This typically requires the stiffness matrix to be symmetric. Besides, it must have</p> <ol> <li>a positive definite stiffness matrix,</li> <li>a semi-positive definite mass matrix.</li> </ol>"},{"location":"Library/Step/Frequency/#remarks","title":"Remarks","text":"<ol> <li>The symmetric banded storage uses <code>_pbsv</code> solver which only accepts symmetric positive definite banded matrix. If    the <code>Frequency</code> fails to compute the required eigen modes, please use other storage schemes.</li> <li>The computed eigenvalue is the eigenvalue of the system. In the field of structural dynamics, it is \\(\\(\\omega^2\\)\\).    The (angular) frequency and period can be computed accordingly.</li> <li>The constrained (generalized) eigenvalue problems cannot be handled when the constraints are implemented via Lagrange    multiplier method. If the system contains constraints, users shall make sure they are applied via the penalty    function method.</li> </ol>"},{"location":"Library/Step/Frequency/#feast-solver","title":"FEAST Solver","text":"<p>By default, the <code>ARPACK</code> solver is used to solve the generalized eigen problem.</p> <p>The FEAST Eigenvalue Solver can also be used. To switch, one can use</p> Text Only<pre><code>solver FEAST (1) (2) (3)\n# (1) int, unique solver tag\n# (2) int, number of eigen modes\n# (3) double, radius\n</code></pre> <p>Currently, the <code>FEAST</code> solver can be applied to full, banded and sparse storage. For banded storage, it is necessary to use the <code>SPIKE</code> solver.</p> Text Only<pre><code>set system_solver SPIKE\n</code></pre>"},{"location":"Library/Step/Frequency/#example","title":"Example","text":"<p>Consider a massless elastic cantilever beam with lumped end mass. Assume the length is \\(\\(L=2.84\\)\\), the elastic modulus is \\(\\(E=94.13\\)\\), the moment of inertia is \\(\\(I=1.34\\)\\) and the lumped mass is \\(\\(M=5.76\\)\\) so that</p> \\[ \\omega^2=\\dfrac{3EI}{ML^3}=\\dfrac{3\\times94.13\\times1.34}{5.76\\times2.84^3}=2.8680. \\] Text Only<pre><code>node 1 0 0\nnode 2 0 2.84\nmaterial Elastic1D 1 94.13\nelement EB21 1 1 2 1 1.34 1\nmass 2 2 5.76 1\nfix 1 P 1\nrecorder 1 hdf5 Eigen\nstep frequency 1 1\nanalyze\npeek eigenvalue\nexit\n</code></pre> <p>The output is</p> Text Only<pre><code>+--------------------------------------------------+\n|   __        __        suanPan is an open source  |\n|  /  \\      |  \\          FEM framework (64-bit)  |\n|  \\__       |__/  __   __          Acrux (0.1.0)  |\n|     \\ |  | |    |  \\ |  |                        |\n|  \\__/ |__| |    |__X |  |     maintained by tlc  |\n|                             all rights reserved  |\n+--------------------------------------------------+\n\nEigenvalues:\n   2.8680\n\nFinished in 0.005 seconds.\n</code></pre>"},{"location":"Library/Step/Optimization/","title":"Optimization","text":"<p>Structural Optimization Step</p>"},{"location":"Library/Step/Optimization/#syntax","title":"Syntax","text":"Text Only<pre><code>step Optimization (1)\n# (1) int, unique step tag\n</code></pre> <p>It shall be noted all previously defined steps will be analyzed by the end of the <code>ESO</code> step.</p>"},{"location":"Library/Step/Static/","title":"Static","text":"<p>To define a static analysis, the <code>Static</code> step shall be used.</p> Text Only<pre><code>step static (1) [2]\n# (1) int, unique step tag\n# [2] double, step length, default: 1.0\n</code></pre>"},{"location":"Library/Step/Static/#remarks","title":"Remarks","text":"<ol> <li>Unlike <code>ABAQUS</code>, all time lengths defined are absolute time. There is no so-called \"step time\", which is related to    some normalized time concept in <code>ABAQUS</code>.</li> <li>The <code>Static</code> step supports all matrix storage schemes.</li> <li>Displacement control solver <code>MPDC</code> is automatically enabled if a displacement load is active.</li> </ol>"}]}